<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 12:55:11 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
MXBean (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="MXBean (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MXBean.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/management/MBeanTrustPermission.html" title="javax.management 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../javax/management/NotCompliantMBeanException.html" title="javax.management 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/management/MXBean.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="MXBean.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;必需&nbsp;|&nbsp;<A HREF="#annotation_type_optional_element_summary">可选</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#annotation_type_element_detail">元素</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.management</FONT>
<BR>
注释类型 MXBean</H2>
<HR>
<DL>
<DT><PRE><FONT SIZE="-1"><A HREF="../../java/lang/annotation/Documented.html" title="java.lang.annotation 中的注释">@Documented</A>
<A HREF="../../java/lang/annotation/Retention.html" title="java.lang.annotation 中的注释">@Retention</A>(<A HREF="../../java/lang/annotation/Retention.html#value()">value</A>=<A HREF="../../java/lang/annotation/RetentionPolicy.html#RUNTIME">RUNTIME</A>)
<A HREF="../../java/lang/annotation/Target.html" title="java.lang.annotation 中的注释">@Target</A>(<A HREF="../../java/lang/annotation/Target.html#value()">value</A>=<A HREF="../../java/lang/annotation/ElementType.html#TYPE">TYPE</A>)
</FONT>public @interface <B>MXBean</B></DL>
</PRE>

<P>
<p>显式地标记某一接口是否为 MXBean 接口的注释。默认情况下，如果接口的名称以 <code>MXBean</code> 结尾（如 <code>SomethingMXBean</code>），则该接口为 MXBean 接口。以下接口是 MXBean 接口：</p>

    <pre>
    public interface WhatsitMXBean {}

    &#64;MXBean
    public interface Whatsit1Interface {}

    &#64;MXBean(true)
    public interface Whatsit2Interface {}
    </pre>

<p>以下接口不是 MXBean 接口：</p>

    <pre>
    public interface Whatsit3Interface{}

    &#64;MXBean(false)
    public interface MisleadingMXBean {}
    </pre>

<h3><a name="MXBean-spec">MXBean 规范</a></h3>

<p>MXBean 概念提供了一种对 MBean 进行编码的简单方式，这种方式只引用一组预定义的类型，这些类型由 <A HREF="../../javax/management/openmbean/package-summary.html"><CODE>javax.management.openmbean</CODE></A> 定义。使用这种方式可以确保任何客户端（包括远程客户端）都可以使用您的 MBean，无需客户端具有访问表示 MBean 类型的<em>特定于模型的类</em> 的权限。</p>

<p>与 Standard MBean 概念相比，这些概念更容易理解一些。以下是将管理对象表示为 Standard MBean 和 MXBean 的方式：</p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
public interface MemoryPool<b>MBean</b> {
String getName();
MemoryUsage getUsage();
    // ...
}
          </pre></td>
        <td><pre>
public interface MemoryPool<b>MXBean</b> {
String getName();
MemoryUsage getUsage();
    // ...
}
          </pre></td>
      </tr>
    </table>

<p>如您所见，这些定义非常相似。唯一的不同是命名接口的约定将使用 MXBean 的 <code><em>Something</em> MXBean</code>，而不是 Standard MBean 的 <code><em>Something</em> MBean</code>。</p>

<p>在此管理对象中，有一种类型为 <A HREF="../../java/lang/management/MemoryUsage.html" title="java.lang.management 中的类"><CODE>MemoryUsage</CODE></A> 的称作 <code>Usage</code> 的属性。此类属性的要点是，它给出了一组数据项的统一快照。例如，它可能包括内存池中目前已使用的内存量，以及内存池的当前最大量。如果这些是单独的项（通过单独的 <A HREF="../../javax/management/MBeanServer.html#getAttribute(javax.management.ObjectName, java.lang.String)"><CODE>getAttribute</CODE></A> 调用获得），那么我们可以在不同时间查看不一致的值。我们可能获得大于 <code>max</code> 值的 <code>used</code> 值。</p>

<p>因此，可以按如下形式定义 <code>MemoryUsage</code>：</p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
public class MemoryUsage <b>implements Serializable</b> {
// standard JavaBean conventions with getters

public MemoryUsage(long init, long used,
long committed, long max) {...}
long getInit() {...}
long getUsed() {...}
long getCommitted() {...}
long getMax() {...}
}
          </pre></td>
        <td><pre>
public class MemoryUsage {
// standard JavaBean conventions with getters
<b>@ConstructorProperties({&quot;init&quot;, &quot;used&quot;, &quot;committed&quot;, &quot;max&quot;})</b>
public MemoryUsage(long init, long used,
long committed, long max) {...}
long getInit() {...}
long getUsed() {...}
long getCommitted() {...}
long getMax() {...}
}
          </pre></td>
      </tr>
    </table>

<p>两种情况下的定义是相同的（使用 MXBean 的情况除外），不再需要将 <code>MemoryUsage</code> 标记为 <code>Serializable</code>（尽管可以这样做）。另一方面，我们添加了一个 <code>@ConstructorProperties</code> 注释，以便将构造方法参数链接到相应的获取方法。下面将看到更多这方面的信息。</p>

<p><code>MemoryUsage</code> 是一个<em>特定于模型的类</em>。使用 Standard MBean 时，如果 <code>MemoryUsage</code> 类对于 MBean Server 的客户端为未知类，那么该客户端将无法访问 <code>Usage</code> 属性。假定该客户端是一个基于 JMX 技术的通用控制台。那么必须使用该控制台可以连接到的每个应用程序的特定于模型的类来配置此控制台。对于未用 Java 语言编写的客户端，问题甚至更为严重。此时可能无法通知客户端 <code>MemoryUsage</code> 是什么样的。</p>

<p>这就是 MXBean 与 Standard MBean 的不同之处。尽管我们以几乎完全相同的方式定义了管理接口，但 MXBean 框架会从 Java 平台将特定于模型的类<em>转换</em> 为标准类。使用数组以及标准 <A HREF="../../javax/management/openmbean/package-summary.html"><CODE>javax.management.openmbean</CODE></A> 包中的 <A HREF="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean 中的接口"><CODE>CompositeData</CODE></A> 和 <A HREF="../../javax/management/openmbean/TabularData.html" title="javax.management.openmbean 中的接口"><CODE>TabularData</CODE></A> 类，就有可能只使用标准类来构建任意复杂度的数据结构。</p>

<p>如果比较两种模型的客户端的外观，这将变得更清楚：</p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
String name = (String)
mbeanServer.<A HREF="../../javax/management/MBeanServer.html#getAttribute(javax.management.ObjectName, java.lang.String)"><CODE>getAttribute</CODE></A>(objectName, &quot;Name&quot;);
<b>MemoryUsage</b> usage = (<b>MemoryUsage</b>)
mbeanServer.getAttribute(objectName, &quot;Usage&quot;);
<b>long used = usage.getUsed();</b>
          </pre></td>
        <td><pre>
String name = (String)
mbeanServer.<A HREF="../../javax/management/MBeanServer.html#getAttribute(javax.management.ObjectName, java.lang.String)"><CODE>getAttribute</CODE></A>(objectName, &quot;Name&quot;);
<b><A HREF="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean 中的接口"><CODE>CompositeData</CODE></A></b> usage = (<b>CompositeData</b>)
mbeanServer.getAttribute(objectName, &quot;Usage&quot;);
<b>long used = (Long) usage.<A HREF="../../javax/management/openmbean/CompositeData.html#get(java.lang.String)"><CODE>get</CODE></A>(&quot;used&quot;);</b>
          </pre></td>
    </table>

<p>对于具有简单类型（如 <code>String</code>）的属性，代码是相同的。但对于具有复杂类型的属性，Standard MBean 代码要求客户端知道特定于模型的类 <code>MemoryUsage</code>，而 MXBean 代码则不需要任何非标准类。</p>

<p>此处显示的客户端代码对于 MXBean 客户端而言更加复杂。但是，如果客户端确实知道该模型、此处的接口 <code>MemoryPoolMXBean</code> 和 <code>MemoryUsage</code> 类，则该客户端可以构造一个<em>代理</em>。在预先知道模型的情况下，建议您使用这种方式与管理对象进行交互，不必考虑正在使用的是 Standard MBean 还是 MXBean：</p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
MemoryPool<b>MBean</b> proxy =
JMX.<b><A HREF="../../javax/management/JMX.html#newMBeanProxy(javax.management.MBeanServerConnection, javax.management.ObjectName, java.lang.Class)"><CODE>newMBeanProxy</CODE></A></b>(
mbeanServer,
objectName,
MemoryPool<b>MBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre></td>
        <td><pre>
MemoryPool<b>MXBean</b> proxy =
JMX.<b><A HREF="../../javax/management/JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection, javax.management.ObjectName, java.lang.Class)"><CODE>newMXBeanProxy</CODE></A></b>(
mbeanServer,
objectName,
MemoryPool<b>MXBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre></td>
      </tr>
    </table>

<p>对于 Standard MBean 和 MXBean 而言，实现 MemoryPool 对象的方式是类似的。</p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
public class MemoryPool
implements MemoryPool<b>MBean</b> {
public String getName() {...}
public MemoryUsage getUsage() {...}
    // ...
}
          </pre></td>
        <td><pre>
public class MemoryPool
implements MemoryPool<b>MXBean</b> {
public String getName() {...}
public MemoryUsage getUsage() {...}
    // ...
}
          </pre></td>
      </tr>
    </table>

<p>在两种情况下，在 MBean Server 中注册 MBean 的方式是相同的：</p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
{
MemoryPool<b>MBean</b> pool = new MemoryPool();
mbeanServer.<A HREF="../../javax/management/MBeanServer.html#registerMBean(java.lang.Object, javax.management.ObjectName)"><CODE>registerMBean</CODE></A>(pool, objectName);
}
          </pre></td>
        <td><pre>
{
MemoryPool<b>MXBean</b> pool = new MemoryPool();
mbeanServer.<A HREF="../../javax/management/MBeanServer.html#registerMBean(java.lang.Object, javax.management.ObjectName)"><CODE>registerMBean</CODE></A>(pool, objectName);
}
          </pre></td>
      </tr>
    </table>


<h2><a name="mxbean-def">MXBean 的定义</a></h2>

<p>MXBean 是一种 MBean。MXBean 对象可以直接在 MBean Server 中注册，也可以用作在 MBean Server 中注册的 <A HREF="../../javax/management/StandardMBean.html" title="javax.management 中的类"><CODE>StandardMBean</CODE></A> 和结果 MBean 的参数。</p>

<p>当使用 <A HREF="../../javax/management/MBeanServer.html" title="javax.management 中的接口"><CODE>MBeanServer</CODE></A> 接口的 <code>registerMBean</code> 或 <code>createMBean</code> 方法在 MBean Server 中注册某个对象时，要检查该对象的类来确定 MBean 的类型：</p>

    <ul>
<li>如果该类实现了接口 <A HREF="../../javax/management/DynamicMBean.html" title="javax.management 中的接口"><CODE>DynamicMBean</CODE></A>，则 MBean 是一个 Dynamic MBean。注意，因为 <code>StandardMBean</code> 类实现了此接口，所以这种情况可应用于使用 <code>StandardMBean</code> 类创建的 Standard MBean 或 MXBean。</li>

<li>否则，如果该类与 Standard MBean 命名约定匹配，则 MBean 是一个 Standard MBean。</li>

<li>否则它可能是一个 MXBean。检查由对象实现的那组接口，以获得具有以下特性的接口：

        <ul>
<li>具有一个类名称 <code><em>S</em>MXBean</code>（其中的 <code><em>S</em></code> 为非空字符串），且没有注释 <code>@MXBean(false)</code>；</li>
<li>具有注释 <code>@MXBean(true)</code> 或只有 <code>@MXBean</code>。</li>
        </ul>

如果确实有这样一个接口，或者如果有一个作为其他所有接口的子接口的接口，则该对象是一个 MXBean。相关接口是 <em>MXBean 接口</em>。在上述示例中，MXBean 接口是 <code>MemoryPoolMXBean</code>。

<li>如果这些条件都不满足，则 MBean 无效，并且试图对其进行注册将生成 <A HREF="../../javax/management/NotCompliantMBeanException.html" title="javax.management 中的类"><CODE>NotCompliantMBeanException</CODE></A>。
    </ul>

<p>作为参数出现的每个 Java 类型或 MXBean 接口中某一方法的返回类型在使用下面的规则进行转换时，必须是<em>可转换的</em>。此外，参数必须是<em>可重新构造的</em>，正如下面所定义的那样。</p>

<p>尝试构造不符合上述规则的 MXBean 将产生一个异常。</p>


<h2><a name="naming-conv">命名约定</a></h2>

<p>与在 Standard MBean 中一样，相同的命名约定可应用于 MXBean 中的各种方法：</p>

    <ol>
<li>方法 <code><em>T</em> get<em>N</em>()</code> 明确说明存在一个名为 <code><em>N</em></code> 的可读属性，该方法中的 <code><em>T</em></code> 是一种 Java 类型（不可以为 <code>void</code>），<code><em>N</em></code> 为非空字符串。该属性的 Java 类型和 Open 类型是根据下面的映射规则确定的。在查找获取方法时，将忽略从 <code>Object</code> 继承的方法 <code>final Class getClass()</code>。</li>

<li>方法 <code>boolean is<em>N</em>()</code> 明确说明存在一个名为 <code><em>N</em></code> 的可读属性，且该属性的 Java 类型为 <code>boolean</code>，Open 类型为 <code>SimpleType.Boolean</code>。</li>

<li>方法 <code>void set<em>N</em>(<em>T</em> x)</code> 明确说明存在一个名为 <code><em>N</em></code> 的可写属性。该属性的 Java 类型和 Open 类型是根据下面的映射规则确定的。（当然，参数的名称 <code>x</code> 无关紧要。）</li>

<li>其他每个方法都明确说明存在一个名称与该方法相同的操作。返回值和每个参数的 Java 类型和 Open 类型是根据下面的映射规则确定的。</li>
    </ol>

<p><code>get<em>N</em></code> 和 <code>is<em>N</em></code> 的规则共同定义了 <em>getter</em> 的概念。<code>set<em>N</em></code> 的规则定义了 <em>setter</em> 的概念。</p>

<p>两个获取方法具有相同名称或者两个设置方法具有相同名称是一种错误。如果一个获取方法和一个设置方法具有相同的名称，则二者的类型 <code><em>T</em></code> 必须相同。在这种情况下，属性为 read/write。如果只有一个获取方法或只有一个设置方法，则属性分别为 read-only 或 write-only。</p>


<h2><a name="mapping-rules">类型映射规则</a></h2>

<p>MXBean 是一种 Open MBean，由 <A HREF="../../javax/management/openmbean/package-summary.html"><CODE>javax.management.openmbean</CODE></A> 包定义。这意味着属性类型、操作参数和操作返回值都必须是可以使用 <em>Open Types</em>（即 <A HREF="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean 中的类"><CODE>OpenType</CODE></A> 的四个标准子类）描述的。MXBean 通过将 Java 类型映射为 Open Types 来实现此操作。</p>

<p>对于每个 Java 类型 <em>J</em>，MXBean 映射关系根据以下信息来描述：</p>

    <ul>
<li>相应的 Open Type，即 <em>opentype(J)</em>。这是 <A HREF="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean 中的类"><CODE>OpenType</CODE></A> 的子类的一个实例。</li>
<li><em>映射的</em> Java 类型（<em>opendata(J)</em>）对于任何给定的 <em>opentype(J)</em> 都是相同的。这是一个 Java 类。</li>
<li>将值从类型 <em>J</em> 转换为类型 <em>opendata(J)</em> 的方式。</li>
<li>将值从类型 <em>opendata(J)</em> 转换为类型 <em>J</em> 的方式（如果可以转换）。</li>
    </ul>

<p>例如，对于 Java 类型 <code>List&lt;String&gt;</code>：</p>

    <ul>
<li>Open Type <em>opentype(</em><code>List&lt;String&gt;</code><em>)</em> 是 <A HREF="../../javax/management/openmbean/ArrayType.html" title="javax.management.openmbean 中的类"><CODE>ArrayType</CODE></A><code>(1, </code><A HREF="../../javax/management/openmbean/SimpleType.html#STRING"><CODE>SimpleType.STRING</CODE></A><code>)</code>，表示 <code>String</code> 的一个一维数组。</li>
<li>映射的 Java 类型 <em>opendata(</em><code>List&lt;String&gt;</code><em>)</em> 是 <code>String[]</code>。</li>
<li>使用 <A HREF="../../java/util/List.html#toArray(T[])"><CODE>List.toArray(new String[0])</CODE></A> 可以将 <code>List&lt;String&gt;</code> 转换为 <code>String[]</code>。</li>
<li>使用 <A HREF="../../java/util/Arrays.html#asList(T...)"><CODE>Arrays.asList</CODE></A> 可以将 <code>String[]</code> 转换为 <code>List&lt;String&gt;</code>。</li>
    </ul>

<p>如果没有用来从 <em>J</em> 中派生 <em>opentype(J)</em> 的映射规则，则 <em>J</em> 不能是 MXBean 接口中方法参数或返回值的类型。</p>

<p>如果有办法将 <em>opendata(J)</em> 转换回 <em>J</em>，则我们说 <em>J</em> 是<em>可重新构造的</em>。MXBean 接口中的所有方法参数必须是可重新构造的，这是因为当 MXBean 框架调用某一方法时，它需要将这些参数从 <em>opendata(J)</em> 转换为 <em>J</em>。在由 <A HREF="../../javax/management/JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection, javax.management.ObjectName, java.lang.Class)"><CODE>JMX.newMXBeanProxy</CODE></A> 生成的代理中，MXBean 接口中方法的返回值必须是可重新构造的。</p>

<p>所有 Java 类型和 Open Types 都允许使用 null 值，不可能使用 null 值的一些基本 Java 类型除外。当从类型 <em>J</em> 转换为类型 <em>opendata(J)</em> 或从类型 <em>opendata(J)</em> 转换为类型 <em>J</em> 时，null 值被映射为一个 null 值。</p>

<p>下表总结了类型映射规则。</p>

    <table border="1" cellpadding="5">
      <tr>
<th>Java 类型 <em>J</em></th>
<th><em>opentype(J)</em></th>
<th><em>opendata(J)</em></th>
      </tr>
      <tbody cellvalign="top">
        <tr>
<td><code>int</code>、<code>boolean</code> 等<br>（8 个基本 Java 类型）</td>
<td><code>SimpleType.INTEGER</code>、<br><code>SimpleType.BOOLEAN</code> 等</td>
<td><code>Integer</code>、<code>Boolean</code> 等<br>（相应的 boxed 类型）</td>
        </tr>
        <tr>
<td><code>Integer</code>、<code>ObjectName</code> 等<br>（<A HREF="../../javax/management/openmbean/SimpleType.html" title="javax.management.openmbean 中的类"><CODE>SimpleType</CODE></A> 包含的类型）</td>
<td>相应的 <code>SimpleType</code></td>
<td><em>J</em>，相同类型</td>
        </tr>
        <tr>
<td><code>int[]</code> 等<br>（具有<br>基本元素类型的一维数组）</td>
<td><code>ArrayType.getPrimitiveArrayType(int[].class)</code> 等</td>
<td><em>J</em>，相同类型</td>
        <tr>
<td><em>E</em><code>[]</code><br>（具有非基本元素类型 <em>E</em> 的数组；这包括 <code>int[][]</code>，其中 <em>E</em> 为 <code>int[]</code>）</td>
<td><code>ArrayType.getArrayType(</code><em>opentype(E)</em><code>)</code></td>
<td><em>opendata(E)</em><code>[]</code></td>
        </tr>
        <tr>
<td><code>List&amp;lt;</code><em>E</em><code>&amp;gt;</code><br> <code>Set&amp;lt;</code><em>E</em><code>&amp;gt;</code><br> <code>SortedSet&amp;lt;</code><em>E</em><code>&amp;gt;</code>（参见以下内容）</td>
<td>与 <em>E</em><code>[]</code> 相同</td>
<td>与 <em>E</em><code>[]</code> 相同</td>
        </tr>
        <tr>
<td>枚举 <em>E</em><br>（在 Java 中被声明为 <code>enum </code><em>E</em> <code>{...}</code>）</td>
<td><code>SimpleType.STRING</code></td>
<td><code>String</code></td>
        </tr>
        <tr>
<td><code>Map&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code><br> <code>SortedMap&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code></td>
<td><A HREF="../../javax/management/openmbean/TabularType.html" title="javax.management.openmbean 中的类"><CODE>TabularType</CODE></A><br>（参见以下内容）</td>
<td><A HREF="../../javax/management/openmbean/TabularData.html" title="javax.management.openmbean 中的接口"><CODE>TabularData</CODE></A><br>（参见以下内容）</td>
        </tr>
        <tr>
<td>MXBean 接口</td>
<td><code>SimpleType.OBJECTNAME</code><br>（参见以下内容）</td>
<td><A HREF="../../javax/management/ObjectName.html" title="javax.management 中的类"><CODE>ObjectName</CODE></A><br>（参见以下内容）</td>
        </tr>
        <tr>
<td>任何其他类型</td>
<td><A HREF="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean 中的类"><CODE>CompositeType</CODE></A>，如果可能<br>（参见以下内容）</td>
<td><A HREF="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean 中的接口"><CODE>CompositeData</CODE></A></td>
      </tbody>
    </table>

<p>以下几节将详细解释这些规则。</p>


<h3>基本类型的映射</h3>

<p>8 种基本 Java 类型（<code>boolean</code>、<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>char</code>）都可映射到 <code>java.lang</code> 中的相应 boxed 类型，即 <code>Boolean</code>、<code>Byte</code> 等。Open Type 是相应的 <code>SimpleType</code>。因此，<em>opentype(</em><code>long</code><em>)</em> 是 <code>SimpleType.LONG</code>，<em>opendata(</em><code>long</code><em>)</em> 是 <code>java.lang.Long</code>。</p>

<p>诸如 <code>long[]</code> 之类的基本类型的数组可以直接表示为一种 Open Type。因此，<em>openType(</em><code>long[]</code><em>)</em> 是 <code>ArrayType.getPrimitiveArrayType(long[].class)</code>，<em>opendata(</em><code>long[]</code><em>)</em> 是 <code>long[]</code>。</p>

<p>实际上，普通 <code>int</code> 和 <code>Integer</code> 等之间的差异不会显现出来，因为 JMX API 中的操作总是在 Java 对象上进行，而不是在基本类型上进行。但是，数组中<em>确实</em> 存在这种差异。</p>


<h3>集合的映射（<code>List&amp;lt;</code><em>E</em><code>&amp;gt;</code> 等）</h3>

<p><code>List&amp;lt;</code><em>E</em><code>&amp;gt;</code> 或 <code>Set&amp;lt;</code><em>E</em><code>&amp;gt;</code>（如 <code>List&lt;String&gt;</code> 或 <code>Set&lt;ObjectName&gt;</code>）以相同方式映射为相同元素类型的数组，如 <code>String[]</code> 或 <code>ObjectName[]</code>。</p>

<p>也可以用相同方式将 <code>SortedSet&amp;lt;</code><em>E</em><code>&amp;gt;</code> 映射为 <em>E</em><code>[]</code>，但是只有在 <em>E</em> 是实现 <A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口"><CODE>Comparable</CODE></A> 的类或接口时，它才是可转换的。因此，<code>SortedSet&lt;String&gt;</code> 或 <code>SortedSet&lt;Integer&gt;</code> 是可转换的，但 <code>SortedSet&lt;int[]&gt;</code> 或 <code>SortedSet&lt;List&lt;String&gt;&amp;gt;</code> 是不可转换的。如果 <code>SortedSet</code> 实例包含一个非 null <A HREF="../../java/util/SortedSet.html#comparator()"><CODE>comparator()</CODE></A>，那么对该实例的转换将失败，并抛出 <code>IllegalArgumentException</code>。</p>

<p><code>List&amp;lt;</code><em>E</em><code>&amp;gt;</code> 被重新构造为一个 <code>java.util.ArrayList&amp;lt;</code><em>E</em><code>&amp;gt;</code>；<code>Set&amp;lt;</code><em>E</em><code>&amp;gt;</code> 被重新构造为一个 <code>java.util.HashSet&amp;lt;</code><em>E</em><code>&amp;gt;</code>；<code>SortedSet&amp;lt;</code><em>E</em><code>&amp;gt;</code> 被重新构造为一个 <code>java.util.TreeSet&amp;lt;</code><em>E</em><code>&amp;gt;</code>。</p>


<h3>映射的映射关系（<code>Map&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code> 等）</h3>

<p><code>Map&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code> 或 <code>SortedMap&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code>（如 <code>Map&lt;String,ObjectName&gt;</code>）包含 Open Type <A HREF="../../javax/management/openmbean/TabularType.html" title="javax.management.openmbean 中的类"><CODE>TabularType</CODE></A>，并且可映射为一个 <A HREF="../../javax/management/openmbean/TabularData.html" title="javax.management.openmbean 中的接口"><CODE>TabularData</CODE></A>。<code>TabularType</code> 有两个称为 <code>key</code> 和 <code>value</code> 的项。<code>key</code> 的 Open Type 为 <em>opentype(K)</em>，<code>value</code> 的 Open Type 为 <em>opentype(V)</em>。<code>TabularType</code> 的索引是单个项 <code>key</code>。</p>

<p>例如，用于 <code>Map&lt;String,ObjectName&gt;</code> 的 <code>TabularType</code> 可以使用如下代码构造：</p>

    <pre>
String typeName =
&quot;java.util.Map&lt;java.lang.String, javax.management.ObjectName&gt;&quot;;
String[] keyValue =
new String[] {&quot;key&quot;, &quot;value&quot;};
OpenType[] openTypes =
new OpenType[] {SimpleType.STRING, SimpleType.OBJECTNAME};
CompositeType rowType =
new CompositeType(typeName, typeName, keyValue, keyValue, openTypes);
TabularType tabularType =
new TabularType(typeName, typeName, rowType, new String[] {&quot;key&quot;});
    </pre>

<p>此处的 <code>typeName</code> 由下面将详细介绍的<a href="#type-names">类型名称规则</a>确定。

<p><code>SortedMap&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code> 以相同的方式映射，但只有在 <em>K</em> 是实现 <A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口"><CODE>Comparable</CODE></A> 的类或接口时才是可转换的。因此，<code>SortedMap&lt;String,int[]&gt;</code> 是可转换的，但 <code>SortedMap&lt;int[],String&gt;</code> 是不可转换的。如果 <code>SortedMap</code> 实例包含一个非 null <A HREF="../../java/util/SortedMap.html#comparator()"><CODE>comparator()</CODE></A>，那么该实例的转换将失败，并将抛出 <code>IllegalArgumentException</code>。</p>

<p><code>Map&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code> 被重新构造为一个 <code>java.util.HashMap&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code>；<code>SortedMap&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code> 被重新构造为一个 <code>java.util.TreeMap&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code>。</p>

<p><code>TabularData</code> 是一个接口。用于将 <code>Map&amp;lt;</code><em>K</em>,<em>V</em><code>&amp;gt;</code> 表示为 Open Data 的具体类是 <A HREF="../../javax/management/openmbean/TabularDataSupport.html" title="javax.management.openmbean 中的类"><CODE>TabularDataSupport</CODE></A>，或是实现作为 <code>TabularDataSupport</code> 序列化的 <code>TabularData</code> 的另一个类。</p>


<h3><a name="mxbean-map">MXBean 接口的映射</a></h3>

<p>MXBean 接口（或 MXBean 接口中引用的类型）可以引用另一个 MXBean 接口 <em>J</em>。这时 <em>opentype(J)</em> 是 <code>SimpleType.OBJECTNAME</code>，<em>opendata(J)</em> 是 <code>ObjectName</code>。</p>

<p>例如，假设您有两个如下所示的 MXBean 接口：</p>

    <pre>
public interface ProductMXBean {
public ModuleMXBean[] getModules();
}

public interface ModuleMXBean {
public ProductMXBean getProduct();
}
    </pre>

<p>实现 <code>ModuleMXBean</code> 接口的对象从其 <code>getProduct</code> 方法返回一个实现 <code>ProductMXBean</code> 接口的对象。<code>ModuleMXBean</code> 对象和返回的 <code>ProductMXBean</code> 对象都必须注册为相同 MBean Server 中的 MXBean。</p>

<p>方法 <code>ModuleMXBean.getProduct()</code> 定义了一个称为 <code>Product</code> 的属性。此属性的 Open Type 为 <code>SimpleType.OBJECTNAME</code>，并且相应的 <code>ObjectName</code> 值将是所引用的 <code>ProductMXBean</code> 在 MBean Server 中注册的名称。</p>

<p>如果为 <code>ModuleMXBean</code> 构造一个 MXBean 代理，并调用其 <code>getProduct()</code> 方法，则该代理将通过构造另一个 MXBean 代理将 <code>ObjectName</code> 映射回 <code>ProductMXBean</code>。更正式地说，当使用 <A HREF="../../javax/management/JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection, javax.management.ObjectName, java.lang.Class)"><CODE>JMX.newMXBeanProxy(mbeanServerConnection, objectNameX, interfaceX)</CODE></A> 构造一个代理需要将 <code>objectNameY</code> 映射回 <code>interfaceY</code>（另一个 MXBean 接口）时，可以使用 <code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameY, interfaceY)</code> 来完成此操作。该实现可以返回一个以前通过使用相同参数调用 <code>JMX.newMXBeanProxy</code> 创建的代理，或创建一个新代理。</p>

<p>通过对 <code>ModuleMXBean</code> 接口进行以下更改来解释反向映射：</p>

    <pre>
public interface ModuleMXBean {
public ProductMXBean getProduct();
public void setProduct(ProductMXBean c);
}
    </pre>

<p><code>setProduct</code> 方法的存在现在意味着 <code>Product</code> 属性为 read/write。与以前一样，该属性的值是一个 <code>ObjectName</code>。设置属性时，必须将 <code>ObjectName</code> 转换成 <code>setProduct</code> 方法所需要的 <code>ProductMXBean</code> 对象。此对象将是相同 MBean Server 中给定 <code>ObjectName</code> 的 MXBean 代理。</p>

<p>如果为 <code>ModuleMXBean</code> 构造一个 MXBean 代理并调用其 <code>setProduct</code> 方法，则该代理会将其 <code>ProductMXBean</code> 参数映射回 <code>ObjectName</code>。只有在该参数实际上是另一代理时，才能如此操作，这也可用于相同 <code>MBeanServerConnection</code> 中的 <code>ProductMXBean</code>。可以从另一代理（如返回 <code>ProductMXBean</code> 的代理的 <code>ModuleMXBean.getProduct()</code>）返回代理；或由 <A HREF="../../javax/management/JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection, javax.management.ObjectName, java.lang.Class)"><CODE>JMX.newMXBeanProxy</CODE></A> 创建代理；或使用带有调用处理程序的 <A HREF="../../java/lang/reflect/Proxy.html" title="java.lang.reflect 中的类"><CODE>Proxy</CODE></A> 创建，该调用处理程序是 <A HREF="../../javax/management/MBeanServerInvocationHandler.html" title="javax.management 中的类"><CODE>MBeanServerInvocationHandler</CODE></A> 或一个子类。</p>

<p>如果相同的 MXBean 在两个不同的 <code>ObjectName</code> 下注册，那么对哪个 MXBean 进行引用将是不明确的。因此，如果某个 MXBean 对象已经在 MBean Server 中注册并且尝试在相同 MBean Server 的另一名称下对其进行注册，结果将是抛出 <A HREF="../../javax/management/InstanceAlreadyExistsException.html" title="javax.management 中的类"><CODE>InstanceAlreadyExistsException</CODE></A>。通常不鼓励在多个名称下注册同一 MBean 对象，因为它显然不适合那些是 <A HREF="../../javax/management/NotificationBroadcaster.html" title="javax.management 中的接口"><CODE>NotificationBroadcaster</CODE></A> 的 MBean。</p>

<h3><a name="composite-map">其他类型的映射</a></h3>

<p>如果给定的 Java 类或接口 <em>J</em> 与上述表中的其他规则不匹配，则 MXBean 框架会尝试按照以下方式将其映射到 <A HREF="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean 中的类"><CODE>CompositeType</CODE></A>。此 <code>CompositeType</code> 的类型名称是根据以下<a href="#type-names">类型名称规则</a>确定的。</p>

<p>使用<a href="#naming-conv">上述</a>约定检查获取方法的类。（Getter 必须是公共实例方法。）如果没有获取方法，或任何获取方法都有一个不可转换的类型，则 <em>J</em> 是不可转换的。</p>

<p>如果至少有一个获取方法并且每个获取方法都有一个可转换的类型，则 <em>opentype(J)</em> 是一个 <code>CompositeType</code>，它对于每个获取方法都有一个项。如果获取方法为

    <blockquote>
<code><em>T</em> get<em>Name</em>()</code>
    </blockquote>

则 <code>CompositeType</code> 中的项被称为 <code>name</code>，且类型为 <em>opentype(T)</em>。例如，如果该项为

    <blockquote>
<code>String getOwner()</code>
    </blockquote>

则该项被称为 <code>owner</code>，且 Open Type 为 <code>SimpleType.STRING</code>。如果该获取方法为

    <blockquote>
<code>boolean is<em>Name</em>()</code>
    </blockquote>

则 <code>CompositeType</code> 中的项被称为 <code>name</code>，且类型为 <code>SimpleType.BOOLEAN</code>。</p>

<p>注意，第一个字符（或代码点）要转换为小写。这遵守 Java Bean 约定，由于历史原因，该约定与 Standard MBean 约定不同。在 Standard MBean 或 MXBean 接口中，方法 <code>getOwner</code> 定义了名为 <code>Owner</code> 的属性，而在 Java Bean 或映射的 <code>CompositeType</code> 中，方法 <code>getOwner</code> 定义了名为 <code>owner</code> 的属性或项。</p>

<p>如果两个方法生成了相同的项名称（如 <code>getOwner</code> 和 <code>isOwner</code>，或 <code>getOwner</code> 和 <code>getowner</code>），则该类型是不可转换的。</p>

<p>当 Open Type 为 <code>CompositeType</code> 时，相应的映射 Java 类型 (<em>opendata(J)</em>) 是 <A HREF="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean 中的接口"><CODE>CompositeData</CODE></A>。从 <em>J</em> 的实例到对应于刚描述的 <code>CompositeType</code> 的 <code>CompositeData</code> 的映射是按以下方式完成的。首先，如果 <em>J</em> 实现了接口 <A HREF="../../javax/management/openmbean/CompositeDataView.html" title="javax.management.openmbean 中的接口"><CODE>CompositeDataView</CODE></A>，则调用该接口的 <A HREF="../../javax/management/openmbean/CompositeDataView.html#toCompositeData(javax.management.openmbean.CompositeType)"><CODE>toCompositeData</CODE></A> 方法来完成转换。否则，通过对每个项调用获取方法并将其转换为相应的 Open Data 类型来构造 <code>CompositeData</code>。因此，如下所示的获取方法</p>

    <blockquote>
<code>List&lt;String&gt; getNames()</code>
    </blockquote>

<p>将被映射到名称为 &quot;<code>names</code>&quot; 且 Open Type 为 <code>ArrayType(1, SimpleType.STRING)</code> 的项。对 <code>CompositeData</code> 的转换将调用 <code>getNames()</code>，并将结果 <code>List&lt;String&gt;</code> 转换为项 &quot;<code>names</code>&quot; 的 <code>String[]</code>。</p>

<p><code>CompositeData</code> 是一个接口。用于将类型表示为 Open Data 的具体类是 <A HREF="../../javax/management/openmbean/CompositeDataSupport.html" title="javax.management.openmbean 中的类"><CODE>CompositeDataSupport</CODE></A>，或者是实现作为 <code>CompositeDataSupport</code> 序列化的 <code>CompositeData</code> 的另一个类。</p>


<h4>从 <code>CompositeData</code> 重新构造 Java 类型 <em>J</em> 的实例</h4>

<p>如果 <em>opendata(J)</em> 是 Java 类型 <em>J</em> 的 <code>CompositeData</code>，则要么从 <code>CompositeData</code> 重新构造 <em>J</em> 的实例，要么 <em>J</em> 是不可重新构造的。如果 <code>CompositeData</code> 中的任何项都是不可重新构造的，则 <em>J</em> 也是不可重新构造的。</p>

<p>对于任何给定的 <em>J</em>，都可参考以下规则来确定如何从 <code>CompositeData</code> 重新构造 <em>J</em> 的实例。列表中的第一个适用规则是将被使用的规则。</p>

    <ol>

<li><p>如果 <em>J</em> 拥有方法<br> <code>public static </code><em>J </em><code>from(CompositeData cd)</code><br>，则调用该方法来重新构造一个 <em>J</em> 实例。</p></li>

<li><p>否则，如果 <em>J</em> 至少有一个带有 <A HREF="../../java/beans/ConstructorProperties.html" title="java.beans 中的注释"><CODE>ConstructorProperties</CODE></A> 注释的公共构造方法，则将调用这些构造方法之一（不一定总是同一个构造方法）来重新构造一个 <em>J</em> 实例。每个这样的注释都必须列出与构造方法的参数数量相同的字符串；每个字符串必须命名一个对应于 <em>J</em> 的获取方法的属性；此获取方法的类型必须与对应构造方法参数的类型相同。如果存在 <code>ConstructorProperties</code> 注释中未提到的获取方法（这些获取方法可能对应于重新构造对象所不需要的信息），这不算是一种错误。</p>

<p>通过使用 <code>CompositeData</code> 中经过适当重新构造的项来调用构造方法，可以重新构造一个 <em>J</em> 实例。要调用的构造方法将在运行的时候根据实际出现在 <code>CompositeData</code> 中的项来确定，在这种情况下，此 <code>CompositeData</code> 可能来自 <em>J</em> 的较早版本，该版本中没有包含所有的项。如果在构造方法的 <code>ConstructorProperties</code> 注释中命名的所有属性都作为项出现在 <code>CompositeData</code> 中，则该构造方法是<em>适用的</em>。如果没有构造方法是适用的，则尝试重新构造 <em>J</em> 将失败。</p>

<p>对于任何可能的属性组合，必须是以下情况：(a) 没有适用的构造方法，或 (b) 恰恰有一个适用的构造方法，或 (c) 适用的构造方法之一命名了由其他每个适用构造方法命名的属性的适当超集。（换句话说，在选择构造方法时永远不应该有混淆现象。）如果此条件不为 true，则 <em>J</em> 是不可重新构造的。</p></li>

<li><p>否则，如果 <em>J</em> 具有不带参数的公共构造方法，并且对于类型为 <em>T</em> 且名称为 <em>N</em> 的 <em>J</em> 中的每个获取方法，都有一个具有相同名称和类型的相应设置方法，则 <em>J</em> 的实例是使用不带参数的构造方法构造的 ，并使用 <code>CompositeData</code> 中经过重新构造的项来调用这些设置方法，以恢复某些值。例如，如果具有方法<br> <code>public List&lt;String&gt; getNames()</code><br>，则还必须有一个应用此规则的方法<br> <code>public void setNames(List&lt;String&gt; names)</code><br>。</p>

<p>如果 <code>CompositeData</code> 来自 <em>J</em> 的较早版本，则有些项可能不会出现。在这种情况下，不会调用相应的设置方法。</p></li>

<li><p>否则，如果 <em>J</em> 是一个除了获取方法之外没有其他方法的接口，则使用具有 <A HREF="../../javax/management/openmbean/CompositeDataInvocationHandler.html" title="javax.management.openmbean 中的类"><CODE>CompositeDataInvocationHandler</CODE></A>（受正在转换的 <code>CompositeData</code> 支持）的 <A HREF="../../java/lang/reflect/Proxy.html" title="java.lang.reflect 中的类"><CODE>Proxy</CODE></A> 来构造一个 <em>J</em> 实例。</p></li>

<li><p>否则，<em>J</em> 是不可重新构造的。</p></li>
    </ol>

<p>下面的示例显示了对那些由 <code>int</code> 和 <code>String</code> 组成的类型 <code>NamedNumber</code> 进行编码的不同方式。<code>CompositeType</code> 在各种情况下的形式如下：</p>

    <blockquote>
      <pre>
<A HREF="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean 中的类"><CODE>CompositeType</CODE></A>(
&quot;NamedNumber&quot;,                        // typeName
&quot;NamedNumber&quot;,                        // description
new String[] {&quot;number&quot;, &quot;name&quot;},    // itemNames
new String[] {&quot;number&quot;, &quot;name&quot;},    // itemDescriptions
new OpenType[] {SimpleType.INTEGER,
SimpleType.STRING}  // itemTypes
);
      </pre>
    </blockquote>

    <ol>
<li>静态 <code>from</code> 方法：

        <blockquote>
          <pre>
public class NamedNumber {
public int getNumber() {return number;}
public String getName() {return name;}
private NamedNumber(int number, String name) {
this.number = number;
this.name = name;
    }
<b>public static NamedNumber from(CompositeData cd)</b> {
return new NamedNumber((Integer) cd.get(&quot;number&quot;),
(String) cd.get(&quot;name&quot;));
    }
private final int number;
private final String name;
}
          </pre>
        </blockquote>
      </li>

<li>带有 <code>@ConstructorProperties</code> 注释的公共构造方法：

        <blockquote>
          <pre>
public class NamedNumber {
public int getNumber() {return number;}
public String getName() {return name;}
<b>@ConstructorProperties({&quot;number&quot;, &quot;name&quot;})
public NamedNumber(int number, String name)</b> {
this.number = number;
this.name = name;
    }
private final int number;
private final String name;
}
          </pre>
        </blockquote>
      </li>

<li>针对每个获取方法的设置方法：

        <blockquote>
          <pre>
public class NamedNumber {
public int getNumber() {return number;}
public void <b>setNumber</b>(int number) {this.number = number;}
public String getName() {return name;}
public void <b>setName</b>(String name) {this.name = name;}
<b>public NamedNumber()</b> {}
private int number;
private String name;
}
          </pre>
        </blockquote>
      </li>

<li>只带有获取方法的接口：

        <blockquote>
          <pre>
public interface NamedNumber {
public int getNumber();
public String getName();
}
          </pre>
        </blockquote>
      </li>
    </ol>

<p>通常，它更适合只将数据集合表示为<em>不可变</em> 的类。不可变类的实例在被构造之后无法进行更改。注意，<code>CompositeData</code> 本身是不可变的。不可变性有许多优点，最为明显的是线程安全和安全性。因此，如有可能，通常应该采用避免使用设置方法的方式。</p>

<h3>递归类型</h3>

    <p>递归（自引用）类型不能在 MXBean 接口中使用。这是 <A HREF="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean 中的类"><CODE>CompositeType</CODE></A> 的不变性导致的。例如，以下类型不能是属性的类型，因为属性引用了自身：</p>

    <pre>
public interface <b>Node</b> {
    public String getName();
    public int getPriority();
    public <b>Node</b> getNext();
}
</pre>

    <p>总是可以像这样重写递归接口，使之不再递归。重写可能需要引入新类型。例如：</p>

    <pre>
public interface <b>NodeList</b> {
    public List&lt;Node&gt; getNodes();
}

public interface Node {
    public String getName();
    public int getPriority();
}
</pre>


<h3>MXBean 的 MBeanInfo 内容</h3>

<p>MXBean 是 Open MBean 的一种类型。但是，出于兼容性考虑，其 <A HREF="../../javax/management/MBeanInfo.html" title="javax.management 中的类"><CODE>MBeanInfo</CODE></A> 不是一个 <A HREF="../../javax/management/openmbean/OpenMBeanInfo.html" title="javax.management.openmbean 中的接口"><CODE>OpenMBeanInfo</CODE></A>。需要特别指出的是，如果属性、参数或操作返回值的类型是 <code>int</code> 之类的基本类型，或者是 <code>void</code>（针对返回类型），则属性、参数或操作将被分别表示为其 <code>getType()</code> 或 <code>getReturnType()</code> 返回基本名称（&quot;<code>int</code>&quot; 等）的 <A HREF="../../javax/management/MBeanAttributeInfo.html" title="javax.management 中的类"><CODE>MBeanAttributeInfo</CODE></A>、<A HREF="../../javax/management/MBeanParameterInfo.html" title="javax.management 中的类"><CODE>MBeanParameterInfo</CODE></A> 或 <A HREF="../../javax/management/MBeanOperationInfo.html" title="javax.management 中的类"><CODE>MBeanOperationInfo</CODE></A>。即使上面的映射规则指定 <em>opendata</em> 映射是包装类型（<code>Integer</code> 等），情况也是这样。</p>

<p>由直接在 MBean Server 中注册的 MXBean 的 <A HREF="../../javax/management/MBeanInfo.html#getConstructors()"><CODE>MBeanInfo.getConstructors()</CODE></A> 返回的公共构造方法数组，将包含该 MXBean 的所有公共构造方法。如果 MXBean 的类不是公共类，则其构造方法也被视为非公共构造方法。MXBean 的返回列表是使用 <A HREF="../../javax/management/StandardMBean.html" title="javax.management 中的类"><CODE>StandardMBean</CODE></A> 类构造的，其派生方式与 Standard MBean 的相同。不管 MXBean 是如何构造的，其构造方法参数都不服从 MXBean 映射规则，且没有对应的 <code>OpenType</code>。</p>

<p>如果直接在 MBean Server 中注册的 MXBean 没有实现 <A HREF="../../javax/management/NotificationBroadcaster.html" title="javax.management 中的接口"><CODE>NotificationBroadcaster</CODE></A> 接口，则由其 <A HREF="../../javax/management/MBeanInfo.html#getNotifications()"><CODE>MBeanInfo.getNotifications()</CODE></A> 返回的通知类型的数组将为空。否则，它将是在注册 MXBean 时调用 <A HREF="../../javax/management/NotificationBroadcaster.html#getNotificationInfo()"><CODE>NotificationBroadcaster.getNotificationInfo()</CODE></A> 的结果。即使此方法的结果以后发生更改，<code>MBeanInfo.getNotifications()</code> 的结果也不会发生更改。MXBean 的返回列表是使用 <A HREF="../../javax/management/StandardMBean.html" title="javax.management 中的类"><CODE>StandardMBean</CODE></A> 或 <A HREF="../../javax/management/StandardEmitterMBean.html" title="javax.management 中的类"><CODE>StandardEmitterMBean</CODE></A> 类构造的，其派生方式与 Standard MBean 的相同。</p>

<p><code>MBeanInfo</code> 中包含的所有 <code>MBeanAttributeInfo</code>、<code>MBeanParameterInfo</code> 和 <code>MBeanOperationInfo</code> 对象的 <A HREF="../../javax/management/Descriptor.html" title="javax.management 中的接口"><CODE>Descriptor</CODE></A> 都将包含一个字段 <code>openType</code>，其值为由上述映射规则指定的 <A HREF="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean 中的类"><CODE>OpenType</CODE></A>。因此，即使在 <code>getType()</code> 为 &quot;<code>int</code>&quot; 时，<code>getDescriptor().getField(&amp;quot;openType&amp;quot;)</code> 仍将是 <A HREF="../../javax/management/openmbean/SimpleType.html#INTEGER"><CODE>SimpleType.INTEGER</CODE></A>。</p>

<p>每个对象的 <code>Descriptor</code> 还有一个 <code>originalType</code> 字段，该字段是一个表示 MXBean 接口中出现的 Java 类型的字符串。此字符串的格式将在下面的<a href="#type-names">类型名称</a>一节中描述。</p>

<p><code>MBeanInfo</code> 的 <code>Descriptor</code> 将包含一个 <code>mxbean</code> 字段，该字段值是字符串 &quot;<code>true</code>&quot;。</p>


<h3><a name="type-names">类型名称</a></h3>

<p>有时必须将 MXBean 中方法参数或返回值的未映射类型 <em>T</em> 表示为一个字符串。如果 <em>T</em> 是非一般类型，则此字符串是由 <A HREF="../../java/lang/Class.html#getName()"><CODE>Class.getName()</CODE></A> 返回的值。否则，它是 <em>genericstring(T)</em> 的值，定义方式如下：

    <ul>

<li>如果 <em>T</em> 为特殊的非数组类型，则 <em>genericstring(T)</em> 是由 <A HREF="../../java/lang/Class.html#getName()"><CODE>Class.getName()</CODE></A> 返回的值，如 <code>&amp;quot;int&amp;quot;</code> 或 <code>&amp;quot;java.lang.String&amp;quot;</code>。

<li>如果 <em>T</em> 是数组 <em>E[]</em>，则 <em>genericstring(T)</em> 是后跟 <code>&amp;quot;[]&amp;quot;</code> 的 <em>genericstring(E)</em>。例如，<em>genericstring(<code>int[]</code>)</em> 是 <code>&amp;quot;int[]&amp;quot;</code>，而 <em>genericstring(<code>List&lt;String&gt;[][]</code>)</em> 是 <code>&amp;quot;java.util.List&lt;java.lang.String&gt;[][]&amp;quot;</code>。

<li>否则，<em>T</em> 是一个参数化类型（如 <code>List&lt;String&gt;</code>）并且 <em>genericstring(T)</em> 由以下内容组成：由 <code>Class.getName()</code> 返回的参数化类型的完全限定名称；左尖角括号 (<code>&amp;quot;&amp;lt;&amp;quot;</code>)；<em>genericstring(A)</em>（其中 <em>A</em> 是第一个类型参数）；如果存在第二个类型参数 <em>B</em>，则是一个后跟 <em>genericstring(B)</em> 的 <code>&amp;quot;, &amp;quot;</code>（即逗号加一个空格）；右尖角括号 (<code>&amp;quot;&amp;gt;&amp;quot;</code>)。

    </ul>

<p>注意，如果某一方法返回 <code>int[]</code>，则这将由 <code>Class.getName()</code> 返回的字符串 <code>&amp;quot;[I&amp;quot;</code> 表示，但如果某一方法返回 <code>List&lt;int[]&gt;</code>，则这将由字符串 <code>&amp;quot;java.util.List&lt;int[]&gt;&amp;quot;</code> 表示。

<h3>异常</h3>

<p><em>从</em> Java 类型映射<em>到</em> Open 类型时存在的一个问题是会出现 <A HREF="../../javax/management/openmbean/OpenDataException.html" title="javax.management.openmbean 中的类"><CODE>OpenDataException</CODE></A> 信号。这可能发生在分析 MXBean 接口时，例如，如果它引用一个类似于没有获取方法的 <A HREF="../../java/util/Random.html" title="java.util 中的类"><CODE>java.util.Random</CODE></A> 的类型。或者发生在转换实例（将返回值从 MXBean 中的方法或参数转换为 MXBean 代理中的方法）时，例如在 <code>SortedSet</code> 拥有非 null <code>Comparator</code> 的情况下从 <code>SortedSet&lt;String&gt;</code> 转换为 <code>String[]</code> 时。</p>

<p><em>从</em> Open 类型映射<em>到</em> Java 类型时存在的一个问题是会出现 <A HREF="../../java/io/InvalidObjectException.html" title="java.io 中的类"><CODE>InvalidObjectException</CODE></A> 信号。这可能发生在分析 MXBean 接口时，例如，当上下文需要可重新构造的类型时，根据上述规则引用了一个<em>不可重新构造的</em> 类型。或者发生在转换实例（MXBean 中某一方法的参数或 MXBean 代理中某一方法的返回值）时，例如在没有具备该名称的 Enum 常量的情况下将 String 转换为 Enum 时。</p>

<p>根据上下文，<code>OpenDataException</code> 或 <code>InvalidObjectException</code> 可以包装在另一个异常（如 <A HREF="../../javax/management/RuntimeMBeanException.html" title="javax.management 中的类"><CODE>RuntimeMBeanException</CODE></A> 或 <A HREF="../../java/lang/reflect/UndeclaredThrowableException.html" title="java.lang.reflect 中的类"><CODE>UndeclaredThrowableException</CODE></A>）中。 对于每个抛出的异常，条件 <em>C</em> 将为 true：&quot;<em>e</em> 为 <code>OpenDataException</code> 或 <code>InvalidObjectException</code>（如果合适），或者 <em>C</em> 在 <em>e</em>.<A HREF="../../java/lang/Throwable.html#getCause()"><CODE>getCause()</CODE></A>&quot; 中为 ture。</p>
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
<HR>

<P>
<!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== -->

<A NAME="annotation_type_optional_element_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>可选元素摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/management/MXBean.html#value()">value</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果被注释的接口是一个 MXBean 接口，则为 true。</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="value()"><!-- --></A><H3>
value</H3>
<PRE>
public abstract boolean <B>value</B></PRE>
<DL>
<DD>如果被注释的接口是一个 MXBean 接口，则为 true。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果被注释的接口是一个 MXBean 接口，则返回 true。</DL>
<DL>
<DT><B>默认值：</B><DD>true</DD>
</DL>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MXBean.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/management/MBeanTrustPermission.html" title="javax.management 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../javax/management/NotCompliantMBeanException.html" title="javax.management 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/management/MXBean.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="MXBean.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;必需&nbsp;|&nbsp;<A HREF="#annotation_type_optional_element_summary">可选</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#annotation_type_element_detail">元素</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
