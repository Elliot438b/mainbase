<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 13:47:20 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
AbstractUnmarshallerImpl (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AbstractUnmarshallerImpl (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractUnmarshallerImpl.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../javax/xml/bind/helpers/AbstractMarshallerImpl.html" title="javax.xml.bind.helpers 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../../javax/xml/bind/helpers/DefaultValidationEventHandler.html" title="javax.xml.bind.helpers 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?javax/xml/bind/helpers/AbstractUnmarshallerImpl.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="AbstractUnmarshallerImpl.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.xml.bind.helpers</FONT>
<BR>
类 AbstractUnmarshallerImpl</H2>
<PRE>
<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../../../resources/inherit.gif" ALT="继承者 "><B>javax.xml.bind.helpers.AbstractUnmarshallerImpl</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>AbstractUnmarshallerImpl</B><DT>extends <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A><DT>implements <A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></DL>
</PRE>

<P>
部分默认 <tt>Unmarshaller</tt> 实现。
 
 <p>
此类提供 <A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口"><CODE>Unmarshaller</CODE></A> 接口的部分默认实现。
 
 <p>
JAXB 提供者必须实现 5 个方法：getUnmarshallerHandler、unmarshal(Node)、unmarshal(XMLReader,InputSource)、unmarshal(XMLStreamReader) 和 unmarshal(XMLEventReader)。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>JAXB1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口"><CODE>Unmarshaller</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>嵌套类摘要</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_javax.xml.bind.Unmarshaller"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从接口 javax.xml.bind.<A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A> 继承的嵌套类/接口</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind 中的类">Unmarshaller.Listener</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#validating">validating</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指示 Unmarshaller 是否将执行验证。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#AbstractUnmarshallerImpl()">AbstractUnmarshallerImpl</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#createUnmarshalException(org.xml.sax.SAXException)">createUnmarshalException</A></B>(<A HREF="../../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A>&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 SAXException 创建 UnmarshalException。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;A extends <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类">XmlAdapter</A>&gt; 
<BR>
A</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#getAdapter(java.lang.Class)">getAdapter</A></B>(<A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;A&gt;&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取与指定类型关联的适配器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../javax/xml/bind/attachment/AttachmentUnmarshaller.html" title="javax.xml.bind.attachment 中的类">AttachmentUnmarshaller</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#getAttachmentUnmarshaller()">getAttachmentUnmarshaller</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口">ValidationEventHandler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#getEventHandler()">getEventHandler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回当前的事件处理程序，如果没有设置该处理程序，则返回默认的事件处理程序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind 中的类">Unmarshaller.Listener</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#getListener()">getListener</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回向此 <A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口"><CODE>Unmarshaller</CODE></A> 注册的 <A HREF="../../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind 中的类"><CODE>Unmarshaller.Listener</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#getProperty(java.lang.String)">getProperty</A></B>(<A HREF="../../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于没有必需的属性，getProperty 方法的默认实现总是抛出 PropertyException。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#getSchema()">getSchema</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取用于执行解组时验证的 JAXP 1.3 <A HREF="../../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../org/xml/sax/XMLReader.html" title="org.xml.sax 中的接口">XMLReader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#getXMLReader()">getXMLReader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取配置好的 XMLReader。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#isValidating()">isValidating</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指示 Unmarshaller 是否被配置为在执行解组操作期间进行验证。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;A extends <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类">XmlAdapter</A>&gt; 
<BR>
void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#setAdapter(java.lang.Class, A)">setAdapter</A></B>(<A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;A&gt;&nbsp;type,
           A&nbsp;adapter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将已配置的 <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类"><CODE>XmlAdapter</CODE></A> 实例与此 unmarshaller 关联。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter)">setAdapter</A></B>(<A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类">XmlAdapter</A>&nbsp;adapter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将已配置的 <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类"><CODE>XmlAdapter</CODE></A> 实例与此 unmarshaller 关联。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#setAttachmentUnmarshaller(javax.xml.bind.attachment.AttachmentUnmarshaller)">setAttachmentUnmarshaller</A></B>(<A HREF="../../../../javax/xml/bind/attachment/AttachmentUnmarshaller.html" title="javax.xml.bind.attachment 中的类">AttachmentUnmarshaller</A>&nbsp;au)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将解析 cid（内容 id URI）的上下文与作为附件传递的二进制数据关联。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#setEventHandler(javax.xml.bind.ValidationEventHandler)">setEventHandler</A></B>(<A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口">ValidationEventHandler</A>&nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许应用程序注册一个验证事件处理程序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#setListener(javax.xml.bind.Unmarshaller.Listener)">setListener</A></B>(<A HREF="../../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind 中的类">Unmarshaller.Listener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
向此 <A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口"><CODE>Unmarshaller</CODE></A> 注册解组事件回调 <A HREF="../../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind 中的类"><CODE>Unmarshaller.Listener</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A></B>(<A HREF="../../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
            <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于没有必需的属性，setProperty 方法的默认实现总是抛出 PropertyException。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#setSchema(javax.xml.validation.Schema)">setSchema</A></B>(<A HREF="../../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A>&nbsp;schema)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定应用作验证后续解组操作依据的 JAXP 1.3 <A HREF="../../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#setValidating(boolean)">setValidating</A></B>(boolean&nbsp;validating)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定 Unmarshaller 是否应该在执行解组操作期间进行验证。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(java.io.File)">unmarshal</A></B>(<A HREF="../../../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从指定的文件解组 XML 数据并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(org.xml.sax.InputSource)">unmarshal</A></B>(<A HREF="../../../../org/xml/sax/InputSource.html" title="org.xml.sax 中的类">InputSource</A>&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从指定的 SAX InputSource 解组 XML 数据并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(java.io.InputStream)">unmarshal</A></B>(<A HREF="../../../../java/io/InputStream.html" title="java.io 中的类">InputStream</A>&nbsp;is)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从指定的 InputStream 解组 XML 数据并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../javax/xml/bind/JAXBElement.html" title="javax.xml.bind 中的类">JAXBElement</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(org.w3c.dom.Node, java.lang.Class)">unmarshal</A></B>(<A HREF="../../../../org/w3c/dom/Node.html" title="org.w3c.dom 中的接口">Node</A>&nbsp;node,
          <A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;T&gt;&nbsp;expectedType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过 JAXB 映射的 <tt>declaredType</tt> 解组 XML 数据并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(java.io.Reader)">unmarshal</A></B>(<A HREF="../../../../java/io/Reader.html" title="java.io 中的类">Reader</A>&nbsp;reader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从指定的 Reader 解组 XML 数据并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(javax.xml.transform.Source)">unmarshal</A></B>(<A HREF="../../../../javax/xml/transform/Source.html" title="javax.xml.transform 中的接口">Source</A>&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从指定的 XML Source 解组 XML 数据并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../javax/xml/bind/JAXBElement.html" title="javax.xml.bind 中的类">JAXBElement</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(javax.xml.transform.Source, java.lang.Class)">unmarshal</A></B>(<A HREF="../../../../javax/xml/transform/Source.html" title="javax.xml.transform 中的接口">Source</A>&nbsp;source,
          <A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;T&gt;&nbsp;expectedType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <tt>declaredType</tt> 指定的 XML Source 解组 XML 数据并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(java.net.URL)">unmarshal</A></B>(<A HREF="../../../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;url)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从指定的 URL 解组 XML 数据并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(javax.xml.stream.XMLEventReader)">unmarshal</A></B>(<A HREF="../../../../javax/xml/stream/XMLEventReader.html" title="javax.xml.stream 中的接口">XMLEventReader</A>&nbsp;reader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从指定的 pull 解析器解组 XML 数据并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../javax/xml/bind/JAXBElement.html" title="javax.xml.bind 中的类">JAXBElement</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(javax.xml.stream.XMLEventReader, java.lang.Class)">unmarshal</A></B>(<A HREF="../../../../javax/xml/stream/XMLEventReader.html" title="javax.xml.stream 中的接口">XMLEventReader</A>&nbsp;reader,
          <A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;T&gt;&nbsp;expectedType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将根元素解组到 JAXB 映射的 <tt>declaredType</tt> 并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(org.xml.sax.XMLReader, org.xml.sax.InputSource)">unmarshal</A></B>(<A HREF="../../../../org/xml/sax/XMLReader.html" title="org.xml.sax 中的接口">XMLReader</A>&nbsp;reader,
          <A HREF="../../../../org/xml/sax/InputSource.html" title="org.xml.sax 中的类">InputSource</A>&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用指定的 XMLReader 和 InputSource 解组对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(javax.xml.stream.XMLStreamReader)">unmarshal</A></B>(<A HREF="../../../../javax/xml/stream/XMLStreamReader.html" title="javax.xml.stream 中的接口">XMLStreamReader</A>&nbsp;reader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从指定的 pull 解析器解组 XML 数据并返回得到的内容树。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../../javax/xml/bind/JAXBElement.html" title="javax.xml.bind 中的类">JAXBElement</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/xml/bind/helpers/AbstractUnmarshallerImpl.html#unmarshal(javax.xml.stream.XMLStreamReader, java.lang.Class)">unmarshal</A></B>(<A HREF="../../../../javax/xml/stream/XMLStreamReader.html" title="javax.xml.stream 中的接口">XMLStreamReader</A>&nbsp;reader,
          <A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;T&gt;&nbsp;expectedType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将根元素解组到 JAXB 映射的 <tt>declaredType</tt> 并返回得到的内容树。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.xml.bind.Unmarshaller"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从接口 javax.xml.bind.<A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#getUnmarshallerHandler()">getUnmarshallerHandler</A>, <A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(org.w3c.dom.Node)">unmarshal</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>字段详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="validating"><!-- --></A><H3>
validating</H3>
<PRE>
protected boolean <B>validating</B></PRE>
<DL>
<DD>指示 Unmarshaller 是否将执行验证。
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AbstractUnmarshallerImpl()"><!-- --></A><H3>
AbstractUnmarshallerImpl</H3>
<PRE>
public <B>AbstractUnmarshallerImpl</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getXMLReader()"><!-- --></A><H3>
getXMLReader</H3>
<PRE>
protected <A HREF="../../../../org/xml/sax/XMLReader.html" title="org.xml.sax 中的接口">XMLReader</A> <B>getXMLReader</B>()
                          throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD>获取配置好的 XMLReader。
 
此方法在客户端指定的 <A HREF="../../../../javax/xml/transform/sax/SAXSource.html" title="javax.xml.transform.sax 中的类"><CODE>SAXSource</CODE></A> 对象没有 XMLReader 时使用。
 
<A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口"><CODE>Unmarshaller</CODE></A> 不可重入，因此我们只能使用一个 XMLReader 实例。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(javax.xml.transform.Source)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>unmarshal</B>(<A HREF="../../../../javax/xml/transform/Source.html" title="javax.xml.transform 中的接口">Source</A>&nbsp;source)
                 throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.transform.Source)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>从指定的 XML Source 解组 XML 数据并返回得到的内容树。  

 <p>
实现<a href="#unmarshalGlobal">解组全局根元素</a>。

 <p>
<a name="saxParserPlugable"></a> <b>SAX 2.0 解析器的可插入性</b>
 <p>
客户端应用程序可以选择不使用随 JAXB 提供者一起提供的默认解析器机制。任何兼容 SAX 2.0 的解析器都可以取代 JAXB 提供者的默认机制。要实现这一点，客户端应用程序必须正确配置一个包含 <tt>XMLReader</tt> 的 <tt>SAXSource</tt>，并且该 <tt>XMLReader</tt> 是由 SAX 2.0 解析器提供者实现的。如果 <tt>XMLReader</tt> 有一个向它注册的 <tt>org.xml.sax.ErrorHandler</tt>，则将使用 JAXB 提供者替换它，以便通过 JAXB 的 <tt>ValidationEventHandler</tt> 机制报告验证错误。如果 <tt>SAXSource</tt> 不包含 <tt>XMLReader</tt>，则将使用 JAXB 提供者的默认解析器机制。
 <p>
也可以使用此解析器替换机制来替换 JAXB 提供者的解组时验证引擎。客户端应用程序必须正确配置其兼容 SAX 2.0 的解析器来执行验证（如上例所示）。解析器在解组操作期间遇到的任何 <tt>SAXParserExceptions</tt> 都将由 JAXB 提供者处理，并将其转换为 JAXB <tt>ValidationEvent</tt> 对象，这些对象将通过已经向 <tt>Unmarshaller</tt> 注册的 <tt>ValidationEventHandler</tt> 报告给客户端。<i>注：</i> 在为了实现解组而指定一个替换验证 SAX 2.0 解析器时，无需替换 JAXB 提供者使用的验证引擎来执行按需应变的验证。
 <p>
客户端应用程序指定将在解组期间使用的替换解析器机制的唯一方法是通过 <tt>unmarshal(SAXSource)</tt> API。所有其他形式的 unmarshal 方法（文件、URL、Node 等等）将使用 JAXB 提供者的默认解析器和验证器机制。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.transform.Source)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>source</CODE> - 将从中解组 XML 数据的 XML Source（提供者只需支持 SAXSource、DOMSource 和 StreamSource）
<DT><B>返回：</B><DD>新创建的 java 内容树的根对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a><DT><B>另请参见：</B><DD><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.transform.Source, java.lang.Class)"><CODE>Unmarshaller.unmarshal(javax.xml.transform.Source, Class)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(org.xml.sax.XMLReader, org.xml.sax.InputSource)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
protected abstract <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>unmarshal</B>(<A HREF="../../../../org/xml/sax/XMLReader.html" title="org.xml.sax 中的接口">XMLReader</A>&nbsp;reader,
                                    <A HREF="../../../../org/xml/sax/InputSource.html" title="org.xml.sax 中的类">InputSource</A>&nbsp;source)
                             throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD>使用指定的 XMLReader 和 InputSource 解组对象。
 
被调用者应调用 XMLReader 的 setErrorHandler 方法，这样错误才能传递给客户端指定的 ValidationEventHandler。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(org.xml.sax.InputSource)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public final <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>unmarshal</B>(<A HREF="../../../../org/xml/sax/InputSource.html" title="org.xml.sax 中的类">InputSource</A>&nbsp;source)
                       throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(org.xml.sax.InputSource)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>从指定的 SAX InputSource 解组 XML 数据并返回得到的内容树。

 <p>
实现<a href="#unmarshalGlobal">解组全局根元素</a>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(org.xml.sax.InputSource)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>source</CODE> - 将从中解组 XML 数据的输入源
<DT><B>返回：</B><DD>新创建的 java 内容树的根对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(java.net.URL)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public final <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>unmarshal</B>(<A HREF="../../../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;url)
                       throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(java.net.URL)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>从指定的 URL 解组 XML 数据并返回得到的内容树。

 <p>
实现<a href="#unmarshalGlobal">解组全局根元素</a>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(java.net.URL)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>url</CODE> - 将从中解组 XML 数据的 URL
<DT><B>返回：</B><DD>新创建的 java 内容树的根对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(java.io.File)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public final <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>unmarshal</B>(<A HREF="../../../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;f)
                       throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(java.io.File)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>从指定的文件解组 XML 数据并返回得到的内容树。

 <p>
实现<a href="#unmarshalGlobal">解组全局根元素</a>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(java.io.File)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>f</CODE> - 将从中解组 XML 数据的文件
<DT><B>返回：</B><DD>新创建的 java 内容树的根对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或着 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(java.io.InputStream)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public final <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>unmarshal</B>(<A HREF="../../../../java/io/InputStream.html" title="java.io 中的类">InputStream</A>&nbsp;is)
                       throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(java.io.InputStream)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>从指定的 InputStream 解组 XML 数据并返回得到的内容树。使用这种形式的 unmarshal API 时，验证事件位置信息可能不完整。

 <p>
实现<a href="#unmarshalGlobal">解组全局根元素</a>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(java.io.InputStream)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>is</CODE> - 将从中解组 XML 数据的 InputStream
<DT><B>返回：</B><DD>新创建的 java 内容树的根对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(java.io.Reader)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public final <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>unmarshal</B>(<A HREF="../../../../java/io/Reader.html" title="java.io 中的类">Reader</A>&nbsp;reader)
                       throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(java.io.Reader)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>从指定的 Reader 解组 XML 数据并返回得到的内容树。使用这种形式的 unmarshal API 时，验证事件位置信息可能不完整，这是因为 Reader 不提供系统 ID。

 <p>
实现<a href="#unmarshalGlobal">解组全局根元素</a>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(java.io.Reader)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>reader</CODE> - 将从中解组 XML 数据的 Reader
<DT><B>返回：</B><DD>新创建的 java 内容树的根对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a></DL>
</DD>
</DL>
<HR>

<A NAME="isValidating()"><!-- --></A><H3>
isValidating</H3>
<PRE>
public boolean <B>isValidating</B>()
                     throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD>指示 Unmarshaller 是否被配置为在执行解组操作期间进行验证。
 <p>
<i><b>注：</b> 为了与 JAXP 保持一致，我将该方法命名为 isValidating()，而不是 getValidating()。</i>
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#isValidating()">isValidating</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果 Unmarshaller 被配置为在执行解组操作期间进行验证，则返回 true，否则返回 false
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果检索验证标志时发生错误</DL>
</DD>
</DL>
<HR>

<A NAME="setEventHandler(javax.xml.bind.ValidationEventHandler)"><!-- --></A><H3>
setEventHandler</H3>
<PRE>
public void <B>setEventHandler</B>(<A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口">ValidationEventHandler</A>&nbsp;handler)
                     throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD>允许应用程序注册一个验证事件处理程序。
 <p>
如果在调用任一 <tt>unmarshal</tt> 方法期间发生验证错误，则 JAXB 提供者将调用验证事件处理程序。如果在调用解组方法之前客户端应用程序没有注册验证事件处理程序，那么将忽略所有验证事件，并有可能导致不可预料的行为。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setEventHandler(javax.xml.bind.ValidationEventHandler)">setEventHandler</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>handler</CODE> - 验证事件处理程序
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在设置事件处理程序时发生错误</DL>
</DD>
</DL>
<HR>

<A NAME="setValidating(boolean)"><!-- --></A><H3>
setValidating</H3>
<PRE>
public void <B>setValidating</B>(boolean&nbsp;validating)
                   throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD>指定 Unmarshaller 是否应该在执行解组操作期间进行验证。默认情况下，<tt>Unmarshaller</tt> 不进行验证。
 <p>
此方法仅在调用某一解组方法之前或之后调用。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setValidating(boolean)">setValidating</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>validating</CODE> - 如果 Unmarshaller 应该在执行解组操作期间进行验证，则该参数为 true，否则为 false
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在执行解组操作期间启用或禁用验证时发生错误</DL>
</DD>
</DL>
<HR>

<A NAME="getEventHandler()"><!-- --></A><H3>
getEventHandler</H3>
<PRE>
public <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口">ValidationEventHandler</A> <B>getEventHandler</B>()
                                       throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD>返回当前的事件处理程序，如果没有设置该处理程序，则返回默认的事件处理程序。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#getEventHandler()">getEventHandler</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当前 ValidationEventHandler，如果没有设置该处理程序，则返回默认的事件处理程序
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果获取当前事件处理程序时发生错误</DL>
</DD>
</DL>
<HR>

<A NAME="createUnmarshalException(org.xml.sax.SAXException)"><!-- --></A><H3>
createUnmarshalException</H3>
<PRE>
protected <A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A> <B>createUnmarshalException</B>(<A HREF="../../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A>&nbsp;e)</PRE>
<DL>
<DD>从 SAXException 创建 UnmarshalException。
 
这是一个为派生类提供的实用方法。
 
 <p>
当提供者实现的 ContentHandler 希望抛出 JAXBException 时，它需要通过 SAXException 包装该异常。如果 unmarshaller 实现盲目地使用 JAXBException 包装 SAXException ，则异常将是用另一个 JAXBException 包装的 SAXException 包装的 JAXBException。这样做很不明智。
 
 <p>
此方法检查 SAXException 的嵌套异常并可减少过多的包装。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>得到的 UnmarshalException</DL>
</DD>
</DL>
<HR>

<A NAME="setProperty(java.lang.String, java.lang.Object)"><!-- --></A><H3>
setProperty</H3>
<PRE>
public void <B>setProperty</B>(<A HREF="../../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                        <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;value)
                 throws <A HREF="../../../../javax/xml/bind/PropertyException.html" title="javax.xml.bind 中的类">PropertyException</A></PRE>
<DL>
<DD>由于没有必需的属性，setProperty 方法的默认实现总是抛出 PropertyException。如果提供商需要处理其他属性，则应该在派生类中重写此方法。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 要设置的属性的名称。此值可以使用一个常量字段来指定，也可以是一个用户提供的字符串。<DD><CODE>value</CODE> - 要设置的属性值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/PropertyException.html" title="javax.xml.bind 中的类">PropertyException</A></CODE> - 如果处理给定属性或值时发生错误</DL>
</DD>
</DL>
<HR>

<A NAME="getProperty(java.lang.String)"><!-- --></A><H3>
getProperty</H3>
<PRE>
public <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>getProperty</B>(<A HREF="../../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                   throws <A HREF="../../../../javax/xml/bind/PropertyException.html" title="javax.xml.bind 中的类">PropertyException</A></PRE>
<DL>
<DD>由于没有必需的属性，getProperty 方法的默认实现总是抛出 PropertyException。如果提供者需要处理其他属性，则应该在派生类中重写此方法。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#getProperty(java.lang.String)">getProperty</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 要检索的属性的名称
<DT><B>返回：</B><DD>所请求属性的值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/PropertyException.html" title="javax.xml.bind 中的类">PropertyException</A></CODE> - 如果检索给定属性或值属性名称时发生错误</DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(javax.xml.stream.XMLEventReader)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>unmarshal</B>(<A HREF="../../../../javax/xml/stream/XMLEventReader.html" title="javax.xml.stream 中的接口">XMLEventReader</A>&nbsp;reader)
                 throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.stream.XMLEventReader)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>从指定的 pull 解析器解组 XML 数据并返回得到的内容树。

 <p>
此方法是一个<a href="#unmarshalGlobal">解组全局根方法</a>。

 <p>
此方法假定该解析器处于 START_DOCUMENT 或 START_ELEMENT 事件上。解组将从起始事件开始，到相应的终止事件结束。如果此方法成功返回，则 <tt>reader</tt> 将指向终止事件后面的标记。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.stream.XMLEventReader)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>reader</CODE> - 要读取的解析器。
<DT><B>返回：</B><DD>新创建的 java 内容树的根对象。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a><DT><B>另请参见：</B><DD><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.stream.XMLEventReader, java.lang.Class)"><CODE>Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader, Class)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(javax.xml.stream.XMLStreamReader)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public <A HREF="../../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>unmarshal</B>(<A HREF="../../../../javax/xml/stream/XMLStreamReader.html" title="javax.xml.stream 中的接口">XMLStreamReader</A>&nbsp;reader)
                 throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.stream.XMLStreamReader)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>从指定的 pull 解析器解组 XML 数据并返回得到的内容树。

 <p>
实现<a href="#unmarshalGlobal">解组全局根元素</a>。
 
 <p>
此方法假定该解析器处于 START_DOCUMENT 或 START_ELEMENT 事件上。解组将从起始事件开始，到相应的终止事件结束。如果此方法成功返回，则 <tt>reader</tt> 将指向终止事件后面的标记。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.stream.XMLStreamReader)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>reader</CODE> - 要读取的解析器。
<DT><B>返回：</B><DD>新创建的 java 内容树的根对象。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a><DT><B>另请参见：</B><DD><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.stream.XMLStreamReader, java.lang.Class)"><CODE>Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader, Class)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(org.w3c.dom.Node, java.lang.Class)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../javax/xml/bind/JAXBElement.html" title="javax.xml.bind 中的类">JAXBElement</A>&lt;T&gt; <B>unmarshal</B>(<A HREF="../../../../org/w3c/dom/Node.html" title="org.w3c.dom 中的接口">Node</A>&nbsp;node,
                                    <A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;T&gt;&nbsp;expectedType)
                         throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(org.w3c.dom.Node, java.lang.Class)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>通过 JAXB 映射的 <tt>declaredType</tt> 解组 XML 数据并返回得到的内容树。

 <p>
实现<a href="#unmarshalByDeclaredType">借助声明的类型进行解组</a>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(org.w3c.dom.Node, java.lang.Class)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>node</CODE> - 从中解组 XML 数据的文档/元素。调用者至少必须支持 Document 和 Element。<DD><CODE>expectedType</CODE> - 用来保存 <tt>node</tt> 的 XML 数据的适当 JAXB 映射类。
<DT><B>返回：</B><DD><tt>node</tt> 的 <a href="#unmarshalDeclaredTypeReturn">JAXB Element</a> 表示形式
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(javax.xml.transform.Source, java.lang.Class)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../javax/xml/bind/JAXBElement.html" title="javax.xml.bind 中的类">JAXBElement</A>&lt;T&gt; <B>unmarshal</B>(<A HREF="../../../../javax/xml/transform/Source.html" title="javax.xml.transform 中的接口">Source</A>&nbsp;source,
                                    <A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;T&gt;&nbsp;expectedType)
                         throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.transform.Source, java.lang.Class)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>从 <tt>declaredType</tt> 指定的 XML Source 解组 XML 数据并返回得到的内容树。  

 <p>
实现<a href="#unmarshalByDeclaredType">借助声明的类型进行解组</a>。

 <p>
请参阅 <a href="#saxParserPlugable">SAX 2.0 解析器的可插入性</a>
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.transform.Source, java.lang.Class)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>source</CODE> - 将从中解组 XML 数据的 XML Source（提供者只需支持 SAXSource、DOMSource 和 StreamSource）<DD><CODE>expectedType</CODE> - 用来保存 <tt>source</tt> 的 xml 根元素的适当 JAXB 映射类
<DT><B>返回：</B><DD>通过 <a href="#unmarshalDeclaredTypeReturn">JAXB Element</a> 确定的 Java 内容
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(javax.xml.stream.XMLStreamReader, java.lang.Class)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../javax/xml/bind/JAXBElement.html" title="javax.xml.bind 中的类">JAXBElement</A>&lt;T&gt; <B>unmarshal</B>(<A HREF="../../../../javax/xml/stream/XMLStreamReader.html" title="javax.xml.stream 中的接口">XMLStreamReader</A>&nbsp;reader,
                                    <A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;T&gt;&nbsp;expectedType)
                         throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.stream.XMLStreamReader, java.lang.Class)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>将根元素解组到 JAXB 映射的 <tt>declaredType</tt> 并返回得到的内容树。
 
 <p>
此方法实现<a href="#unmarshalByDeclaredType">借助 declaredType 进行解组</a>。
 <p>
此方法假定该解析器处于 START_DOCUMENT 或 START_ELEMENT 事件上。解组将从起始事件开始，到相应的终止事件结束。如果此方法成功返回，则 <tt>reader</tt> 将指向终止事件后面的标记。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.stream.XMLStreamReader, java.lang.Class)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>reader</CODE> - 要读取的解析器。<DD><CODE>expectedType</CODE> - 用来保存 <tt>reader</tt> 的 START_ELEMENT XML 数据的适当 JAXB 映射类。
<DT><B>返回：</B><DD>通过 <a href="#unmarshalDeclaredTypeReturn">JAXB Element 表示形式</a>确定的内容树
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a></DL>
</DD>
</DL>
<HR>

<A NAME="unmarshal(javax.xml.stream.XMLEventReader, java.lang.Class)"><!-- --></A><H3>
unmarshal</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../../javax/xml/bind/JAXBElement.html" title="javax.xml.bind 中的类">JAXBElement</A>&lt;T&gt; <B>unmarshal</B>(<A HREF="../../../../javax/xml/stream/XMLEventReader.html" title="javax.xml.stream 中的接口">XMLEventReader</A>&nbsp;reader,
                                    <A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;T&gt;&nbsp;expectedType)
                         throws <A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.stream.XMLEventReader, java.lang.Class)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>将根元素解组到 JAXB 映射的 <tt>declaredType</tt> 并返回得到的内容树。
 
 <p>
此方法实现<a href="#unmarshalByDeclaredType">借助 declaredType 进行解组</a>。

 <p>
此方法假定该解析器处于 START_DOCUMENT 或 START_ELEMENT 事件上。解组将从起始事件开始，到相应的终止事件结束。如果此方法成功返回，则 <tt>reader</tt> 将指向终止事件后面的标记。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.stream.XMLEventReader, java.lang.Class)">unmarshal</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>reader</CODE> - 要读取的解析器。<DD><CODE>expectedType</CODE> - 用来保存 <tt>reader</tt> 的 START_ELEMENT XML 数据的适当 JAXB 映射类。
<DT><B>返回：</B><DD>通过 <a href="#unmarshalDeclaredTypeReturn">JAXB Element 表示形式</a>确定的内容树
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../../javax/xml/bind/JAXBException.html" title="javax.xml.bind 中的类">JAXBException</A></CODE> - 如果在解组时发生不可预料的错误
<DD><CODE><A HREF="../../../../javax/xml/bind/UnmarshalException.html" title="javax.xml.bind 中的类">UnmarshalException</A></CODE> - 如果 <A HREF="../../../../javax/xml/bind/ValidationEventHandler.html" title="javax.xml.bind 中的接口"><CODE>ValidationEventHandler</CODE></A> 从其 <tt>handleEvent</tt> 方法返回 false 或者 <tt>Unmarshaller</tt> 不能执行 XML 到 Java 的绑定。请参阅<a href="#unmarshalEx">解组 XML 数据</a></DL>
</DD>
</DL>
<HR>

<A NAME="setSchema(javax.xml.validation.Schema)"><!-- --></A><H3>
setSchema</H3>
<PRE>
public void <B>setSchema</B>(<A HREF="../../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A>&nbsp;schema)</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setSchema(javax.xml.validation.Schema)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>指定应用作验证后续解组操作依据的 JAXP 1.3 <A HREF="../../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象。向此方法传递 null 将禁用验证。
 <p>
此方法将替换已过时的 <A HREF="../../../../javax/xml/bind/Unmarshaller.html#setValidating(boolean)"><CODE>setValidating(boolean)</CODE></A> API。

 <p>
最初，此属性被设置为 <tt>null</tt>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setSchema(javax.xml.validation.Schema)">setSchema</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>schema</CODE> - 作为验证解组操作依据的 Schema 对象；为 null 表示禁用验证</DL>
</DD>
</DL>
<HR>

<A NAME="getSchema()"><!-- --></A><H3>
getSchema</H3>
<PRE>
public <A HREF="../../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A> <B>getSchema</B>()</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#getSchema()">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>获取用于执行解组时验证的 JAXP 1.3 <A HREF="../../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象。如果没有在 unmarshaller 上设置 Schema，则此方法将返回 null，指示不会执行解组时验证。
 <p>
此方法用于替换已过时的 <A HREF="../../../../javax/xml/bind/Unmarshaller.html#isValidating()"><CODE>Unmarshaller.isValidating()</CODE></A> API，并可访问 Schema 对象。要确定 Unmarshaller 是否启用了验证，只需测试返回类型是否为 null：
 <p>
<code>boolean isValidating = u.getSchema()!=null;</code>
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#getSchema()">getSchema</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>返回用于执行解组时验证的 Schema 对象；如果该对象不存在，则返回 null</DL>
</DD>
</DL>
<HR>

<A NAME="setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter)"><!-- --></A><H3>
setAdapter</H3>
<PRE>
public void <B>setAdapter</B>(<A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类">XmlAdapter</A>&nbsp;adapter)</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>将已配置的 <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类"><CODE>XmlAdapter</CODE></A> 实例与此 unmarshaller 关联。

 <p>
这是调用 <code>setAdapter(adapter.getClass(),adapter);</code> 的一个便捷方法。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter)">setAdapter</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setAdapter(java.lang.Class, A)"><CODE>Unmarshaller.setAdapter(Class,XmlAdapter)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter)"><!-- --></A><A NAME="setAdapter(java.lang.Class, A)"><!-- --></A><H3>
setAdapter</H3>
<PRE>
public &lt;A extends <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类">XmlAdapter</A>&gt; void <B>setAdapter</B>(<A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;A&gt;&nbsp;type,
                                              A&nbsp;adapter)</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setAdapter(java.lang.Class, A)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>将已配置的 <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类"><CODE>XmlAdapter</CODE></A> 实例与此 unmarshaller 关联。

 <p>
每个 unmarshaller 都可以在内部维护一个 <A HREF="../../../../java/util/Map.html" title="java.util 中的接口"><CODE>Map</CODE></A>&lt;<A HREF="../../../../java/lang/Class.html" title="java.lang 中的类"><CODE>Class</CODE></A>,<A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类"><CODE>XmlAdapter</CODE></A>&gt;，可用来解组使用 <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlJavaTypeAdapter.html" title="javax.xml.bind.annotation.adapters 中的注释"><CODE>XmlJavaTypeAdapter</CODE></A> 注释其字段/方法的类。

 <p>
此方法允许应用程序使用已配置好的 <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类"><CODE>XmlAdapter</CODE></A> 实例。如果没有给出适配器实例，则 unmarshaller 将调用其默认构造方法创建一个实例。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setAdapter(java.lang.Class, A)">setAdapter</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>type</CODE> - 适配器的类型。当 <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlJavaTypeAdapter.html#value()"><CODE>XmlJavaTypeAdapter.value()</CODE></A> 引用此类型时，将使用指定的实例。<DD><CODE>adapter</CODE> - 将要使用的适配器实例。如果为 null，则将注销此类型的当前适配器集合。</DL>
</DD>
</DL>
<HR>

<A NAME="getAdapter(java.lang.Class)"><!-- --></A><H3>
getAdapter</H3>
<PRE>
public &lt;A extends <A HREF="../../../../javax/xml/bind/annotation/adapters/XmlAdapter.html" title="javax.xml.bind.annotation.adapters 中的类">XmlAdapter</A>&gt; A <B>getAdapter</B>(<A HREF="../../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;A&gt;&nbsp;type)</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#getAdapter(java.lang.Class)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD>获取与指定类型关联的适配器。

这是 <A HREF="../../../../javax/xml/bind/Unmarshaller.html#setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter)"><CODE>Unmarshaller.setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter)</CODE></A> 方法的反向操作。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#getAdapter(java.lang.Class)">getAdapter</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAttachmentUnmarshaller(javax.xml.bind.attachment.AttachmentUnmarshaller)"><!-- --></A><H3>
setAttachmentUnmarshaller</H3>
<PRE>
public void <B>setAttachmentUnmarshaller</B>(<A HREF="../../../../javax/xml/bind/attachment/AttachmentUnmarshaller.html" title="javax.xml.bind.attachment 中的类">AttachmentUnmarshaller</A>&nbsp;au)</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setAttachmentUnmarshaller(javax.xml.bind.attachment.AttachmentUnmarshaller)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD><p>将解析 cid（内容 id URI）的上下文与作为附件传递的二进制数据关联。</p>
 <p/>
<p>通过 <A HREF="../../../../javax/xml/bind/Unmarshaller.html#setSchema(javax.xml.validation.Schema)"><CODE>Unmarshaller.setSchema(Schema)</CODE></A> 启用的解组时验证，即使在 unmarshaller 执行 XOP 处理时也必须支持。
 </p>
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setAttachmentUnmarshaller(javax.xml.bind.attachment.AttachmentUnmarshaller)">setAttachmentUnmarshaller</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAttachmentUnmarshaller()"><!-- --></A><H3>
getAttachmentUnmarshaller</H3>
<PRE>
public <A HREF="../../../../javax/xml/bind/attachment/AttachmentUnmarshaller.html" title="javax.xml.bind.attachment 中的类">AttachmentUnmarshaller</A> <B>getAttachmentUnmarshaller</B>()</PRE>
<DL>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#getAttachmentUnmarshaller()">getAttachmentUnmarshaller</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setListener(javax.xml.bind.Unmarshaller.Listener)"><!-- --></A><H3>
setListener</H3>
<PRE>
public void <B>setListener</B>(<A HREF="../../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind 中的类">Unmarshaller.Listener</A>&nbsp;listener)</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setListener(javax.xml.bind.Unmarshaller.Listener)">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD><p>
向此 <A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口"><CODE>Unmarshaller</CODE></A> 注册解组事件回调 <A HREF="../../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind 中的类"><CODE>Unmarshaller.Listener</CODE></A>。
 
 <p>
每个 Unmarshaller 只有一个 Listener。设置 Listener 将替换以前设置的 Listener。通过将 listener 设置为 <tt>null</tt> 可注销当前的 Listener。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#setListener(javax.xml.bind.Unmarshaller.Listener)">setListener</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>listener</CODE> - 为此 <A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口"><CODE>Unmarshaller</CODE></A> 提供解组事件回调</DL>
</DD>
</DL>
<HR>

<A NAME="getListener()"><!-- --></A><H3>
getListener</H3>
<PRE>
public <A HREF="../../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind 中的类">Unmarshaller.Listener</A> <B>getListener</B>()</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#getListener()">Unmarshaller</A></CODE> 复制的描述</B></DD>
<DD><p>返回向此 <A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口"><CODE>Unmarshaller</CODE></A> 注册的 <A HREF="../../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind 中的类"><CODE>Unmarshaller.Listener</CODE></A>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html" title="javax.xml.bind 中的接口">Unmarshaller</A></CODE> 中的 <CODE><A HREF="../../../../javax/xml/bind/Unmarshaller.html#getListener()">getListener</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>注册的 <A HREF="../../../../javax/xml/bind/Unmarshaller.Listener.html" title="javax.xml.bind 中的类"><CODE>Unmarshaller.Listener</CODE></A>；如果未向此 Unmarshaller 注册任何 Listener，则返回 <code>null</code>。</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractUnmarshallerImpl.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../javax/xml/bind/helpers/AbstractMarshallerImpl.html" title="javax.xml.bind.helpers 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../../javax/xml/bind/helpers/DefaultValidationEventHandler.html" title="javax.xml.bind.helpers 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?javax/xml/bind/helpers/AbstractUnmarshallerImpl.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="AbstractUnmarshallerImpl.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
