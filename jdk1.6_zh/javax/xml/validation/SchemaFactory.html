<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 13:48:08 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
SchemaFactory (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SchemaFactory (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SchemaFactory.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/xml/validation/SchemaFactoryLoader.html" title="javax.xml.validation 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/xml/validation/SchemaFactory.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="SchemaFactory.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.xml.validation</FONT>
<BR>
类 SchemaFactory</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="继承者 "><B>javax.xml.validation.SchemaFactory</B>
</PRE>
<HR>
<DL>
<DT><PRE>public abstract class <B>SchemaFactory</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A></DL>
</PRE>

<P>
创建 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象的工厂。验证 API 的入口点。

 <p>
<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 是一个模式编译器。它读取模式的外部表示形式并准备验证它们。
 
 <p>
<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 类不是线程安全的。换句话说，应用程序负责确保任意给定时刻至多只有一个线程使用 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 对象。鼓励实现将方法标记为 <code>synchronized</code>，以保护客户机不至于崩溃。
 
 <p>
<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 不是重入（re-entrant）方法。当正在调用某个 <code>newSchema</code> 方法时，应用程序不能试图以递归方式调用 <code>newSchema</code> 方法，甚至不能从相同线程调用该方法。
 
<h2><a name="schemaLanguage"></a>模式语言</h2>
 <p>
此规范使用名称空间 URI 来指定模式语言。下表显示了此规范定义的值。
 <p>
要遵守此规范，实现只需支持 W3C XML 模式 1.0 即可。但是，如果实现选择支持其他模式语言，那么它必须遵守此规范中所描述的相关行为。
 
 <p>
此处未列出的模式语言应引用它们自己的 URI 来表示它们本身。<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 类能够在运行时定位其他模式语言的其他实现。
 
 <p>
注意，因为 XML DTD 与解析过程有紧密联系，并对解析过程产生很大影响，因此不能将 DTD 验证定义为与解析无关的过程。出于此原因，此规范不定义 XML DTD 的语义。这并不限制实现者以他们了解的合适方式来实现它，但<em>这里提醒用户，此接口上实现的任何 DTD 验证必然偏离 XML 1.0 中所定义的 XML DTD 语义</em>。
 
 <table border="1" cellpadding="2">
   <thead>
     <tr>
<th>值</th>
<th>语言</th>
     </tr>
   </thead>
   <tbody>
     <tr>
       <td><A HREF="../../../javax/xml/XMLConstants.html#W3C_XML_SCHEMA_NS_URI"><CODE>XMLConstants.W3C_XML_SCHEMA_NS_URI</CODE></A> (&quot;<code>http://www.w3.org/2001/XMLSchema</code>&quot;)</td>
       <td><a href="http://www.w3.org/TR/xmlschema-1">W3C XML Schema 1.0</a></td>
     </tr>
     <tr>
       <td><A HREF="../../../javax/xml/XMLConstants.html#RELAXNG_NS_URI"><CODE>XMLConstants.RELAXNG_NS_URI</CODE></A> (&quot;<code>http://relaxng.org/ns/structure/1.0</code>&quot;)</td>
       <td><a href="http://www.relaxng.org/">RELAX NG 1.0</a></td>
     </tr>
   </tbody>
 </table>
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#SchemaFactory()">SchemaFactory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;派生类的构造方法。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口">ErrorHandler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#getErrorHandler()">getErrorHandler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取设置为此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 的当前 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#getFeature(java.lang.String)">getFeature</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找功能标志的值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#getProperty(java.lang.String)">getProperty</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找属性值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口">LSResourceResolver</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#getResourceResolver()">getResourceResolver</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取设置为此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 的当前 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口"><CODE>LSResourceResolver</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#isSchemaLanguageSupported(java.lang.String)">isSchemaLanguageSupported</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;schemaLanguage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此 <code>SchemaFactory</code> 支持指定的模式吗？</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类">SchemaFactory</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newInstance(java.lang.String)">newInstance</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;schemaLanguage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找支持指定模式语言的 <code>SchemaFactory</code> 的实现并返回它。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类">SchemaFactory</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newInstance(java.lang.String, java.lang.String, java.lang.ClassLoader)">newInstance</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;schemaLanguage,
            <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;factoryClassName,
            <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;classLoader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据类名称获得一个新 <code>SchemaFactory</code> 实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema()">newSchema</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建特殊的 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(java.io.File)">newSchema</A></B>(<A HREF="../../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;schema)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解析作为模式的指定 <code>File</code> 并以 <code>Schema</code> 的形式返回它。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source)">newSchema</A></B>(<A HREF="../../../javax/xml/transform/Source.html" title="javax.xml.transform 中的接口">Source</A>&nbsp;schema)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解析作为模式的指定源并以模式形式返回它。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source[])">newSchema</A></B>(<A HREF="../../../javax/xml/transform/Source.html" title="javax.xml.transform 中的接口">Source</A>[]&nbsp;schemas)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解析作为模式的指定源（或多个源），并以模式形式返回它。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(java.net.URL)">newSchema</A></B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;schema)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解析作为模式的指定 <code>URL</code> 并以 <code>Schema</code> 形式返回它。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)">setErrorHandler</A></B>(<A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口">ErrorHandler</A>&nbsp;errorHandler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 以接收在 <code>newSchema</code> 方法调用期间遇到的错误。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#setFeature(java.lang.String, boolean)">setFeature</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
           boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此 <code>SchemaFactory</code> 的特性，<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 由此工厂创建，更进一步说，<A HREF="../../../javax/xml/validation/Validator.html" title="javax.xml.validation 中的类"><CODE>Validator</CODE></A> 和 <A HREF="../../../javax/xml/validation/ValidatorHandler.html" title="javax.xml.validation 中的类"><CODE>ValidatorHandler</CODE></A> 由这些 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 创建。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
            <A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置属性值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#setResourceResolver(org.w3c.dom.ls.LSResourceResolver)">setResourceResolver</A></B>(<A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口">LSResourceResolver</A>&nbsp;resourceResolver)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口"><CODE>LSResourceResolver</CODE></A> 以自定义解析模式时的资源解析。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SchemaFactory()"><!-- --></A><H3>
SchemaFactory</H3>
<PRE>
protected <B>SchemaFactory</B>()</PRE>
<DL>
<DD><p>派生类的构造方法。</p>
 
<p>构造方法不执行任何动作。</p>
 
<p>派生类必须创建具有 <code>null</code> <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 和 <code>null</code> <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口"><CODE>LSResourceResolver</CODE></A> 的 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 对象。</p>
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="newInstance(java.lang.String)"><!-- --></A><H3>
newInstance</H3>
<PRE>
public static final <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类">SchemaFactory</A> <B>newInstance</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;schemaLanguage)</PRE>
<DL>
<DD><p>查找支持指定模式语言的 <code>SchemaFactory</code> 的实现并返回它。</p>
 
<p>为了查找给定模式语言的 <code>SchemaFactory</code> 对象，此方法按照以下顺序查找以下位置，其中&ldquo;类加载器&rdquo;指上下文类加载器：</p>
 <ol>
  <li>
如果系统属性 <code>&quot;javax.xml.validation.SchemaFactory:<i>schemaLanguage</i>&quot;</code> 存在（其中 <i>schemaLanguage</i> 是此方法的参数），那么可以将它的值作为类名称来读取。该方法试图通过使用类加载器来创建此类的新实例，如果创建成功，则返回它。
   </li>
   <li>
读取 <code>$java.home/lib/jaxp.properties</code>，并查找与作为系统属性的键关联的值。如果存在这样的值，则按上面的方式处理该值。
   </li>
   <li>
<p>类加载器要求服务提供者的提供者配置文件与资源目录 META-INF/services 中的 <code>javax.xml.validation.SchemaFactory</code> 匹配。参见文件格式和解析规则的 JAR File Specification。每个可能的服务提供者均要实现以下方法：</p>
     <pre>
        <A HREF="../../../javax/xml/validation/SchemaFactory.html#isSchemaLanguageSupported(java.lang.String)"><CODE>isSchemaLanguageSupported(String schemaLanguage)</CODE></A>
     </pre> 
返回支持指定模式语言的类加载器顺序中的第一个服务提供者。
   </li>
   <li>
以特定于实现的方式来定位平台默认的 <code>SchemaFactory</code>。必须存在 W3C XML 模式的平台默认 <code>SchemaFactory</code>。
   </li>
 </ol>
 
<p>如果这些都失败，则将抛出 <A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类"><CODE>IllegalArgumentException</CODE></A>。</p>
 
<p><strong>疑难解答提示：</strong></p>
<p>有关如何精确解析属性文件的信息，请参阅 <A HREF="../../../java/util/Properties.html#load(java.io.InputStream)"><CODE>Properties.load(java.io.InputStream)</CODE></A>。尤其要指出的是，冒号 ':'在属性文件中需要转义，因此要确保模式语言 URI 在其中进行正确转义。例如：</p>
 <pre>
 http\://www.w3.org/2001/XMLSchema=org.acme.foo.XSSchemaFactory
 </pre>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>schemaLanguage</CODE> - 指定返回的 SchemaFactory 理解的模式语言。有关可能的值，请参阅 <a href="#schemaLanguage">可用模式语言列表</a>。
<DT><B>返回：</B><DD>新的 <code>SchemaFactory</code> 实例
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果没有可用的模式语言实现。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>schemaLanguage</code> 参数为 null。<DT><B>另请参见：</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#newInstance(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>newInstance(String schemaLanguage, String factoryClassName, ClassLoader classLoader)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="newInstance(java.lang.String, java.lang.String, java.lang.ClassLoader)"><!-- --></A><H3>
newInstance</H3>
<PRE>
public static <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类">SchemaFactory</A> <B>newInstance</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;schemaLanguage,
                                        <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;factoryClassName,
                                        <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;classLoader)</PRE>
<DL>
<DD><p>根据类名称获得一个新 <code>SchemaFactory</code> 实例。如果指定的工厂类支持指定的模式语言，则返回 <code>SchemaFactory</code>。当类路径中有多个提供者时此功能很有用。它给了应用程序更多的控制权，因为它能指定应该加载哪个提供者。</p>
     
 <h2>疑难解答提示</h2>
 <p>设置 <code>jaxp.debug</code> 系统属性将导致此方法将许多调试消息打印到 <code>System.err</code>，以说明它执行的操作以及在何处查找这些操作。</p>
 
 <p> 如有问题，请尝试：</p>
 <pre>
 java -Djaxp.debug=1 YourProgram ....
 </pre>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>schemaLanguage</CODE> - 指定返回的 <code>SchemaFactory</code> 理解的模式语言。有关可能的值，请参阅 <a href="#schemaLanguage">the list of available schema languages</a>。<DD><CODE>factoryClassName</CODE> - 完全限定工厂类名称，提供 <code>javax.xml.validation.SchemaFactory</code> 的实现。<DD><CODE>classLoader</CODE> - 用来加载工厂类的 <code>ClassLoader</code>。如果为 <code>null</code>，则使用当前 <code>Thread</code> 的上下文 classLoader 来加载工厂类。
<DT><B>返回：</B><DD>新的 <code>SchemaFactory</code> 实例
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>factoryClassName</code> 为 <code>null</code>、工厂类不能被加载或实例化、工厂类不支持 <code>schemLanguage</code> 参数中指定的模式语言。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>schemaLanguage</code> 参数为 null。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#newInstance(java.lang.String)"><CODE>newInstance(String schemaLanguage)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isSchemaLanguageSupported(java.lang.String)"><!-- --></A><H3>
isSchemaLanguageSupported</H3>
<PRE>
public abstract boolean <B>isSchemaLanguageSupported</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;schemaLanguage)</PRE>
<DL>
<DD><p>此 <code>SchemaFactory</code> 支持指定的模式吗？</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>schemaLanguage</CODE> - 指定返回的 <code>SchemaFactory</code> 理解的模式语言。<code>schemaLanguage</code> 必须指定<a href="#schemaLanguage">有效的</a>模式语言。
<DT><B>返回：</B><DD>如果 <code>SchemaFactory</code> 支持 <code>schemaLanguage</code>，则返回 <code>true</code>，否则返回 <code>false</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>schemaLanguage</code> 为 <code>null</code>。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>schemaLanguage.length() == 0</code> 或 <code>schemaLanguage</code> 未指定<a href="#schemaLanguage">有效的</a>模式语言。</DL>
</DD>
</DL>
<HR>

<A NAME="getFeature(java.lang.String)"><!-- --></A><H3>
getFeature</H3>
<PRE>
public boolean <B>getFeature</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                   throws <A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 中的类">SAXNotRecognizedException</A>,
                          <A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 中的类">SAXNotSupportedException</A></PRE>
<DL>
<DD>查找功能标志的值。

<p>功能名称是任何完全限定的 URI。<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 有可能识别功能名称，但暂时不能返回其值。

<p>实现者可随意选择（鼓励）创建自己的功能，方法是使用在它们自己的 URI 上构建的名称。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 功能名称，它是非 null 的完全限定 URI。
<DT><B>返回：</B><DD>功能的当前值（true 或 false）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 中的类">SAXNotRecognizedException</A></CODE> - 如果不能分配或检索功能值。
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 中的类">SAXNotSupportedException</A></CODE> - 当 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 可以识别功能名称但不能确定它此时的值时。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>name</code> 为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#setFeature(java.lang.String, boolean)"><CODE>setFeature(String, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFeature(java.lang.String, boolean)"><!-- --></A><H3>
setFeature</H3>
<PRE>
public void <B>setFeature</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                       boolean&nbsp;value)
                throws <A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 中的类">SAXNotRecognizedException</A>,
                       <A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 中的类">SAXNotSupportedException</A></PRE>
<DL>
<DD><p>设置此 <code>SchemaFactory</code> 的特性，<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 由此工厂创建，更进一步说，<A HREF="../../../javax/xml/validation/Validator.html" title="javax.xml.validation 中的类"><CODE>Validator</CODE></A> 和 <A HREF="../../../javax/xml/validation/ValidatorHandler.html" title="javax.xml.validation 中的类"><CODE>ValidatorHandler</CODE></A> 由这些 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 创建。
 </p>

 <p>实现者和开发人员应该特别注意 <A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema()"><CODE>newSchema()</CODE></A> 返回的特殊 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象是如何处理的。在某些情况下，例如，当 <code>SchemaFactory</code> 和类实际上加载来自不同实现的模式时，<code>SchemaFactory</code> 特性将无法自动继承。开发人员应该确保在两个地方都显式地设置了特性（如安全处理）。</p>

<p>功能名称是任何完全限定的 URI。<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 有可能公开功能值，但不能更改当前值。</p>

<p>所有实现必须支持 <A HREF="../../../javax/xml/XMLConstants.html#FEATURE_SECURE_PROCESSING"><CODE>XMLConstants.FEATURE_SECURE_PROCESSING</CODE></A> 功能。当功能为以下情况时：</p>
 <ul>
   <li>
<code>true</code>：该实现将限制 XML 处理遵守实现限制。示例包括实体扩展限制和将使用大量资源的 XML 模式构造。如果由于安全原因 XML 处理受到限制，则将通过调用注册的 <A HREF="../../../org/xml/sax/ErrorHandler.html#fatalError(org.xml.sax.SAXParseException)"><CODE>ErrorHandler.fatalError(SAXParseException exception)</CODE></A> 来报告此情况。参见 <A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)"><CODE>setErrorHandler(ErrorHandler errorHandler)</CODE></A>。
   </li>
   <li>
<code>false</code>：实现将根据 XML 规范来处理 XML，而不管可能的实现限制。
   </li>
 </ul>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 功能名称，它是非 null 的完全限定 URI。<DD><CODE>value</CODE> - 所请求的功能值（true 或 false）。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 中的类">SAXNotRecognizedException</A></CODE> - 如果不能分配或检索功能值。
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 中的类">SAXNotSupportedException</A></CODE> - 当 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 可以识别功能名称，但不能设置请求的值时。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>name</code> 为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#getFeature(java.lang.String)"><CODE>getFeature(String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setProperty(java.lang.String, java.lang.Object)"><!-- --></A><H3>
setProperty</H3>
<PRE>
public void <B>setProperty</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                        <A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;object)
                 throws <A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 中的类">SAXNotRecognizedException</A>,
                        <A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 中的类">SAXNotSupportedException</A></PRE>
<DL>
<DD>设置属性值。

<p>属性名称是任何完全限定的 URI。<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 有可能识别属性名称，但不能更改当前值。</p>

<p><A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 无需识别设置任何特定的属性名称。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 属性名称，它是非 null 的完全限定 URI。<DD><CODE>object</CODE> - 所请求的属性值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 中的类">SAXNotRecognizedException</A></CODE> - 如果不能分配或检索属性值。
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 中的类">SAXNotSupportedException</A></CODE> - 当 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 可以识别属性名称，但不能设置请求的值时。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>name</code> 为 <code>null</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="getProperty(java.lang.String)"><!-- --></A><H3>
getProperty</H3>
<PRE>
public <A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>getProperty</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                   throws <A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 中的类">SAXNotRecognizedException</A>,
                          <A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 中的类">SAXNotSupportedException</A></PRE>
<DL>
<DD>查找属性值。

<p>属性名称是任何完全限定的 URI。<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 有可能识别属性名称，但暂时不能返回其值。</p>

<p><A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 无需识别任何特定的属性名称。</p>

<p>实现者可随意选择（鼓励）创建自己的属性，方法是使用在它们自己的 URI 上构建的名称。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 属性名称，它是非 null 的完全限定 URI。
<DT><B>返回：</B><DD>属性的当前值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 中的类">SAXNotRecognizedException</A></CODE> - 如果不能分配或检索属性值。
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 中的类">SAXNotSupportedException</A></CODE> - 当 XMLReader 可以识别属性名称，但不能确定它此时的值时。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>name</code> 为 <code>null</code>。<DT><B>另请参见：</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#setProperty(java.lang.String, java.lang.Object)"><CODE>setProperty(String, Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setErrorHandler(org.xml.sax.ErrorHandler)"><!-- --></A><H3>
setErrorHandler</H3>
<PRE>
public abstract void <B>setErrorHandler</B>(<A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口">ErrorHandler</A>&nbsp;errorHandler)</PRE>
<DL>
<DD>设置 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 以接收在 <code>newSchema</code> 方法调用期间遇到的错误。
 
 <p>
错误处理程序可用于自定义模式解析期间的错误处理过程。当设置 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 时，模式解析期间发现的错误将首先发送到 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A>。
 
 <p>
通过抛出处理程序中的 <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类"><CODE>SAXException</CODE></A>，错误处理程序可以立即中止模式的解析。例如，它可以将错误打印到屏幕上，并尝试通过从 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 正常返回来继续该过程。
 
 <p>
如果从 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 抛出任何 <A HREF="../../../java/lang/Throwable.html" title="java.lang 中的类"><CODE>Throwable</CODE></A>（或其派生类的实例），则 <code>newSchema</code> 方法的调用者将接收相同的 <A HREF="../../../java/lang/Throwable.html" title="java.lang 中的类"><CODE>Throwable</CODE></A> 对象。
 
 <p>
在 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 没有先向 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 报告之前，不能抛出 <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类"><CODE>SAXException</CODE></A>。
 
 <p>
甚至正在解析 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 期间，应用程序也可以调用此方法。 
 
 <p>
当 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 为 null 时，实现的行为就好像设置了以下 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 一样。
 <pre>
 class DraconianErrorHandler implements <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> {
     public void fatalError( <A HREF="../../../org/xml/sax/SAXParseException.html" title="org.xml.sax 中的类"><CODE>SAXParseException</CODE></A> e ) throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类"><CODE>SAXException</CODE></A> {
         throw e;
     }
     public void error( <A HREF="../../../org/xml/sax/SAXParseException.html" title="org.xml.sax 中的类"><CODE>SAXParseException</CODE></A> e ) throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类"><CODE>SAXException</CODE></A> {
         throw e;
     }
     public void warning( <A HREF="../../../org/xml/sax/SAXParseException.html" title="org.xml.sax 中的类"><CODE>SAXParseException</CODE></A> e ) throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类"><CODE>SAXException</CODE></A> {
         // noop
     }
 }
 </pre>
 
 <p>
当创建新 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 对象时，此字段在初始化时被设置为 null。<em>不要</em> 将此字段继承给从此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 创建的 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A>、<A HREF="../../../javax/xml/validation/Validator.html" title="javax.xml.validation 中的类"><CODE>Validator</CODE></A> 或 <A HREF="../../../javax/xml/validation/ValidatorHandler.html" title="javax.xml.validation 中的类"><CODE>ValidatorHandler</CODE></A>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>errorHandler</CODE> - 要设置的新错误处理程序。此参数可以为 <code>null</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="getErrorHandler()"><!-- --></A><H3>
getErrorHandler</H3>
<PRE>
public abstract <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口">ErrorHandler</A> <B>getErrorHandler</B>()</PRE>
<DL>
<DD>获取设置为此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 的当前 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A>。
<P>
<DD><DL>

<DT><B>返回：</B><DD>此方法返回通过 <A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)"><CODE>setErrorHandler(ErrorHandler)</CODE></A> 方法设置的最后一个对象，如果自从创建此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 以来一直未调用该方法，则返回 null。<DT><B>另请参见：</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)"><CODE>setErrorHandler(ErrorHandler)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setResourceResolver(org.w3c.dom.ls.LSResourceResolver)"><!-- --></A><H3>
setResourceResolver</H3>
<PRE>
public abstract void <B>setResourceResolver</B>(<A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口">LSResourceResolver</A>&nbsp;resourceResolver)</PRE>
<DL>
<DD>设置 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口"><CODE>LSResourceResolver</CODE></A> 以自定义解析模式时的资源解析。
 
 <p>
在模式解析中，<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 在需要查找外部资源时使用 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口"><CODE>LSResourceResolver</CODE></A>，虽然&ldquo;查找外部资源&rdquo;的准确含义取决于每个模式语言。例如，对于 W3C XML Schema，这包括文件 <code>&lt;include></code>d 或 <code>&lt;import></code>ed，以及从模式文件引用的 DTD 等。
 
 <p>
甚至正在解析 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 期间，应用程序也可以调用此方法。 
 
 <p>
当 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口"><CODE>LSResourceResolver</CODE></A> 为 null 时，实现的行为就好像设置了以下 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口"><CODE>LSResourceResolver</CODE></A> 一样：
 <pre>
 class DumbDOMResourceResolver implements <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口"><CODE>LSResourceResolver</CODE></A> {
     public <A HREF="../../../org/w3c/dom/ls/LSInput.html" title="org.w3c.dom.ls 中的接口"><CODE>LSInput</CODE></A> resolveResource(
         String publicId, String systemId, String baseURI) {
         
         return null; // always return null
     }
 }
 </pre>
 
 <p>
如果 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口"><CODE>LSResourceResolver</CODE></A> 抛出 <A HREF="../../../java/lang/RuntimeException.html" title="java.lang 中的类"><CODE>RuntimeException</CODE></A>（或其派生类的实例），则 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 将中止解析，且 <code>newSchema</code> 方法的调用者将接收相同的 <A HREF="../../../java/lang/RuntimeException.html" title="java.lang 中的类"><CODE>RuntimeException</CODE></A>。 
 
 <p>
当创建新 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 对象时，此字段在初始化时被设置为 null。<em>不要</em> 将此字段继承给从此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 创建的 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A>、<A HREF="../../../javax/xml/validation/Validator.html" title="javax.xml.validation 中的类"><CODE>Validator</CODE></A> 或 <A HREF="../../../javax/xml/validation/ValidatorHandler.html" title="javax.xml.validation 中的类"><CODE>ValidatorHandler</CODE></A>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>resourceResolver</CODE> - 要设置的新资源解析器。此参数可以为 null。</DL>
</DD>
</DL>
<HR>

<A NAME="getResourceResolver()"><!-- --></A><H3>
getResourceResolver</H3>
<PRE>
public abstract <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口">LSResourceResolver</A> <B>getResourceResolver</B>()</PRE>
<DL>
<DD>获取设置为此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 的当前 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 中的接口"><CODE>LSResourceResolver</CODE></A>。
<P>
<DD><DL>

<DT><B>返回：</B><DD>此方法返回通过 <A HREF="../../../javax/xml/validation/SchemaFactory.html#setResourceResolver(org.w3c.dom.ls.LSResourceResolver)"><CODE>setResourceResolver(LSResourceResolver)</CODE></A> 方法设置的最后一个对象，如果自从创建此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 以来一直未调用该方法，则返回 null。<DT><B>另请参见：</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)"><CODE>setErrorHandler(ErrorHandler)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="newSchema(javax.xml.transform.Source)"><!-- --></A><H3>
newSchema</H3>
<PRE>
public <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A> <B>newSchema</B>(<A HREF="../../../javax/xml/transform/Source.html" title="javax.xml.transform 中的接口">Source</A>&nbsp;schema)
                 throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A></PRE>
<DL>
<DD><p>解析作为模式的指定源并以模式形式返回它。</p>
 
<p>这是一个针对 <A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source[])"><CODE>newSchema(Source[] schemas)</CODE></A> 的便捷方法。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>schema</CODE> - 表示模式的源。
<DT><B>返回：</B><DD>从解析 <code>schema</code> 得到的新 <code>Schema</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A></CODE> - 如果解析期间发生 SAX 错误。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>schema</code> 为 null。</DL>
</DD>
</DL>
<HR>

<A NAME="newSchema(java.io.File)"><!-- --></A><H3>
newSchema</H3>
<PRE>
public <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A> <B>newSchema</B>(<A HREF="../../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;schema)
                 throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A></PRE>
<DL>
<DD><p>解析作为模式的指定 <code>File</code> 并以 <code>Schema</code> 的形式返回它。</p>
 
<p>这是一个针对 <A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source)"><CODE>newSchema(Source schema)</CODE></A> 的便捷方法。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>schema</CODE> - 表示模式的 File。
<DT><B>返回：</B><DD>从解析 <code>schema</code> 得到的新 <code>Schema</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A></CODE> - 如果解析期间发生 SAX 错误。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>schema</code> 为 null。</DL>
</DD>
</DL>
<HR>

<A NAME="newSchema(java.net.URL)"><!-- --></A><H3>
newSchema</H3>
<PRE>
public <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A> <B>newSchema</B>(<A HREF="../../../java/net/URL.html" title="java.net 中的类">URL</A>&nbsp;schema)
                 throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A></PRE>
<DL>
<DD><p>解析作为模式的指定 <code>URL</code> 并以 <code>Schema</code> 形式返回它。</p>
 
<p>这是一个针对 <A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source)"><CODE>newSchema(Source schema)</CODE></A> 的便捷方法。</p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>schema</CODE> - 表示模式的 <code>URL</code>。
<DT><B>返回：</B><DD>从解析 <code>schema</code> 得到的新 <code>Schema</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A></CODE> - 如果解析期间发生 SAX 错误。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>schema</code> 为 null。</DL>
</DD>
</DL>
<HR>

<A NAME="newSchema(javax.xml.transform.Source[])"><!-- --></A><H3>
newSchema</H3>
<PRE>
public abstract <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A> <B>newSchema</B>(<A HREF="../../../javax/xml/transform/Source.html" title="javax.xml.transform 中的接口">Source</A>[]&nbsp;schemas)
                          throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A></PRE>
<DL>
<DD>解析作为模式的指定源（或多个源），并以模式形式返回它。
 
 <p>
被调用者将读取所有 <A HREF="../../../javax/xml/transform/Source.html" title="javax.xml.transform 中的接口"><CODE>Source</CODE></A> 并将它们组合到一个模式中。组合的精确语义取决于此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 对象为其创建的模式语言。
 
 <p>
当设置 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 时，被调用者将向处理程序报告源中发现的所有错误。如果处理程序执行异常，则它将中止模式组合，且将从此方法抛出相同的异常。同样，向处理程序报告错误后，允许被调用者通过抛出该错误来中止下一步处理。如果未设置错误处理程序，则被调用者将抛出在源中发现的第一个错误。   
 
 <h2>W3C XML 模式 1.0</h2>
 <p>
得到的模式包含来自指定源的组件。如果使用合适的 schemaLocation 值和名称空间值将所有这些源导入具有不同 targetNamespace 且没有其自己组件的单个模式文档中，如果以与源相同的顺序给定导入元素，则将得到相同结果。XML 模式建议的第 4.2.3 节描述了处理器关于这方面的选项。当处理器应与其 JAXP 模式源和 XML 模式导入的处理一致时，JAXP 兼容的解析器之间的行为可能不同，特别是解析器可能选择忽略所有给定名称空间的 &lt;import&gt;（第一个除外），而不管 schemaLocation 中所提供的信息。
 
 <p>
如果解析后的模式集包含 XML 模式规范第 5.1 节指定的错误（或多个错误），则必须将错误报告给 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A>。
 
 <h2>RELAX NG</h2>
 
<p>对于 RELAX NG，如果 <code>schemas.length!=1</code>，则此方法必须抛出 <A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类"><CODE>UnsupportedOperationException</CODE></A>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>schemas</CODE> - 要解析的输入。<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 必须识别 <A HREF="../../../javax/xml/transform/sax/SAXSource.html" title="javax.xml.transform.sax 中的类"><CODE>SAXSource</CODE></A>、<A HREF="../../../javax/xml/transform/stream/StreamSource.html" title="javax.xml.transform.stream 中的类"><CODE>StreamSource</CODE></A>、<A HREF="../../../javax/xml/transform/stax/StAXSource.html" title="javax.xml.transform.stax 中的类"><CODE>StAXSource</CODE></A> 和 <A HREF="../../../javax/xml/transform/dom/DOMSource.html" title="javax.xml.transform.dom 中的类"><CODE>DOMSource</CODE></A>。输入模式必须是 XML 文档或 XML 元素，并且不得为 null。为了向后兼容，传递文档或元素以外的任何内容的所得结果都由实现决定。实现必须能识别并处理输入，否则将抛出 IllegalArgumentException。
<DT><B>返回：</B><DD>总返回非 null 的有效 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象。注意，当已报告错误后，不保证返回的 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象有意义。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A></CODE> - 如果在处理指定输入期间发现错误。当设置 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 中的接口"><CODE>ErrorHandler</CODE></A> 时，首先将错误报告到该处。参见 <A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)"><CODE>setErrorHandler(ErrorHandler)</CODE></A>。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>schemas</code> 参数本身为 null，或数组中的任何项为 null。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果此方法不识别数组中的任何项。
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果模式语言不支持此操作。</DL>
</DD>
</DL>
<HR>

<A NAME="newSchema()"><!-- --></A><H3>
newSchema</H3>
<PRE>
public abstract <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类">Schema</A> <B>newSchema</B>()
                          throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A></PRE>
<DL>
<DD>创建特殊的 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象。
 
 <p>
返回的 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象的精确语义取决于此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 为其创建的模式语言。
 
 <p>
同样，允许实现使用特定于实现的属性/功能来更改此方法的语义。</p>

 <p>实现者和开发人员应该特别注意此 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 上设置的特性是如何由此特殊 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象处理的。在某些情况下，例如，当 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 和类实际上加载来自不同实现的模式时，<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 中的类"><CODE>SchemaFactory</CODE></A> 特性将无法自动继承。开发人员应该确保在两个地方都显式地设置了特性（如安全处理）。</p>
 
 
 <h2>W3C XML 模式 1.0</h2>
 <p>
对于 XML 模式，此方法创建 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象，该对象通过使用文档中指定的位置提示来执行验证。
 
 <p>
返回的 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象假定如果文档指向模式位置提示中的相同 URL，则它们将总是解析为相同的模式文档。此假定允许实现重用解析后的模式文档结果，以便相对于相同模式的多个验证可以更快地运行。
 
 <p>
注意，模式位置提示的使用引入了恶意的拒绝服务攻击。 
   
 <h2>RELAX NG</h2>
 <p>
RELAX NG 不支持此操作。
<P>
<DD><DL>

<DT><B>返回：</B><DD>总返回非 null 的有效 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><CODE>Schema</CODE></A> 对象。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果被调用者不支持此操作。
<DD><CODE><A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 中的类">SAXException</A></CODE> - 如果此操作受支持但由于某种原因而失败。</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SchemaFactory.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/xml/validation/SchemaFactoryLoader.html" title="javax.xml.validation 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/xml/validation/SchemaFactory.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="SchemaFactory.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
