<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 12:47:38 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
File (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="File (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/File.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/Externalizable.html" title="java.io 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/io/FileDescriptor.html" title="java.io 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/io/File.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="File.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.io</FONT>
<BR>
类 File</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.io.File</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../java/io/Serializable.html" title="java.io 中的接口">Serializable</A>, <A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口">Comparable</A>&lt;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&gt;</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>File</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A><DT>implements <A HREF="../../java/io/Serializable.html" title="java.io 中的接口">Serializable</A>, <A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口">Comparable</A>&lt;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&gt;</DL>
</PRE>

<P>
文件和目录路径名的抽象表示形式。

<p> 用户界面和操作系统使用与系统相关的<em>路径名字符串</em> 来命名文件和目录。此类呈现分层路径名的一个抽象的、与系统无关的视图。<em>抽象路径名</em> 有两个组件：

 <ol>
<li> 一个可选的与系统有关的<em>前缀</em> 字符串，比如盘符，<code>&quot;/&quot;</code>&#xA0;表示 UNIX 中的根目录，<code>&quot;\\\\&quot;</code>&#xA0;表示 Microsoft Windows UNC 路径名。
<li> 零个或更多字符串<em>名称</em> 的序列。
 </ol>

抽象路径名中的第一个名称是目录名，对于 Microsoft Windows UNC 路径名则是主机名。抽象路径名中第一个名称之后的每个名称表示一个目录；最后一个名称既可以表示目录，也可以表示文件。<em>空</em> 抽象路径名没有前缀和名称序列。

<p> 路径名字符串与抽象路径名之间的转换与系统有关。将抽象路径名转换为路径名字符串时，每个名称与下一个名称之间用一个默认<em>分隔符</em> 隔开。默认名称分隔符由系统属性 <code>file.separator</code> 定义，可通过此类的公共静态字段 <code><A HREF="../../java/io/File.html#separator"><CODE>separator</CODE></A></code> 和 <code><A HREF="../../java/io/File.html#separatorChar"><CODE>separatorChar</CODE></A></code> 使其可用。将路径名字符串转换为抽象路径名时，可以使用默认名称分隔符或者底层系统支持的任何其他名称分隔符来分隔其中的名称。

<p> 无论是抽象路径名还是路径名字符串，都可以是<em>绝对</em> 路径名或<em>相对</em> 路径名。绝对路径名是完整的路径名，不需要任何其他信息就可以定位它所表示的文件。相反，相对路径名必须使用取自其他路径名的信息进行解释。默认情况下，<code>java.io</code> 包中的类总是根据当前用户目录来解析相对路径名。此目录由系统属性 <code>user.dir</code> 指定，通常是 Java 虚拟机的调用目录。

 <p> 调用此类的 <A HREF="../../java/io/File.html#getParent()"><CODE>getParent()</CODE></A> 方法可以获取抽象路径名的<em>父</em> 路径名，它由路径名前缀以及路径名名称序列中的每个名称（最后一个除外）组成。对于任何具有绝对抽象路径名的 <tt>File</tt> 对象，如果其绝对抽象路径名以某个目录的绝对路径名开头，那么该目录的绝对路径名是该 <tt>File</tt> 对象的祖先。例如，抽象路径名 <tt>"/usr"</tt> 表示的目录是路径名 <tt>"/usr/local/bin"</tt> 所表示目录的一个祖先。

<p> 在处理 UNIX 平台的根目录，以及 Microsoft Windows 平台的盘符、根目录和 UNC 路径名时，将用到前缀这一概念。如下所示：

 <ul>

<li> 对于 UNIX 平台，绝对路径名的前缀始终是 <code>&quot;/&quot;</code>。相对路径名没有前缀。表示根目录的绝对路径名的前缀为 <code>&quot;/&quot;</code> 且名称序列为空。

<li> 对于 Microsoft Windows 平台，包含盘符的路径名前缀由驱动器号和一个 <code>&quot;:&quot;</code> 组成。如果路径名是绝对路径名，还可能后跟 <code>&quot;\\&quot;</code>。UNC 路径名的前缀是 <code>&quot;\\\\&quot;</code>；主机名和共享名是名称序列中的前两个名称。没有指定驱动器的相对路径名没有前缀。

 </ul>
 <p> 此类的实例可能表示（也可能不表示）实际文件系统对象，如文件或目录。如果它表示这种对象，那么该对象驻留在一个<i>分区</i> 中。分区是文件系统特定于操作系统的存储分区。一个存储设备（例如，物理磁盘驱动器、闪存、CD-ROM）可以包含多个分区。对象（如果有）将驻留在此路径名（绝对形式）某个祖先指定的分区上。

 <p> 文件系统可以实现对实际文件系统对象上的某些操作（比如，读、写、执行）进行限制。这些限制统称为<i>访问权限</i>。文件系统可以对一个对象设置多个访问权限。例如，一个设置可能适用于对象的<i>所有者</i>，另一个设置则可能适用于所有其他用户。对象上的访问权限可能导致此类的某些方法执行失败。

<p> <code>File</code> 类的实例是不可变的；也就是说，一旦创建，<code>File</code> 对象表示的抽象路径名将永不改变。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../serialized-form.html#java.io.File">序列化表格</A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#pathSeparator">pathSeparator</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与系统有关的路径分隔符，为了方便，它被表示为一个字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#pathSeparatorChar">pathSeparatorChar</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与系统有关的路径分隔符。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#separator">separator</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#separatorChar">separatorChar</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与系统有关的默认名称分隔符。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/io/File.html#File(java.io.File, java.lang.String)">File</A></B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;parent,
     <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;child)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 parent 抽象路径名和 child 路径名字符串创建一个新 <code>File</code> 实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/io/File.html#File(java.lang.String)">File</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;pathname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过将给定路径名字符串转换为抽象路径名来创建一个新 <code>File</code> 实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/io/File.html#File(java.lang.String, java.lang.String)">File</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;parent,
     <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;child)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 parent 路径名字符串和 child 路径名字符串创建一个新 <code>File</code> 实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/io/File.html#File(java.net.URI)">File</A></B>(<A HREF="../../java/net/URI.html" title="java.net 中的类">URI</A>&nbsp;uri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过将给定的 <tt>file:</tt> URI 转换为一个抽象路径名来创建一个新的 <tt>File</tt> 实例。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#canExecute()">canExecute</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试应用程序是否可以执行此抽象路径名表示的文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#canRead()">canRead</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试应用程序是否可以读取此抽象路径名表示的文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#canWrite()">canWrite</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试应用程序是否可以修改此抽象路径名表示的文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#compareTo(java.io.File)">compareTo</A></B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;pathname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按字母顺序比较两个抽象路径名。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#createNewFile()">createNewFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#createTempFile(java.lang.String, java.lang.String)">createTempFile</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;prefix,
               <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;suffix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#createTempFile(java.lang.String, java.lang.String, java.io.File)">createTempFile</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;prefix,
               <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;suffix,
               <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;directory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#delete()">delete</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除此抽象路径名表示的文件或目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#deleteOnExit()">deleteOnExit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#equals(java.lang.Object)">equals</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名与给定对象是否相等。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#exists()">exists</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名表示的文件或目录是否存在。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getAbsoluteFile()">getAbsoluteFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名的绝对路径名形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getAbsolutePath()">getAbsolutePath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名的绝对路径名字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getCanonicalFile()">getCanonicalFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名的规范形式。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getCanonicalPath()">getCanonicalPath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名的规范路径名字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getFreeSpace()">getFreeSpace</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名<a href="#partName">指定的</a>分区中未分配的字节数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getName()">getName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回由此抽象路径名表示的文件或目录的名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getParent()">getParent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getParentFile()">getParentFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getPath()">getPath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将此抽象路径名转换为一个路径名字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getTotalSpace()">getTotalSpace</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名<a href="#partName">指定的</a>分区大小。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#getUsableSpace()">getUsableSpace</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名<a href="#partName">指定的</a>分区上可用于此虚拟机的字节数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算此抽象路径名的哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#isAbsolute()">isAbsolute</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名是否为绝对路径名。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#isDirectory()">isDirectory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名表示的文件是否是一个目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#isFile()">isFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名表示的文件是否是一个标准文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#isHidden()">isHidden</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试此抽象路径名指定的文件是否是一个隐藏文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#lastModified()">lastModified</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名表示的文件最后一次被修改的时间。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#length()">length</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回由此抽象路径名表示的文件的长度。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#list()">list</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#list(java.io.FilenameFilter)">list</A></B>(<A HREF="../../java/io/FilenameFilter.html" title="java.io 中的接口">FilenameFilter</A>&nbsp;filter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#listFiles()">listFiles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#listFiles(java.io.FileFilter)">listFiles</A></B>(<A HREF="../../java/io/FileFilter.html" title="java.io 中的接口">FileFilter</A>&nbsp;filter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#listFiles(java.io.FilenameFilter)">listFiles</A></B>(<A HREF="../../java/io/FilenameFilter.html" title="java.io 中的接口">FilenameFilter</A>&nbsp;filter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#listRoots()">listRoots</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列出可用的文件系统根。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#mkdir()">mkdir</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建此抽象路径名指定的目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#mkdirs()">mkdirs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#renameTo(java.io.File)">renameTo</A></B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;dest)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重新命名此抽象路径名表示的文件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#setExecutable(boolean)">setExecutable</A></B>(boolean&nbsp;executable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此抽象路径名所有者执行权限的一个便捷方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#setExecutable(boolean, boolean)">setExecutable</A></B>(boolean&nbsp;executable,
              boolean&nbsp;ownerOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此抽象路径名的所有者或所有用户的执行权限。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#setLastModified(long)">setLastModified</A></B>(long&nbsp;time)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此抽象路径名指定的文件或目录的最后一次修改时间。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#setReadable(boolean)">setReadable</A></B>(boolean&nbsp;readable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此抽象路径名所有者读权限的一个便捷方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#setReadable(boolean, boolean)">setReadable</A></B>(boolean&nbsp;readable,
            boolean&nbsp;ownerOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此抽象路径名的所有者或所有用户的读权限。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#setReadOnly()">setReadOnly</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#setWritable(boolean)">setWritable</A></B>(boolean&nbsp;writable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此抽象路径名所有者写权限的一个便捷方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#setWritable(boolean, boolean)">setWritable</A></B>(boolean&nbsp;writable,
            boolean&nbsp;ownerOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置此抽象路径名的所有者或所有用户的写权限。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此抽象路径名的路径名字符串。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URI.html" title="java.net 中的类">URI</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#toURI()">toURI</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造一个表示此抽象路径名的 <tt>file:</tt> URI。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/File.html#toURL()">toURL</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 <A HREF="../../java/io/File.html#toURI()"><CODE>toURI</CODE></A> 方法将其转换为 URI，然后通过 <A HREF="../../java/net/URI.html#toURL()"><CODE>URI.toURL</CODE></A> 方法将 URI 装换为 URL。</I></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>字段详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="separatorChar"><!-- --></A><H3>
separatorChar</H3>
<PRE>
public static final char <B>separatorChar</B></PRE>
<DL>
<DD>与系统有关的默认名称分隔符。此字段被初始化为包含系统属性 <code>file.separator</code> 值的第一个字符。在 UNIX 系统上，此字段的值为 <code>'/'</code>；在 Microsoft Windows 系统上，它为 <code>'\\'</code>。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/System.html#getProperty(java.lang.String)"><CODE>System.getProperty(java.lang.String)</CODE></A></DL>
</DL>
<HR>

<A NAME="separator"><!-- --></A><H3>
separator</H3>
<PRE>
public static final <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>separator</B></PRE>
<DL>
<DD>与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。此字符串只包含一个字符，即 <code><A HREF="../../java/io/File.html#separatorChar"><CODE>separatorChar</CODE></A></code>。
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="pathSeparatorChar"><!-- --></A><H3>
pathSeparatorChar</H3>
<PRE>
public static final char <B>pathSeparatorChar</B></PRE>
<DL>
<DD>与系统有关的路径分隔符。此字段被初始为包含系统属性 <code>path.separator</code> 值的第一个字符。此字符用于分隔以<em>路径列表</em> 形式给定的文件序列中的文件名。在 UNIX 系统上，此字段为 <code>':'</code>；在 Microsoft Windows 系统上，它为 <code>';'</code>。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/System.html#getProperty(java.lang.String)"><CODE>System.getProperty(java.lang.String)</CODE></A></DL>
</DL>
<HR>

<A NAME="pathSeparator"><!-- --></A><H3>
pathSeparator</H3>
<PRE>
public static final <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>pathSeparator</B></PRE>
<DL>
<DD>与系统有关的路径分隔符，为了方便，它被表示为一个字符串。此字符串只包含一个字符，即 <code><A HREF="../../java/io/File.html#pathSeparatorChar"><CODE>pathSeparatorChar</CODE></A></code>。
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="File(java.lang.String)"><!-- --></A><H3>
File</H3>
<PRE>
public <B>File</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;pathname)</PRE>
<DL>
<DD>通过将给定路径名字符串转换为抽象路径名来创建一个新 <code>File</code> 实例。如果给定字符串是空字符串，那么结果是空抽象路径名。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>pathname</CODE> - 路径名字符串
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>pathname</code> 参数为 <code>null</code></DL>
</DL>
<HR>

<A NAME="File(java.lang.String, java.lang.String)"><!-- --></A><H3>
File</H3>
<PRE>
public <B>File</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;parent,
            <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;child)</PRE>
<DL>
<DD>根据 parent 路径名字符串和 child 路径名字符串创建一个新 <code>File</code> 实例。

<p> 如果 <code>parent</code> 为 <code>null</code>，则创建一个新的 <code>File</code> 实例，这与调用以给定 <code>child</code> 路径名字符串作为参数的单参数 <code>File</code> 构造方法效果一样。

<p> 否则，<code>parent</code> 路径名字符串用于表示目录，<code>child</code> 路径名字符串用于表示目录或文件。如果 <code>child</code> 路径名字符串是绝对路径名，则用与系统有关的方式将它转换为一个相对路径名。如果 <code>parent</code> 是空字符串，则通过将 <code>child</code> 转换为抽象路径名，并根据与系统有关的默认目录解析结果来创建新的 <code>File</code> 实例。否则，将每个路径名字符串转换为一个抽象路径名，并根据父抽象路径名解析子抽象路径名。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 父路径名字符串<DD><CODE>child</CODE> - 子路径名字符串
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>child</code> 为 <code>null</code></DL>
</DL>
<HR>

<A NAME="File(java.io.File, java.lang.String)"><!-- --></A><H3>
File</H3>
<PRE>
public <B>File</B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;parent,
            <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;child)</PRE>
<DL>
<DD>根据 parent 抽象路径名和 child 路径名字符串创建一个新 <code>File</code> 实例。

<p> 如果 <code>parent</code> 为 <code>null</code>，则创建一个新的 <code>File</code> 实例，这与调用给定 <code>child</code> 路径名字符串的单参数 <code>File</code> 构造方法的效果一样。

<p> 否则，<code>parent</code> 抽象路径名用于表示目录，<code>child</code> 路径名字符串用于表示目录或文件。如果 <code>child</code> 路径名字符串是绝对路径名，则用与系统有关的方式将它转换为一个相对路径名。如果 <code>parent</code> 是空抽象路径名，则通过将 <code>child</code> 转换为抽象路径名，并根据与系统有关的默认目录解析结果来创建新的 <code>File</code> 实例。否则，将每个路径名字符串转换为一个抽象路径名，并根据父抽象路径名解析子抽象路径名。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 父抽象路径名<DD><CODE>child</CODE> - 子路径名字符串
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>child</code> 为 <code>null</code></DL>
</DL>
<HR>

<A NAME="File(java.net.URI)"><!-- --></A><H3>
File</H3>
<PRE>
public <B>File</B>(<A HREF="../../java/net/URI.html" title="java.net 中的类">URI</A>&nbsp;uri)</PRE>
<DL>
<DD>通过将给定的 <tt>file:</tt> URI 转换为一个抽象路径名来创建一个新的 <tt>File</tt> 实例。

<p> <tt>file:</tt> URI 的具体形式与系统有关，因此，由此构造方法执行的转换也与系统有关。 

<p> 对于某个给定抽象路径名 <i>f</i>，可以保证：

<blockquote><tt>new File(</tt><i>&nbsp;f</i><tt>.<A HREF="../../java/io/File.html#toURI()"><CODE>toURI</CODE></A>()).equals(</tt><i>&nbsp;f</i><tt>.<A HREF="../../java/io/File.html#getAbsoluteFile()"><CODE>getAbsoluteFile</CODE></A>())</tt></blockquote>

只要原始抽象路径名、URI 和新抽象路径名都是在同一 Java 虚拟机（或者它的不同调用）中创建的。但是，当在某一操作系统上的虚拟机中创建的 <tt>file:</tt> URI 在不同操作系统上的虚拟机中被转换为抽象路径名时，这种关系通常是不成立的。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>uri</CODE> - 一个绝对分层 URI，由一个等于 <tt>&quot;file&quot;</tt> 的 scheme、非空的 path 组件，以及未定义的 authority、query 和 fragment 组件组成
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>uri</tt> 为 <tt>null</tt>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果关于参数的前提不成立<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#toURI()"><CODE>toURI()</CODE></A>, 
<A HREF="../../java/net/URI.html" title="java.net 中的类"><CODE>URI</CODE></A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getName()"><!-- --></A><H3>
getName</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getName</B>()</PRE>
<DL>
<DD>返回由此抽象路径名表示的文件或目录的名称。该名称是路径名名称序列中的最后一个名称。如果路径名名称序列为空，则返回空字符串。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名表示的文件或目录的名称；如果路径名的名称序列为空，则返回空字符串</DL>
</DD>
</DL>
<HR>

<A NAME="getParent()"><!-- --></A><H3>
getParent</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getParent</B>()</PRE>
<DL>
<DD>返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 <code>null</code>。

<p> 抽象路径名的<em>父</em> 路径名由路径名的前缀（如果有），以及路径名名称序列中最后一个名称以外的所有名称组成。如果名称序列为空，那么该路径名没有指定父目录。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名指定父目录的路径名字符串；如果此路径名没有指定父目录，则返回 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getParentFile()"><!-- --></A><H3>
getParentFile</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A> <B>getParentFile</B>()</PRE>
<DL>
<DD>返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 <code>null</code>。

<p> 抽象路径名的<em>父</em> 路径名由路径名的前缀（如果有），以及路径名名称序列中最后一个名称以外的所有名称组成。如果名称序列为空，那么该路径名没有指定父目录。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名指定父目录的抽象路径名；如果此路径名没有指定父目录，则返回 <code>null</code><DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPath()"><!-- --></A><H3>
getPath</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getPath</B>()</PRE>
<DL>
<DD>将此抽象路径名转换为一个路径名字符串。所得字符串使用<A HREF="../../java/io/File.html#separator"><CODE>默认名称分隔符</CODE></A>分隔名称序列中的名称。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名的字符串形式</DL>
</DD>
</DL>
<HR>

<A NAME="isAbsolute()"><!-- --></A><H3>
isAbsolute</H3>
<PRE>
public boolean <B>isAbsolute</B>()</PRE>
<DL>
<DD>测试此抽象路径名是否为绝对路径名。绝对路径名的定义与系统有关。在 UNIX 系统上，如果路径名的前缀是 <code>&quot;/&quot;</code>，那么该路径名是绝对路径名。在 Microsoft Windows 系统上，如果路径名的前缀是后跟 <code>&quot;\\&quot;</code> 的盘符，或者是 <code>&quot;\\\\&quot;</code>，那么该路径名是绝对路径名。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果此抽象路径名是绝对路径名，则返回 <code>true</code>；否则返回 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="getAbsolutePath()"><!-- --></A><H3>
getAbsolutePath</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getAbsolutePath</B>()</PRE>
<DL>
<DD>返回此抽象路径名的绝对路径名字符串。

<p> 如果此抽象路径名已经是绝对路径名，则返回该路径名字符串，这与 <code><A HREF="../../java/io/File.html#getPath()"><CODE>getPath()</CODE></A></code> 方法一样。如果此抽象路径名是空抽象路径名，则返回当前用户目录的路径名字符串，该目录由系统属性 <code>user.dir</code> 指定。否则，使用与系统有关的方式解析此路径名。在 UNIX 系统上，根据当前用户目录解析相对路径名，可使该路径名成为绝对路径名。在 Microsoft Windows 系统上，根据路径名指定的当前驱动器目录（如果有）解析相对路径名，可使该路径名成为绝对路径名；否则，可以根据当前用户目录解析它。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>绝对路径名字符串，它与此抽象路径名表示相同的文件或目录
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果无法访问所需的系统属性值。<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#isAbsolute()"><CODE>isAbsolute()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAbsoluteFile()"><!-- --></A><H3>
getAbsoluteFile</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A> <B>getAbsoluteFile</B>()</PRE>
<DL>
<DD>返回此抽象路径名的绝对路径名形式。等同于 <code>new&nbsp;File(this.<A HREF="../../java/io/File.html#getAbsolutePath()"><CODE>getAbsolutePath()</CODE></A>)</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>绝对抽象路径名，它与此抽象路径名表示相同的文件或目录
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果无法访问所需的系统属性值。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCanonicalPath()"><!-- --></A><H3>
getCanonicalPath</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getCanonicalPath</B>()
                        throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>返回此抽象路径名的规范路径名字符串。

<p> 规范路径名是绝对路径名，并且是惟一的。规范路径名的准确定义与系统有关。如有必要，此方法首先将路径名转换为绝对路径名，这与调用 <A HREF="../../java/io/File.html#getAbsolutePath()"><CODE>getAbsolutePath()</CODE></A> 方法的效果一样，然后用与系统相关的方式将它映射到其惟一路径名。这通常涉及到从路径名中移除多余的名称（比如 <tt>&quot;.&quot;</tt> 和 <tt>&quot;..&quot;</tt>）、解析符号连接（对于 UNIX 平台），以及将驱动器号转换为标准大小写形式（对于 Microsoft Windows 平台）。

<p> 每个表示现存文件或目录的路径名都有一个惟一的规范形式。每个表示不存在文件或目录的路径名也有一个惟一的规范形式。不存在文件或目录路径名的规范形式可能不同于创建文件或目录之后同一路径名的规范形式。同样，现存文件或目录路径名的规范形式可能不同于删除文件或目录之后同一路径名的规范形式。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>规范路径名字符串，它与此抽象路径名表示相同的文件或目录
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误（可能是因为构造规范路径名需要进行文件系统查询）
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果无法访问所需的系统属性值，或者存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.io.FileDescriptor)"><CODE>SecurityManager.checkRead(java.io.FileDescriptor)</CODE></A></code> 方法拒绝对文件进行读访问<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCanonicalFile()"><!-- --></A><H3>
getCanonicalFile</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A> <B>getCanonicalFile</B>()
                      throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>返回此抽象路径名的规范形式。等同于 <code>new&nbsp;File(this.<A HREF="../../java/io/File.html#getCanonicalPath()"><CODE>getCanonicalPath()</CODE></A>)</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>规范路径名字符串，它与此抽象路径名表示相同的文件或目录
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误（可能是因为构造规范路径名需要进行文件系统查询）
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果无法访问所需的系统属性值，或者存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.io.FileDescriptor)"><CODE>SecurityManager.checkRead(java.io.FileDescriptor)</CODE></A></code> 方法拒绝对文件进行读访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toURL()"><!-- --></A><H3>
toURL</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public <A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A> <B>toURL</B>()
          throws <A HREF="../../java/net/MalformedURLException.html" title="java.net 中的类">MalformedURLException</A></PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 <A HREF="../../java/io/File.html#toURI()"><CODE>toURI</CODE></A> 方法将其转换为 URI，然后通过 <A HREF="../../java/net/URI.html#toURL()"><CODE>URI.toURL</CODE></A> 方法将 URI 装换为 URL。</I>
<P>
<DD>将此抽象路径名转换为一个 <code>file:</code> URL。该 URL 的具体形式与系统有关。如果可以确定此抽象路径名表示的文件是一个目录，那么所得 URL 将以斜杠结束。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示等价文件 URL 的 URL 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/net/MalformedURLException.html" title="java.net 中的类">MalformedURLException</A></CODE> - 如果无法将路径解析为 URL<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#toURI()"><CODE>toURI()</CODE></A>, 
<A HREF="../../java/net/URI.html" title="java.net 中的类"><CODE>URI</CODE></A>, 
<A HREF="../../java/net/URI.html#toURL()"><CODE>URI.toURL()</CODE></A>, 
<A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE>URL</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="toURI()"><!-- --></A><H3>
toURI</H3>
<PRE>
public <A HREF="../../java/net/URI.html" title="java.net 中的类">URI</A> <B>toURI</B>()</PRE>
<DL>
<DD>构造一个表示此抽象路径名的 <tt>file:</tt> URI。 

<p> 该 URI 的具体形式与系统有关。如果可以确定此抽象路径名表示的文件是一个目录，那么所得 URI 将以斜杠结束。

<p> 对于某个给定抽象路径名 <i>f</i>，可保证：

<blockquote><tt>new <A HREF="../../java/io/File.html#File(java.net.URI)"><CODE>File</CODE></A>(</tt><i>&nbsp;f</i><tt>.toURI()).equals(</tt><i>&nbsp;f</i><tt>.<A HREF="../../java/io/File.html#getAbsoluteFile()"><CODE>getAbsoluteFile</CODE></A>())</tt></blockquote>

只要原始抽象路径名、URI 和新抽象路径名都是在同一 Java 虚拟机（或者它的不同调用）中创建的。但是，由于抽象路径名与系统有关的特性，当在某一操作系统上的虚拟机中创建的 <tt>file:</tt> URI 在不同操作系统上的虚拟机中被转换为抽象路径名时，这种关系通常是不成立的。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>一个绝对分层 URI，由一个等于 <tt>&quot;file&quot;</tt> 的 scheme、表示此抽象路径名的 path，以及未定义的 authority、query 和 fragment 组件组成
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果不能访问请求的系统属性值。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#File(java.net.URI)"><CODE>File(java.net.URI)</CODE></A>, 
<A HREF="../../java/net/URI.html" title="java.net 中的类"><CODE>URI</CODE></A>, 
<A HREF="../../java/net/URI.html#toURL()"><CODE>URI.toURL()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="canRead()"><!-- --></A><H3>
canRead</H3>
<PRE>
public boolean <B>canRead</B>()</PRE>
<DL>
<DD>测试应用程序是否可以读取此抽象路径名表示的文件。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此抽象路径名指定的文件存在<em>且</em> 可被应用程序读取时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读访问</DL>
</DD>
</DL>
<HR>

<A NAME="canWrite()"><!-- --></A><H3>
canWrite</H3>
<PRE>
public boolean <B>canWrite</B>()</PRE>
<DL>
<DD>测试应用程序是否可以修改此抽象路径名表示的文件。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当文件系统实际包含此抽象路径名表示的文件<em>且</em> 允许应用程序对该文件进行写入时，返回 <code>true</code>；否则返回 <code>false</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对文件进行写访问</DL>
</DD>
</DL>
<HR>

<A NAME="exists()"><!-- --></A><H3>
exists</H3>
<PRE>
public boolean <B>exists</B>()</PRE>
<DL>
<DD>测试此抽象路径名表示的文件或目录是否存在。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此抽象路径名表示的文件或目录存在时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件或目录进行写访问</DL>
</DD>
</DL>
<HR>

<A NAME="isDirectory()"><!-- --></A><H3>
isDirectory</H3>
<PRE>
public boolean <B>isDirectory</B>()</PRE>
<DL>
<DD>测试此抽象路径名表示的文件是否是一个目录。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此抽象路径名表示的文件存在<em>且</em> 是一个目录时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读访问</DL>
</DD>
</DL>
<HR>

<A NAME="isFile()"><!-- --></A><H3>
isFile</H3>
<PRE>
public boolean <B>isFile</B>()</PRE>
<DL>
<DD>测试此抽象路径名表示的文件是否是一个标准文件。如果该文件不是一个目录，并且满足其他与系统有关的标准，那么该文件是<em>标准</em> 文件。由 Java 应用程序创建的所有非目录文件一定是标准文件。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此抽象路径名表示的文件存在<em>且</em> 是一个标准文件时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读访问</DL>
</DD>
</DL>
<HR>

<A NAME="isHidden()"><!-- --></A><H3>
isHidden</H3>
<PRE>
public boolean <B>isHidden</B>()</PRE>
<DL>
<DD>测试此抽象路径名指定的文件是否是一个隐藏文件。<em>隐藏</em> 的具体定义与系统有关。在 UNIX 系统上，如果文件名以句点字符 (<code>'.'</code>) 开头，则认为该文件被隐藏。在 Microsoft Windows 系统上，如果在文件系统中文件被标记为隐藏，则认为该文件被隐藏。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此抽象路径名表示的文件根据底层平台约定是隐藏文件时，返回 <code>true</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lastModified()"><!-- --></A><H3>
lastModified</H3>
<PRE>
public long <B>lastModified</B>()</PRE>
<DL>
<DD>返回此抽象路径名表示的文件最后一次被修改的时间。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示文件最后一次被修改的时间的 <code>long</code> 值，用与时间点（1970 年 1 月 1 日，00:00:00 GMT）之间的毫秒数表示；如果该文件不存在，或者发生 I/O 错误，则返回 <code>0L</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读访问</DL>
</DD>
</DL>
<HR>

<A NAME="length()"><!-- --></A><H3>
length</H3>
<PRE>
public long <B>length</B>()</PRE>
<DL>
<DD>返回由此抽象路径名表示的文件的长度。如果此路径名表示一个目录，则返回值是不确定的。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名表示的文件的长度，以字节为单位；如果文件不存在，则返回 <code>0L</code>。对于表示特定于系统的实体（比如设备或管道）的路径名，某些操作系统可能返回 <code>0L</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对文件进行读访问</DL>
</DD>
</DL>
<HR>

<A NAME="createNewFile()"><!-- --></A><H3>
createNewFile</H3>
<PRE>
public boolean <B>createNewFile</B>()
                      throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。检查文件是否存在，若不存在则创建该文件，这是单个操作，对于其他所有可能影响该文件的文件系统活动来说，该操作是不可分的。
 <P>
注：此方法<i>不应该</i> 用于文件锁定，因为所得协议可能无法可靠地工作。应该使用 <A HREF="../../java/nio/channels/FileLock.html" title="java.nio.channels 中的类"><CODE>FileLock</CODE></A> 机制替代。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果指定的文件不存在并成功地创建，则返回 <code>true</code>；如果指定的文件已经存在，则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对文件进行写访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete()"><!-- --></A><H3>
delete</H3>
<PRE>
public boolean <B>delete</B>()</PRE>
<DL>
<DD>删除此抽象路径名表示的文件或目录。如果此路径名表示一个目录，则该目录必须为空才能删除。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当成功删除文件或目录时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkDelete(java.lang.String)"><CODE>SecurityManager.checkDelete(java.lang.String)</CODE></A></code> 方法拒绝对文件进行删除访问</DL>
</DD>
</DL>
<HR>

<A NAME="deleteOnExit()"><!-- --></A><H3>
deleteOnExit</H3>
<PRE>
public void <B>deleteOnExit</B>()</PRE>
<DL>
<DD>在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。  文件（或目录）将以与注册相反的顺序删除。调用此方法删除已注册为删除的文件或目录无效。根据 Java 语言规范中的定义，只有在虚拟机正常终止时，才会尝试执行删除操作。 

<p> 一旦请求了删除操作，就无法取消该请求。所以应小心使用此方法。

 <P>
注：此方法<i>不应该</i> 用于文件锁定，因为所得协议可能无法可靠地工作。应该使用 <A HREF="../../java/nio/channels/FileLock.html" title="java.nio.channels 中的类"><CODE>FileLock</CODE></A> 设施替代。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkDelete(java.lang.String)"><CODE>SecurityManager.checkDelete(java.lang.String)</CODE></A></code> 方法拒绝对文件进行删除访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/File.html#delete()"><CODE>delete()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="list()"><!-- --></A><H3>
list</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[] <B>list</B>()</PRE>
<DL>
<DD>返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。

<p> 如果此抽象路径名不表示一个目录，那么此方法将返回 <code>null</code>。否则返回一个字符串数组，每个数组元素对应目录中的每个文件或目录。表示目录本身及其父目录的名称不包括在结果中。每个字符串是一个文件名，而不是一条完整路径。

<p> 不保证所得数组中的相同字符串将以特定顺序出现，特别是不保证它们按字母顺序出现。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。如果目录为空，那么数组也将为空。如果此抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 <code>null</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对目录进行读访问</DL>
</DD>
</DL>
<HR>

<A NAME="list(java.io.FilenameFilter)"><!-- --></A><H3>
list</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[] <B>list</B>(<A HREF="../../java/io/FilenameFilter.html" title="java.io 中的接口">FilenameFilter</A>&nbsp;filter)</PRE>
<DL>
<DD>返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。除了返回数组中的字符串必须满足过滤器外，此方法的行为与 <code><A HREF="../../java/io/File.html#list()"><CODE>list()</CODE></A></code> 方法相同。如果给定 <code>filter</code> 为 <code>null</code>，则接受所有名称。否则，当且仅当在此抽象路径名及其表示的目录中的文件名或目录名上调用过滤器的 <code><A HREF="../../java/io/FilenameFilter.html#accept(java.io.File, java.lang.String)"><CODE>FilenameFilter.accept(java.io.File, java.lang.String)</CODE></A></code> 方法返回 <code>true</code> 时，该名称才满足过滤器。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>filter</CODE> - 文件名过滤器
<DT><B>返回：</B><DD>字符串数组，这些字符串指定此抽象路径名表示的目录中给定 <code>filter</code> 能接受的文件和目录。如果目录为空，或者没有名称被过滤器接受，那么该数组将为空。如果抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 <code>null</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对目录进行读访问</DL>
</DD>
</DL>
<HR>

<A NAME="listFiles()"><!-- --></A><H3>
listFiles</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[] <B>listFiles</B>()</PRE>
<DL>
<DD>返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。

<p> 如果此抽象路径名不表示一个目录，那么此方法将返回 <code>null</code>。否则返回一个 <code>File</code> 对象数组，每个数组元素对应目录中的每个文件或目录。表示目录本身及其父目录的名称不包括在结果中。得到的每个抽象路径名都是根据此抽象路径名，使用 <code><A HREF="../../java/io/File.html#File(java.io.File, java.lang.String)"><CODE>File(File,&nbsp;String)</CODE></A></code> 构造方法构造的。所以，如果此路径名是绝对路径名，那么得到的每个路径名都是绝对路径名；如果此路径名是相对路径名，那么得到的每个路径名都是相对于同一目录的路径名。

<p> 不保证所得数组中的相同字符串将以特定顺序出现，特别是不保证它们按字母顺序出现。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件和目录。如果目录为空，那么数组也将为空。如果抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 <code>null</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对目录进行读访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="listFiles(java.io.FilenameFilter)"><!-- --></A><H3>
listFiles</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[] <B>listFiles</B>(<A HREF="../../java/io/FilenameFilter.html" title="java.io 中的接口">FilenameFilter</A>&nbsp;filter)</PRE>
<DL>
<DD>返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。除了返回数组中的路径名必须满足过滤器外，此方法的行为与 <code><A HREF="../../java/io/File.html#listFiles()"><CODE>listFiles()</CODE></A></code> 方法相同。如果给定 <code>filter</code> 为 <code>null</code>，则接受所有路径名。否则，当且仅当在此抽象路径名及其表示的目录中的文件名或目录名上调用过滤器的 <code><A HREF="../../java/io/FilenameFilter.html#accept(java.io.File, java.lang.String)"><CODE>FilenameFilter.accept(java.io.File, java.lang.String)</CODE></A></code> 方法返回 <code>true</code> 时，该路径名才满足过滤器。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>filter</CODE> - 文件名过滤器
<DT><B>返回：</B><DD>抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件和目录。如果目录为空，那么数组也将为空。如果此抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 <code>null</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对目录进行读访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="listFiles(java.io.FileFilter)"><!-- --></A><H3>
listFiles</H3>
<PRE>
public <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[] <B>listFiles</B>(<A HREF="../../java/io/FileFilter.html" title="java.io 中的接口">FileFilter</A>&nbsp;filter)</PRE>
<DL>
<DD>返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。除了返回数组中的路径名必须满足过滤器外，此方法的行为与 <code><A HREF="../../java/io/File.html#listFiles()"><CODE>listFiles()</CODE></A></code> 方法相同。如果给定 <code>filter</code> 为 <code>null</code>，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的 <code><A HREF="../../java/io/FileFilter.html#accept(java.io.File)"><CODE>FileFilter.accept(java.io.File)</CODE></A></code> 方法返回 <code>true</code> 时，该路径名才满足过滤器。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>filter</CODE> - 文件过滤器
<DT><B>返回：</B><DD>抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件和目录。如果目录为空，那么数组也将为空。如果抽象路径名不表示一个目录，或者发生 I/O 错误，则返回 <code>null</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对目录进行读访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="mkdir()"><!-- --></A><H3>
mkdir</H3>
<PRE>
public boolean <B>mkdir</B>()</PRE>
<DL>
<DD>创建此抽象路径名指定的目录。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当已创建目录时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法不允许创建指定的目录</DL>
</DD>
</DL>
<HR>

<A NAME="mkdirs()"><!-- --></A><H3>
mkdirs</H3>
<PRE>
public boolean <B>mkdirs</B>()</PRE>
<DL>
<DD>创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。注意，此操作失败时也可能已经成功地创建了一部分必需的父目录。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当已创建目录以及所有必需的父目录时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法不允许验证指定目录和所有必需的父目录是否存在；或者 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法不允许创建指定的目录和所有必需的父目录</DL>
</DD>
</DL>
<HR>

<A NAME="renameTo(java.io.File)"><!-- --></A><H3>
renameTo</H3>
<PRE>
public boolean <B>renameTo</B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;dest)</PRE>
<DL>
<DD>重新命名此抽象路径名表示的文件。
 
<p> 此方法行为的许多方面都是与平台有关的：重命名操作无法将一个文件从一个文件系统移动到另一个文件系统，该操作不是不可分的，如果已经存在具有目标抽象路径名的文件，那么该操作可能无法获得成功。应该始终检查返回值，以确保重命名操作成功。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>dest</CODE> - 指定文件的新抽象路径名
<DT><B>返回：</B><DD>当且仅当重命名成功时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对原路径名和新路径名进行写访问
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果参数 <code>dest</code> 为 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="setLastModified(long)"><!-- --></A><H3>
setLastModified</H3>
<PRE>
public boolean <B>setLastModified</B>(long&nbsp;time)</PRE>
<DL>
<DD>设置此抽象路径名指定的文件或目录的最后一次修改时间。

<p> 所有平台都支持将文件修改时间设置为最接近的秒数，而且一些平台会提供更精确的值。该参数将被截取，以满足受支持的精度。如果该操作成功，并且没有在文件上发生其他干扰操作，则下一次调用 <code><A HREF="../../java/io/File.html#lastModified()"><CODE>lastModified()</CODE></A></code> 方法将返回传递给此方法的 <code>time</code> 参数（可能被截取）。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>time</CODE> - 新的最后一次修改时间，用与时间点（1970 年 1 月 1 日，00:00:00 GMT）之间的毫秒数表示
<DT><B>返回：</B><DD>当且仅当该操作成功时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果该参数为负
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对指定文件进行写访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setReadOnly()"><!-- --></A><H3>
setReadOnly</H3>
<PRE>
public boolean <B>setReadOnly</B>()</PRE>
<DL>
<DD>标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。调用此方法后，可以保证在被删除或被标记为允许写访问之前，文件或目录不会发生更改。是否可以删除某个只读文件或目录则取决于底层系统。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当该操作成功时，返回 <code>true</code>；否则返回 <code>false</code>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对指定文件进行写访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setWritable(boolean, boolean)"><!-- --></A><H3>
setWritable</H3>
<PRE>
public boolean <B>setWritable</B>(boolean&nbsp;writable,
                           boolean&nbsp;ownerOnly)</PRE>
<DL>
<DD>设置此抽象路径名的所有者或所有用户的写权限。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>writable</CODE> - 如果为 <code>true</code>，则设置允许写操作的访问权限；如果为 <code>false</code>，则不允许写操作。<DD><CODE>ownerOnly</CODE> - 如果为 <code>true</code>，则写权限只适用于所有者的写权限；否则适用于所有用户。如果底层文件系统不能区分所有者写权限与其他写权限，那么无论该参数为何值，写权限将适用于所有用户。
<DT><B>返回：</B><DD>当且仅当操作成功时返回 <code>true</code>。如果用户不具有更改此抽象路径名访问权限的权限，那么操作将失败。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对指定文件进行写访问。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setWritable(boolean)"><!-- --></A><H3>
setWritable</H3>
<PRE>
public boolean <B>setWritable</B>(boolean&nbsp;writable)</PRE>
<DL>
<DD>设置此抽象路径名所有者写权限的一个便捷方法。

 <p> 此方法 <tt>file.setWritable(arg)</tt> 形式的调用与以下调用的行为完全相同：

 <pre>
     file.setWritable(arg, true) </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>writable</CODE> - 如果为 <code>true</code>，则设置允许写操作的访问权限；如果为 <code>false</code>，则不允许写操作。
<DT><B>返回：</B><DD>当且仅当操作成功时返回 <code>true</code>。如果用户不具有更改此抽象路径名访问权限的权限，那么操作将失败。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对文件进行写访问。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setReadable(boolean, boolean)"><!-- --></A><H3>
setReadable</H3>
<PRE>
public boolean <B>setReadable</B>(boolean&nbsp;readable,
                           boolean&nbsp;ownerOnly)</PRE>
<DL>
<DD>设置此抽象路径名的所有者或所有用户的读权限。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>readable</CODE> - 如果为 <code>true</code>，则设置允许读操作的访问权限；如果为 <code>false</code>，则不允许读操作。<DD><CODE>ownerOnly</CODE> - 如果为 <code>true</code>，则读权限只适用于所有者的读权限；否则适用于所有用户。如果底层文件系统不能区分所有者读权限与其他读权限，那么无论该参数为何值，读权限将适用于所有用户。
<DT><B>返回：</B><DD>当且仅当操作成功时返回 <code>true</code>。如果用户不具有更改此抽象路径名访问权限的权限，那么操作将失败。如果 <code>readable</code> 为 <code>false</code>，并且底层文件系统不实现读权限，那么操作也将失败。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对文件进行写访问。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setReadable(boolean)"><!-- --></A><H3>
setReadable</H3>
<PRE>
public boolean <B>setReadable</B>(boolean&nbsp;readable)</PRE>
<DL>
<DD>设置此抽象路径名所有者读权限的一个便捷方法。

 <p>此方法 <tt>file.setReadable(arg)</tt> 形式的调用与以下调用的行为完全相同：

 <pre>
     file.setReadable(arg, true) </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>readable</CODE> - 如果为 <code>true</code>，则设置允许读操作的访问权限；如果为 <code>false</code>，则不允许读操作。
<DT><B>返回：</B><DD>当且仅当操作成功时返回 <code>true</code>。如果用户不具有更改此抽象路径名访问权限的权限，那么操作将失败。如果 <code>readable</code> 为 <code>false</code>，并且底层文件系统不实现读权限，那么操作也将失败。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对文件进行写访问。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExecutable(boolean, boolean)"><!-- --></A><H3>
setExecutable</H3>
<PRE>
public boolean <B>setExecutable</B>(boolean&nbsp;executable,
                             boolean&nbsp;ownerOnly)</PRE>
<DL>
<DD>设置此抽象路径名的所有者或所有用户的执行权限。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>executable</CODE> - 如果为 <code>true</code>，则设置允许执行操作的访问权限；如果为 <code>false</code>，则不允许执行操作。<DD><CODE>ownerOnly</CODE> - 如果为 <code>true</code>，则执行权限只适用于所有者的执行权限；否则适用于所有用户。如果底层文件系统不能区分所有者执行权限与其他执行权限，那么无论该参数为何值，执行权限将适用于所有用户。
<DT><B>返回：</B><DD>当且仅当操作成功时返回 <code>true</code>。如果用户不具有更改此抽象路径名访问权限的权限，那么操作将失败。如果 <code>executable</code> 为 <code>false</code>，并且底层文件系统不实现执行权限，那么操作也将失败。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对文件进行写访问。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setExecutable(boolean)"><!-- --></A><H3>
setExecutable</H3>
<PRE>
public boolean <B>setExecutable</B>(boolean&nbsp;executable)</PRE>
<DL>
<DD>设置此抽象路径名所有者执行权限的一个便捷方法。

 <p>此方法 <tt>file.setExcutable(arg)</tt> 形式的调用与以下调用的行为完全相同：

 <pre>
     file.setExecutable(arg, true) </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>executable</CODE> - 如果为 <code>true</code>，则设置允许执行操作的访问权限；如果为 <code>false</code>，则不允许执行操作。
<DT><B>返回：</B><DD>当且仅当操作成功时返回 <code>true</code>。如果用户不具有更改此抽象路径名访问权限的权限，那么操作将失败。如果 <code>executable</code> 为 <code>false</code>，并且底层文件系统不实现执行权限，那么操作也将失败。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法拒绝对文件进行写访问。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="canExecute()"><!-- --></A><H3>
canExecute</H3>
<PRE>
public boolean <B>canExecute</B>()</PRE>
<DL>
<DD>测试应用程序是否可以执行此抽象路径名表示的文件。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当抽象路径名存在<em>且</em> 允许应用程序执行文件时返回 <code>true</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在且其 <code><A HREF="../../java/lang/SecurityManager.html#checkExec(java.lang.String)"><CODE>SecurityManager.checkExec(java.lang.String)</CODE></A></code> 方法拒绝对文件进行执行访问。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="listRoots()"><!-- --></A><H3>
listRoots</H3>
<PRE>
public static <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>[] <B>listRoots</B>()</PRE>
<DL>
<DD>列出可用的文件系统根。

<p> 特定 Java 平台可以支持零个或更多个分层组织的文件系统。每个文件系统有一个 <code>root</code> 目录，可以从这里到达文件系统中的所有其他文件。例如，Windows 平台为每个活动驱动器提供了一个根目录；UNIX 平台只有一个根目录，即 <code>&quot;/&quot;</code>。可用文件系统根的设置受各种系统级操作的影响，比如可移动介质的插入和弹出，以及断开或卸载那些物理磁盘或虚拟磁盘。

<p> 此方法返回一个 <code>File</code> 对象数组，这些对象表示可用文件系统根的根目录。可以保证本地机器上物理存在的任何文件的规范路径名都以此方法返回的根之一开始。

<p> 位于其他一些机器上的文件的规范路径名是通过远程文件系统协议（比如 SMB 或 NFS）访问的，它们可能以此方法返回的根之一开始，也可能不是这样。如果远程文件的路径名在语法上无法与本地文件的路径名进行区分，那么它将以此方法返回的根之一开始。例如，此方法将返回表示 Windows 平台上映射为网络驱动器根目录的 <code>File</code> 对象，而不返回包含 UNC 路径名的 <code>File</code> 对象。

<p> 与此类中的大多数方法不同，此方法不抛出安全性异常。如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(java.lang.String)</CODE></A></code> 方法拒绝对特定根目录进行读访问，那么该目录将不会出现在结果中。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示可用文件系统根的 <code>File</code> 对象数组；如果无法确定根集，则返回 <code>null</code>。如果没有文件系统，那么该数组将为空。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTotalSpace()"><!-- --></A><H3>
getTotalSpace</H3>
<PRE>
public long <B>getTotalSpace</B>()</PRE>
<DL>
<DD>返回此抽象路径名<a href="#partName">指定的</a>分区大小。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>分区的大小，以字节为单位；如果此抽象路径名没有指定分区，则返回 <tt>0L</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安装了安全管理器，并且安全管理器拒绝 <A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A><tt>("getFileSystemAttributes")</tt>，或者其 <A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(String)</CODE></A> 方法拒绝对此抽象路径名指定的文件进行读访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getFreeSpace()"><!-- --></A><H3>
getFreeSpace</H3>
<PRE>
public long <B>getFreeSpace</B>()</PRE>
<DL>
<DD>返回此抽象路径名<a href="#partName">指定的</a>分区中未分配的字节数。

 <p> 返回的未分配字节数是一个提示，而不是一个保证，只能使用这些字节的一部分。未分配字节数很可能在此调用后立即与实际相符。某些外部 I/O 操作可能使其与实际不符，这些操作包括那些在此虚拟机外部系统上进行的操作。此方法不保证对此文件系统的写操作将成功。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>分区上的未分配字节数；如果抽象路径名没有指定分区，则返回 <tt>0L</tt>。返回值将小于等于 <A HREF="../../java/io/File.html#getTotalSpace()"><CODE>getTotalSpace()</CODE></A> 返回的总文件系统大小。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安装了安全管理器，并且安全管理器拒绝 <A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A><tt>("getFileSystemAttributes")</tt>，或者其 <A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(String)</CODE></A> 方法拒绝对此抽象路径名指定的文件进行读访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUsableSpace()"><!-- --></A><H3>
getUsableSpace</H3>
<PRE>
public long <B>getUsableSpace</B>()</PRE>
<DL>
<DD>返回此抽象路径名<a href="#partName">指定的</a>分区上可用于此虚拟机的字节数。若有可能，此方法将检查写权限和其他操作系统限制，因此与 <A HREF="../../java/io/File.html#getFreeSpace()"><CODE>getFreeSpace()</CODE></A> 相比，此方法能更准确地估计可实际写入的新数据数。

 <p> 返回的可用字节数是一个提示，而不是一个保证，只能使用这些字节的一部分。未分配字节数很可能在此调用后立即与实际相符。某些外部 I/O 操作可能使其与实际不符，这些操作包括那些在此虚拟机外部系统上进行的操作。此方法不保证对此文件系统的写操作将成功。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>分区上的可用字节数；如果抽象路径名没有指定分区，则返回 <tt>0L</tt>。在此信息不可用的系统上，此方法等效于调用 <A HREF="../../java/io/File.html#getFreeSpace()"><CODE>getFreeSpace()</CODE></A>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安装了安全管理器，并且安全管理器拒绝 <A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A><tt>("getFileSystemAttributes")</tt>，或者其 <A HREF="../../java/lang/SecurityManager.html#checkRead(java.lang.String)"><CODE>SecurityManager.checkRead(String)</CODE></A> 方法拒绝对此抽象路径名指定的文件进行读访问<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createTempFile(java.lang.String, java.lang.String, java.io.File)"><!-- --></A><H3>
createTempFile</H3>
<PRE>
public static <A HREF="../../java/io/File.html" title="java.io 中的类">File</A> <B>createTempFile</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;prefix,
                                  <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;suffix,
                                  <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;directory)
                           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD><p> 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。如果此方法成功返回，则可以保证：

 <ol>
<li> 由返回的抽象路径名表示的文件在此方法被调用之前不存在。
<li> 此方法及其所有变体都不会在虚拟机的当前调用中再次返回相同的抽象路径名。
 </ol>

此方法只提供了临时文件的部分功能。要安排自动删除此方法创建的文件，可使用 <code><A HREF="../../java/io/File.html#deleteOnExit()"><CODE>deleteOnExit()</CODE></A></code> 方法。

<p> <code>prefix</code> 参数至少必须是三个字节长。建议前缀使用一个短的、有意义的字符串，比如 <code>&quot;hjb&quot;</code> 或 <code>&quot;mail&quot;</code>。<code>suffix</code> 参数可以为 <code>null</code>，在这种情况下，将使用后缀 <code>&quot;.tmp&quot;</code>。

<p> 要创建新文件，可能首先要调整前缀和后缀，使其满足底层平台的限制。如果前缀太长，则将它截断，但前三个字符将始终保留。如果后缀太长，则将它截断，但如果它以句点字符 (<code>'.'</code>) 开始，则该句点以及后跟的前三个字符将始终保留。进行了这些调整后，通过连接前缀、五个或更多个内部生成的字符以及后缀，便生成了新文件的名称。

<p> 如果 <code>directory</code> 参数为 <code>null</code>，则使用与系统有关的默认临时文件目录。默认临时文件目录由系统属性 <code>java.io.tmpdir</code> 指定。在 UNIX 系统上，此属性的默认值通常是 <code>&quot;/tmp&quot;</code> 或 <code>&quot;/var/tmp&quot;</code>；在 Microsoft Windows 系统上，该值通常是 <code>&quot;C:\\WINNT\\TEMP&quot;</code>。在调用 Java 虚拟机时，可为此系统属性提供不同的值，但不保证使用程序更改此属性会对此方法使用的临时目录产生影响。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>prefix</CODE> - 用于生成文件名的前缀字符串；必须至少是三字符长<DD><CODE>suffix</CODE> - 用于生成文件名的后缀字符串；可以为 <code>null</code>，在这种情况下，将使用后缀 <code>&quot;.tmp&quot;</code><DD><CODE>directory</CODE> - 将创建的文件所在的目录；如果使用默认临时文件目录，则该参数为 <code>null</code>
<DT><B>返回：</B><DD>表示新建空文件的抽象路径名
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>prefix</code> 参数包含的字符少于三个
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果无法创建文件
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法不允许创建文件<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createTempFile(java.lang.String, java.lang.String)"><!-- --></A><H3>
createTempFile</H3>
<PRE>
public static <A HREF="../../java/io/File.html" title="java.io 中的类">File</A> <B>createTempFile</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;prefix,
                                  <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;suffix)
                           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。调用此方法等同于调用 <code><A HREF="../../java/io/File.html#createTempFile(java.lang.String, java.lang.String, java.io.File)"><CODE>createTempFile(prefix,&nbsp;suffix,&nbsp;null)</CODE></A></code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>prefix</CODE> - 用于生成文件名的前缀字符串；必须至少是三字符长<DD><CODE>suffix</CODE> - 用于生成文件名的后缀字符串；可以为 <code>null</code>，在这种情况下，将使用后缀 <code>&quot;.tmp&quot;</code>
<DT><B>返回：</B><DD>表示新建空文件的抽象路径名
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>prefix</code> 参数包含的字符少于三个
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果无法创建文件
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，且其 <code><A HREF="../../java/lang/SecurityManager.html#checkWrite(java.lang.String)"><CODE>SecurityManager.checkWrite(java.lang.String)</CODE></A></code> 方法不允许创建文件<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="compareTo(java.io.File)"><!-- --></A><H3>
compareTo</H3>
<PRE>
public int <B>compareTo</B>(<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;pathname)</PRE>
<DL>
<DD>按字母顺序比较两个抽象路径名。此方法定义的顺序取决于底层系统。在 UNIX 系统上，比较路径名时，字母大小写通常很重要，而在 Microsoft Windows 系统上，这通常不重要。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/lang/Comparable.html" title="java.lang 中的接口">Comparable</A>&lt;<A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&gt;</CODE> 中的 <CODE><A HREF="../../java/lang/Comparable.html#compareTo(T)">compareTo</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>pathname</CODE> - 将与此抽象路径名进行比较的抽象路径名
<DT><B>返回：</B><DD>如果该参数等于此抽象路径名，则返回零；如果此抽象路径名在字母顺序上小于该参数，则返回小于零的值；如果此抽象路径名在字母顺序上大于该参数，则返回大于零的值<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</PRE>
<DL>
<DD>测试此抽象路径名与给定对象是否相等。当且仅当该参数不是 <code>null</code>，而是一个与此抽象路径名表示相同的文件或目录的抽象路径名时，返回 <code>true</code>。两个抽象路径名是否相等取决于底层系统。在 UNIX 系统上，比较路径名时，字母大小写通常很重要，而在 Microsoft Windows 系统上，这通常不重要。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 要与此抽象路径名进行比较的对象
<DT><B>返回：</B><DD>当且仅当对象相同时，返回 <code>true</code>；否则返回 <code>false</code><DT><B>另请参见：</B><DD><A HREF="../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A>, 
<A HREF="../../java/util/Hashtable.html" title="java.util 中的类"><CODE>Hashtable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>计算此抽象路径名的哈希码。因为抽象路径名的相等性与系统有关，所以对其哈希码的计算也与系统有关。在 UNIX 系统上，抽象路径名的哈希码等于其路径名字符串和十进制值 <code>1234321</code> 的哈希码的<em>异或</em>。在 Microsoft Windows 系统上，哈希码等于其转换为小写的路径名字符串和十进制值 <code>1234321</code> 的哈希码的<em>异或</em>。在将路径名字符串转换为小写时不考虑语言环境。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../java/lang/Object.html#hashCode()">hashCode</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名的哈希码<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A>, 
<A HREF="../../java/util/Hashtable.html" title="java.util 中的类"><CODE>Hashtable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>()</PRE>
<DL>
<DD>返回此抽象路径名的路径名字符串。该字符串就是 <code><A HREF="../../java/io/File.html#getPath()"><CODE>getPath()</CODE></A></code> 方法返回的字符串。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此抽象路径名的字符串形式</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/File.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/Externalizable.html" title="java.io 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/io/FileDescriptor.html" title="java.io 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/io/File.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="File.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
