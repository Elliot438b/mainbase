<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 12:47:49 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
ObjectOutputStream (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ObjectOutputStream (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectOutputStream.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/ObjectOutput.html" title="java.io 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/io/ObjectOutputStream.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="ObjectOutputStream.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.io</FONT>
<BR>
类 ObjectOutputStream</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><A HREF="../../java/io/OutputStream.html" title="java.io 中的类">java.io.OutputStream</A>
      <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.io.ObjectOutputStream</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../java/io/Closeable.html" title="java.io 中的接口">Closeable</A>, <A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A>, <A HREF="../../java/io/Flushable.html" title="java.io 中的接口">Flushable</A>, <A HREF="../../java/io/ObjectOutput.html" title="java.io 中的接口">ObjectOutput</A>, <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 中的接口">ObjectStreamConstants</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ObjectOutputStream</B><DT>extends <A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A><DT>implements <A HREF="../../java/io/ObjectOutput.html" title="java.io 中的接口">ObjectOutput</A>, <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 中的接口">ObjectStreamConstants</A></DL>
</PRE>

<P>
ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。

<p>只能将支持 java.io.Serializable 接口的对象写入流中。每个 serializable 对象的类都被编码，编码内容包括类名和类签名、对象的字段值和数组值，以及从初始对象中引用的其他所有对象的闭包。

<p>writeObject 方法用于将对象写入流中。所有对象（包括 String 和数组）都可以通过 writeObject 写入。可将多个对象或基元写入流中。必须使用与写入对象时相同的类型和顺序从相应 ObjectInputstream 中读回对象。

<p>还可以使用 DataOutput 中的适当方法将基本数据类型写入流中。还可以使用 writeUTF 方法写入字符串。

<p>对象的默认序列化机制写入的内容是：对象的类，类签名，以及非瞬态和非静态字段的值。其他对象的引用（瞬态和静态字段除外）也会导致写入那些对象。可使用引用共享机制对单个对象的多个引用进行编码，这样即可将对象的图形恢复为最初写入它们时的形状。

<p>例如，要写入可通过 ObjectInputStream 中的示例读取的对象，请执行以下操作： <br>
 <pre>
        FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;);
        ObjectOutputStream oos = new ObjectOutputStream(fos);

        oos.writeInt(12345);
        oos.writeObject(&quot;Today&quot;);
        oos.writeObject(new Date());

        oos.close();
 </pre>

<p>在序列化和反序列化过程中需要特殊处理的类必须实现具有下列准确签名的特殊方法：<br>
 <pre>
 private void readObject(java.io.ObjectInputStream stream)
     throws IOException, ClassNotFoundException;
 private void writeObject(java.io.ObjectOutputStream stream)
     throws IOException
 private void readObjectNoData() 
     throws ObjectStreamException;
 </pre>
 
<p>writeObject 方法负责写入特定类的对象状态，以便相应的 readObject 方法可以恢复它。该方法本身不必与属于对象的超类或子类的状态有关。状态是通过使用 writeObject 方法或使用 DataOutput 支持的用于基本数据类型的方法将各个字段写入 ObjectOutputStream 来保存的。

<p>序列化操作不写出没有实现 java.io.Serializable 接口的任何对象的字段。不可序列化的 Object 的子类可以是可序列化的。在此情况下，不可序列化的类必须有一个无参数构造方法，以便允许初始化其字段。在此情况下，子类负责保存和恢复不可序列化的类的状态。经常出现的情况是，该类的字段是可访问的（public、package 或 protected），或者存在可用来恢复状态的 get 和 set 方法。

<p>在 writeObject 和 readObject 方法的实现中抛出 NotSerializableException，可以阻止对象的序列化。ObjectOutputStream 将捕获异常并中止序列化进程。

<p>实现 Externalizable 接口允许对象假定可以完全控制对象的序列化形式的内容和格式。调用 Externalizable 接口的方法（writeExternal 和 readExternal）来保存和恢复对象的状态。通过类实现时，它们可以使用 ObjectOutput 和 ObjectInput 的所有方法读写它们自己的状态。对象负责处理出现的任何版本控制。

<p>Enum 常量的序列化不同于普通的 serializable 或 externalizable 对象。enum 常量的序列化形式只包含其名称；常量的字段值不被传送。为了序列化 enum 常量，ObjectOutputStream 需要写入由常量的名称方法返回的字符串。与其他 serializable 或 externalizable 对象一样，enum 常量可以作为序列化流中后续出现的 back 引用的目标。用于序列化 enum 常量的进程不可定制；在序列化期间，由 enum 类型定义的所有类特定的 writeObject 和 writeReplace 方法都将被忽略。类似地，任何 serialPersistentFields 或 serialVersionUID 字段声明也将被忽略，所有 enum 类型都有一个 0L 的固定的 serialVersionUID。

<p>基本数据（不包括 serializable 字段和 externalizable 数据）以块数据记录的形式写入 ObjectOutputStream 中。块数据记录由头部和数据组成。块数据部分包括标记和跟在部分后面的字节数。连续的基本写入数据被合并在一个块数据记录中。块数据记录的分块因子为 1024 字节。每个块数据记录都将填满 1024 字节，或者在终止块数据模式时被写入。调用 ObjectOutputStream 方法 writeObject、defaultWriteObject 和 writeFields 最初只是终止所有现有块数据记录。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口"><CODE>DataOutput</CODE></A>, 
<A HREF="../../java/io/ObjectInputStream.html" title="java.io 中的类"><CODE>ObjectInputStream</CODE></A>, 
<A HREF="../../java/io/Serializable.html" title="java.io 中的接口"><CODE>Serializable</CODE></A>, 
<A HREF="../../java/io/Externalizable.html" title="java.io 中的接口"><CODE>Externalizable</CODE></A>, 
<a href="../../../platform/serialization/spec/output.html">Serialization Specification, Section 2, Object Output Classes</a></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>嵌套类摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 中的类">ObjectOutputStream.PutField</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供对要写入 ObjectOutput 的持久字段的编程访问。</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.io.ObjectStreamConstants"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从接口 java.io.<A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 中的接口">ObjectStreamConstants</A> 继承的字段</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/ObjectStreamConstants.html#baseWireHandle">baseWireHandle</A>, <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1">PROTOCOL_VERSION_1</A>, <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_2">PROTOCOL_VERSION_2</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SC_BLOCK_DATA">SC_BLOCK_DATA</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SC_ENUM">SC_ENUM</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SC_EXTERNALIZABLE">SC_EXTERNALIZABLE</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SC_SERIALIZABLE">SC_SERIALIZABLE</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SC_WRITE_METHOD">SC_WRITE_METHOD</A>, <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_MAGIC">STREAM_MAGIC</A>, <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_VERSION">STREAM_VERSION</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SUBCLASS_IMPLEMENTATION_PERMISSION">SUBCLASS_IMPLEMENTATION_PERMISSION</A>, <A HREF="../../java/io/ObjectStreamConstants.html#SUBSTITUTION_PERMISSION">SUBSTITUTION_PERMISSION</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_ARRAY">TC_ARRAY</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_BASE">TC_BASE</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATA">TC_BLOCKDATA</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATALONG">TC_BLOCKDATALONG</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASS">TC_CLASS</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASSDESC">TC_CLASSDESC</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENDBLOCKDATA">TC_ENDBLOCKDATA</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENUM">TC_ENUM</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_EXCEPTION">TC_EXCEPTION</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_LONGSTRING">TC_LONGSTRING</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_MAX">TC_MAX</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_NULL">TC_NULL</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_OBJECT">TC_OBJECT</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_PROXYCLASSDESC">TC_PROXYCLASSDESC</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_REFERENCE">TC_REFERENCE</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_RESET">TC_RESET</A>, <A HREF="../../java/io/ObjectStreamConstants.html#TC_STRING">TC_STRING</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream()">ObjectOutputStream</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为完全重新实现 ObjectOutputStream 的子类提供一种方法，让它不必分配仅由 ObjectOutputStream 的实现使用的私有数据。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream(java.io.OutputStream)">ObjectOutputStream</A></B>(<A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建写入指定 OutputStream 的 ObjectOutputStream。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#annotateClass(java.lang.Class)">annotateClass</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子类可以实现此方法，从而允许在流中存储类数据。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#annotateProxyClass(java.lang.Class)">annotateProxyClass</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子类可以实现此方法，从而在流中存储定制数据和动态代理类的描述符。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关闭流。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#defaultWriteObject()">defaultWriteObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将当前类的非静态和非瞬态字段写入此流。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#drain()">drain</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;排空 ObjectOutputStream 中的所有已缓冲数据。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#enableReplaceObject(boolean)">enableReplaceObject</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许流对流中的对象进行替换。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#flush()">flush</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刷新该流的缓冲。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 中的类">ObjectOutputStream.PutField</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#putFields()">putFields</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取用于缓冲写入流中的持久存储字段的对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#replaceObject(java.lang.Object)">replaceObject</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在序列化期间，此方法允许 ObjectOutputStream 的受信任子类使用一个对象替代另一个对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#reset()">reset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重置将丢弃已写入流中的所有对象的状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#useProtocolVersion(int)">useProtocolVersion</A></B>(int&nbsp;version)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定要在写入流时使用的流协议版本。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#write(byte[])">write</A></B>(byte[]&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入一个 byte 数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#write(byte[], int, int)">write</A></B>(byte[]&nbsp;buf,
      int&nbsp;off,
      int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入字节的子数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#write(int)">write</A></B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入一个字节。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeBoolean(boolean)">writeBoolean</A></B>(boolean&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入一个 boolean 值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeByte(int)">writeByte</A></B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入一个 8 位字节。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeBytes(java.lang.String)">writeBytes</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以字节序列形式写入一个 String。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeChar(int)">writeChar</A></B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入一个 16 位的 char 值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeChars(java.lang.String)">writeChars</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 char 序列形式写入一个 String。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeClassDescriptor(java.io.ObjectStreamClass)">writeClassDescriptor</A></B>(<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 中的类">ObjectStreamClass</A>&nbsp;desc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的类描述符写入 ObjectOutputStream。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeDouble(double)">writeDouble</A></B>(double&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入一个 64 位的 double 值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeFields()">writeFields</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将已缓冲的字段写入流中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeFloat(float)">writeFloat</A></B>(float&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入一个 32 位的 float 值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeInt(int)">writeInt</A></B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入一个 32 位的 int 值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeLong(long)">writeLong</A></B>(long&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入一个 64 位的 long 值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeObject(java.lang.Object)">writeObject</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将指定的对象写入 ObjectOutputStream。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeObjectOverride(java.lang.Object)">writeObjectOverride</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子类用于重写默认 writeObject 方法的方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeShort(int)">writeShort</A></B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写入一个 16 位的 short 值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeStreamHeader()">writeStreamHeader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供 writeStreamHeader 方法，这样子类可以将其自身的头部添加或预加到流中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeUnshared(java.lang.Object)">writeUnshared</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将&ldquo;未共享&rdquo;对象写入 ObjectOutputStream。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeUTF(java.lang.String)">writeUTF</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 <a href="DataInput.html#modified-utf-8">UTF-8 修改版</a>格式写入此 String 的基本数据。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ObjectOutputStream(java.io.OutputStream)"><!-- --></A><H3>
ObjectOutputStream</H3>
<PRE>
public <B>ObjectOutputStream</B>(<A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A>&nbsp;out)
                   throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>创建写入指定 OutputStream 的 ObjectOutputStream。此构造方法将序列化流部分写入底层流；调用者可以通过立即刷新流，确保在读取头部时，用于接收 ObjectInputStreams 构造方法不会阻塞。

<p>如果安装了安全管理器，则在通过重写 ObjectOutputStream.putFields 或 ObjectOutputStream.writeUnshared 方法的子类的构造方法来直接或间接调用此构造方法时，它将对 &quot;enableSubclassImplementation&quot; SerializablePermission 进行检查。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>out</CODE> - 要写入数据的输出流
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在写入流部分时发生 I/O 错误
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果不受信任的子类非法重写安全敏感方法
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>out</code> 为 <code>null</code><DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream()"><CODE>ObjectOutputStream()</CODE></A>, 
<A HREF="../../java/io/ObjectOutputStream.html#putFields()"><CODE>putFields()</CODE></A>, 
<A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream(java.io.InputStream)"><CODE>ObjectInputStream.ObjectInputStream(InputStream)</CODE></A></DL>
</DL>
<HR>

<A NAME="ObjectOutputStream()"><!-- --></A><H3>
ObjectOutputStream</H3>
<PRE>
protected <B>ObjectOutputStream</B>()
                      throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A>,
                             <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>为完全重新实现 ObjectOutputStream 的子类提供一种方法，让它不必分配仅由 ObjectOutputStream 的实现使用的私有数据。

<p>如果已经安装了安全管理器，则此方法首先利用 <code>SerializablePermission(&quot;enableSubclassImplementation&quot;)</code> 权限调用安全管理器的 <code>checkPermission</code> 方法，以确保可以启用子类化。
<P>
<DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，且其 <code>checkPermission</code> 方法不允许启用子类化。
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE><DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>, 
<A HREF="../../java/io/SerializablePermission.html" title="java.io 中的类"><CODE>SerializablePermission</CODE></A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="useProtocolVersion(int)"><!-- --></A><H3>
useProtocolVersion</H3>
<PRE>
public void <B>useProtocolVersion</B>(int&nbsp;version)
                        throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>指定要在写入流时使用的流协议版本。

<p>此例程提供了一个钩子 (hook)，允许以与旧版的流格式向后兼容的格式写入当前版的 Serialization。

<p>我们将尽最大努力避免造成额外的向后不兼容性；但有时没有其他替代方法。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>version</CODE> - 根据 java.io.ObjectStreamConstants 使用 ProtocolVersion。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果在已序列化所有对象后调用。
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果传入的版本无效。
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1"><CODE>ObjectStreamConstants.PROTOCOL_VERSION_1</CODE></A>, 
<A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_2"><CODE>ObjectStreamConstants.PROTOCOL_VERSION_2</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="writeObject(java.lang.Object)"><!-- --></A><H3>
writeObject</H3>
<PRE>
public final void <B>writeObject</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)
                       throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>将指定的对象写入 ObjectOutputStream。对象的类、类的签名，以及类及其所有超类型的非瞬态和非静态字段的值都将被写入。可以使用 writeObject 和 readObject 方法重写类的默认序列化。由此对象引用的对象是以可变迁的方式写入的，这样，可以通过 ObjectInputStream 重新构造这些对象的完全等价的图形。

<p>当 OutputStream 中出现问题或者遇到不应序列化的类时，将抛出异常。所有异常对于 OutputStream 而言都是致命的，使其处于不确定状态；并由调用者来忽略或恢复流的状态。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 中的接口">ObjectOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/ObjectOutput.html#writeObject(java.lang.Object)">writeObject</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 要写入的对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/InvalidClassException.html" title="java.io 中的类">InvalidClassException</A></CODE> - 序列化操作使用的类出了问题。
<DD><CODE><A HREF="../../java/io/NotSerializableException.html" title="java.io 中的类">NotSerializableException</A></CODE> - 某个要序列化的对象不能实现 java.io.Serializable 接口。
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 由底层 OutputStream 抛出的任何异常。</DL>
</DD>
</DL>
<HR>

<A NAME="writeObjectOverride(java.lang.Object)"><!-- --></A><H3>
writeObjectOverride</H3>
<PRE>
protected void <B>writeObjectOverride</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)
                            throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>子类用于重写默认 writeObject 方法的方法。此方法由 ObjectInputStream 的受信任子类调用，可以使用受保护的无参数构造方法来构造 ObjectInputStream。子类需要使用修饰符 &quot;final&quot; 提供重写方法。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 要写入底层流的对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果写入底层流时发生 I/O 错误<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream()"><CODE>ObjectOutputStream()</CODE></A>, 
<A HREF="../../java/io/ObjectOutputStream.html#writeObject(java.lang.Object)"><CODE>writeObject(Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="writeUnshared(java.lang.Object)"><!-- --></A><H3>
writeUnshared</H3>
<PRE>
public void <B>writeUnshared</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)
                   throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>将&ldquo;未共享&rdquo;对象写入 ObjectOutputStream。此方法等同于 writeObject，不同点在于它总是将给定对象作为流中唯一的新对象进行写入（相对于指向以前序列化实例的 back 引用而言）。尤其是：
 <ul>
<li>通过 writeUnshared 写入的对象总是作为新出现对象（未曾将对象写入流中）被序列化，不管该对象以前是否已经被写入过。

<li>如果使用 writeObject 写入以前通过 writeUnshared 写入的对象，则可将以前的 writeUnshared 操作视为写入一个单独对象。换句话说，ObjectOutputStream 永远不会生成通过调用 writeUnshared 写入的对象数据的 back 引用。
 </ul>
虽然通过 writeUnshared 写入对象本身不能保证反序列化对象时对象引用的唯一性，但它允许在流中多次定义单个对象，因此接收方对 readUnshared 的多个调用不会引发冲突。注意，上述规则仅应用于通过 writeUnshared 写入的基层对象,而不能应用于要序列化的对象图形中的任何可变迁方式引用的子对象。

<p>重写此方法的 ObjectOutputStream 子类只能在处理 &quot;enableSubclassImplementation&quot; SerializablePermission 的安全上下文中构造；在不具有此权限的情况下，任何实例化这种子类的尝试都将导致抛出 SecurityException。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 要写入流的对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/NotSerializableException.html" title="java.io 中的类">NotSerializableException</A></CODE> - 如果要序列化的图形中的对象不能实现 Serializable 接口
<DD><CODE><A HREF="../../java/io/InvalidClassException.html" title="java.io 中的类">InvalidClassException</A></CODE> - 如果要序列化的对象的类存在问题
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果序列化期间发生 I/O 错误<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="defaultWriteObject()"><!-- --></A><H3>
defaultWriteObject</H3>
<PRE>
public void <B>defaultWriteObject</B>()
                        throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>将当前类的非静态和非瞬态字段写入此流。此字段只能从正在序列化的类的 writeObject 方法中调用。如果从其他地方调用该字段，则将抛出 NotActiveException。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在写入底层 <code>OutputStream</code> 中时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="putFields()"><!-- --></A><H3>
putFields</H3>
<PRE>
public <A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 中的类">ObjectOutputStream.PutField</A> <B>putFields</B>()
                                      throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>获取用于缓冲写入流中的持久存储字段的对象。调用 writeFields 方法时，字段被写入流中。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>保存 serializable 字段的 Putfield 类的实例
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="writeFields()"><!-- --></A><H3>
writeFields</H3>
<PRE>
public void <B>writeFields</B>()
                 throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>将已缓冲的字段写入流中。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在写入底层流时发生 I/O 错误
<DD><CODE><A HREF="../../java/io/NotActiveException.html" title="java.io 中的类">NotActiveException</A></CODE> - 未调用类 writeObject 方法来写入对象的状态时调用。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>重置将丢弃已写入流中的所有对象的状态。重新设置状态，使其与新的 ObjectOutputStream 相同。将流中的当前点标记为 reset，相应的 ObjectInputStream 也将在这一点重置。以前写入流中的对象不再被视为正位于流中。它们会再次被写入流。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在序列化对象时调用 reset()。</DL>
</DD>
</DL>
<HR>

<A NAME="annotateClass(java.lang.Class)"><!-- --></A><H3>
annotateClass</H3>
<PRE>
protected void <B>annotateClass</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;cl)
                      throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>子类可以实现此方法，从而允许在流中存储类数据。默认情况下，此方法不执行任何操作。ObjectInputStream 中的相应方法是 resolveClass。对于流中的每个唯一的类，此方法只调用一次。类名和类签名已经写入流中。此方法可以随意使用 ObjectOutputStream 来保存它认为合适的类的任何表示形式（例如类文件的字节）。ObjectInputStream 的相应子类中的 resolveClass 方法必须读取并使用由 annotateClass 写入的数据或对象。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>cl</CODE> - 注释定制数据的类
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 底层 OutputStream 抛出任何异常。</DL>
</DD>
</DL>
<HR>

<A NAME="annotateProxyClass(java.lang.Class)"><!-- --></A><H3>
annotateProxyClass</H3>
<PRE>
protected void <B>annotateProxyClass</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;cl)
                           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>子类可以实现此方法，从而在流中存储定制数据和动态代理类的描述符。

<p>对于流中的每个唯一的代理类描述符，此方法只调用一次。在 <code>ObjectOutputStream</code> 中，此方法的默认实现不执行任何操作。

<p><code>ObjectInputStream</code> 中的相应方法是 <code>resolveProxyClass</code>。对于重写此方法的 <code>ObjectOutputStream</code> 的给定子类，<code>ObjectInputStream</code> 的相应子类中的 <code>resolveProxyClass</code> 方法必须读取由 <code>annotateProxyClass</code> 写入的所有数据或对象。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>cl</CODE> - 注释定制数据的代理类
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 底层 <code>OutputStream</code> 抛出的任何异常<DT><B>从以下版本开始：</B></DT>
  <DD>1.3</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/ObjectInputStream.html#resolveProxyClass(java.lang.String[])"><CODE>ObjectInputStream.resolveProxyClass(String[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="replaceObject(java.lang.Object)"><!-- --></A><H3>
replaceObject</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>replaceObject</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)
                        throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>在序列化期间，此方法允许 ObjectOutputStream 的受信任子类使用一个对象替代另一个对象。在调用 enableReplaceObject 之前，不允许取代对象。enableReplaceObject 方法检查请求取代的流是否可以信任。写入序列化流的每个对象在第一次出现时被传递给 replaceObject。在后续引用中，该对象将由初始调用 replaceObject 所返回的对象取代。为了确保不会无意暴露对象的私有状态，可以仅让受信任的流使用 replaceObject。
 
<p>ObjectOutputStream.writeObject 方法使用 Object 类型的参数（相对于 Serializable 类型），允许非 serializable 对象由 serializable 对象取代。
 
<p>在子类取代对象时，必须确保要么在反序列化期间进行互补替代，要么替代对象与存储引用的每个字段兼容。如果对象的类型不是字段或数组元素类型的子类，则通过引发异常中止序列化并且不存储对象。

<p>此方法仅在首次遇到每个对象时调用一次。对象的所有后续引用都将被重定向到新对象。此方法应该返回要替代的对象或初始对象。

<p>替代对象时可以返回 null，但是在包含到初始对象的引用的类中可能导致 NullReferenceException，因为它们可能期望得到对象而不是 null。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 要取代的对象
<DT><B>返回：</B><DD>取代指定对象的替换对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 底层 OutputStream 抛出的任何异常。</DL>
</DD>
</DL>
<HR>

<A NAME="enableReplaceObject(boolean)"><!-- --></A><H3>
enableReplaceObject</H3>
<PRE>
protected boolean <B>enableReplaceObject</B>(boolean&nbsp;enable)
                               throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>允许流对流中的对象进行替换。启用时，将为正序列化的每个对象调用 replaceObject 方法。

<p>如果 <code>enable</code> 为 true，并且安装了安全管理器，则此方法首先利用 <code>SerializablePermission(&quot;enableSubstitution&quot;)</code> 权限调用安全管理器的 <code>checkPermission</code> 方法，以确保允许流对流中的对象进行替换。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>enable</CODE> - 允许取代对象的 boolean 参数
<DT><B>返回：</B><DD>调用此方法之前的以前的设置
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，且其 <code>checkPermission</code> 方法不允许流对流中的对象进行替换。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>, 
<A HREF="../../java/io/SerializablePermission.html" title="java.io 中的类"><CODE>SerializablePermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="writeStreamHeader()"><!-- --></A><H3>
writeStreamHeader</H3>
<PRE>
protected void <B>writeStreamHeader</B>()
                          throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>提供 writeStreamHeader 方法，这样子类可以将其自身的头部添加或预加到流中。它可以将幻数 (magic number) 和版本写入流。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeClassDescriptor(java.io.ObjectStreamClass)"><!-- --></A><H3>
writeClassDescriptor</H3>
<PRE>
protected void <B>writeClassDescriptor</B>(<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 中的类">ObjectStreamClass</A>&nbsp;desc)
                             throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>将指定的类描述符写入 ObjectOutputStream。类描述符用于标识写入流中的对象的类。ObjectOutputStream 的子类可以重写此方法，从而定制将类描述符写入序列化流中的方式。然后，应该重写 ObjectInputStream 中的相应方法（<code>readClassDescriptor</code>），以便根据其定制的流表示形式来重构类描述符。默认情况下，此方法根据 Object Serialization 规范中定义的格式写入类描述符。
 
<p>注意，仅当 ObjectOutputStream 没有使用旧的序列化流格式（通过调用 ObjectOutputStream 的 <code>useProtocolVersion</code> 方法设置）时才调用此方法。如果此序列化流在使用旧的格式（即 <code>PROTOCOL_VERSION_1</code>），则以不可重写或自定义的方式在内部写入类描述符。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>desc</CODE> - 要写入流的类描述符
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误。<DT><B>从以下版本开始：</B></DT>
  <DD>1.3</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/io/ObjectInputStream.html#readClassDescriptor()"><CODE>ObjectInputStream.readClassDescriptor()</CODE></A>, 
<A HREF="../../java/io/ObjectOutputStream.html#useProtocolVersion(int)"><CODE>useProtocolVersion(int)</CODE></A>, 
<A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1"><CODE>ObjectStreamConstants.PROTOCOL_VERSION_1</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="write(int)"><!-- --></A><H3>
write</H3>
<PRE>
public void <B>write</B>(int&nbsp;val)
           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入一个字节。在实际写入字节前，此方法将发生阻塞。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#write(int)">write</A></CODE><DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 中的接口">ObjectOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/ObjectOutput.html#write(int)">write</A></CODE><DT><B>指定者：</B><DD>类 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A></CODE> 中的 <CODE><A HREF="../../java/io/OutputStream.html#write(int)">write</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>val</CODE> - 要写入流中的字节
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误。</DL>
</DD>
</DL>
<HR>

<A NAME="write(byte[])"><!-- --></A><H3>
write</H3>
<PRE>
public void <B>write</B>(byte[]&nbsp;buf)
           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入一个 byte 数组。在实际写入字节前，此方法将发生阻塞。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#write(byte[])">write</A></CODE><DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 中的接口">ObjectOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/ObjectOutput.html#write(byte[])">write</A></CODE><DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A></CODE> 中的 <CODE><A HREF="../../java/io/OutputStream.html#write(byte[])">write</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>buf</CODE> - 要写入的数据
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误。<DT><B>另请参见：</B><DD><A HREF="../../java/io/OutputStream.html#write(byte[], int, int)"><CODE>OutputStream.write(byte[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="write(byte[], int, int)"><!-- --></A><H3>
write</H3>
<PRE>
public void <B>write</B>(byte[]&nbsp;buf,
                  int&nbsp;off,
                  int&nbsp;len)
           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入字节的子数组。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#write(byte[], int, int)">write</A></CODE><DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 中的接口">ObjectOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/ObjectOutput.html#write(byte[], int, int)">write</A></CODE><DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A></CODE> 中的 <CODE><A HREF="../../java/io/OutputStream.html#write(byte[], int, int)">write</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>buf</CODE> - 要写入的数据<DD><CODE>off</CODE> - 数据中的初始偏移量<DD><CODE>len</CODE> - 写入的字节数
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误。</DL>
</DD>
</DL>
<HR>

<A NAME="flush()"><!-- --></A><H3>
flush</H3>
<PRE>
public void <B>flush</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>刷新该流的缓冲。此操作将写入所有已缓冲的输出字节，并将它们刷新到底层流中。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/Flushable.html" title="java.io 中的接口">Flushable</A></CODE> 中的 <CODE><A HREF="../../java/io/Flushable.html#flush()">flush</A></CODE><DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 中的接口">ObjectOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/ObjectOutput.html#flush()">flush</A></CODE><DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A></CODE> 中的 <CODE><A HREF="../../java/io/OutputStream.html#flush()">flush</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误。</DL>
</DD>
</DL>
<HR>

<A NAME="drain()"><!-- --></A><H3>
drain</H3>
<PRE>
protected void <B>drain</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>排空 ObjectOutputStream 中的所有已缓冲数据。与刷新类似，但没有将刷新传播到底层流。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>关闭流。必须调用此方法来释放与此流有关的所有资源。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/Closeable.html" title="java.io 中的接口">Closeable</A></CODE> 中的 <CODE><A HREF="../../java/io/Closeable.html#close()">close</A></CODE><DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 中的接口">ObjectOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/ObjectOutput.html#close()">close</A></CODE><DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A></CODE> 中的 <CODE><A HREF="../../java/io/OutputStream.html#close()">close</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误。</DL>
</DD>
</DL>
<HR>

<A NAME="writeBoolean(boolean)"><!-- --></A><H3>
writeBoolean</H3>
<PRE>
public void <B>writeBoolean</B>(boolean&nbsp;val)
                  throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入一个 boolean 值。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeBoolean(boolean)">writeBoolean</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>val</CODE> - 要写入的 boolean 值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeByte(int)"><!-- --></A><H3>
writeByte</H3>
<PRE>
public void <B>writeByte</B>(int&nbsp;val)
               throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入一个 8 位字节。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeByte(int)">writeByte</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>val</CODE> - 要写入的字节值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeShort(int)"><!-- --></A><H3>
writeShort</H3>
<PRE>
public void <B>writeShort</B>(int&nbsp;val)
                throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入一个 16 位的 short 值。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeShort(int)">writeShort</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>val</CODE> - 要写入的 short 值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeChar(int)"><!-- --></A><H3>
writeChar</H3>
<PRE>
public void <B>writeChar</B>(int&nbsp;val)
               throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入一个 16 位的 char 值。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeChar(int)">writeChar</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>val</CODE> - 要写入的 char 值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeInt(int)"><!-- --></A><H3>
writeInt</H3>
<PRE>
public void <B>writeInt</B>(int&nbsp;val)
              throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入一个 32 位的 int 值。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeInt(int)">writeInt</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>val</CODE> - 要写入的整数值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeLong(long)"><!-- --></A><H3>
writeLong</H3>
<PRE>
public void <B>writeLong</B>(long&nbsp;val)
               throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入一个 64 位的 long 值。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeLong(long)">writeLong</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>val</CODE> - 要写入的 long 值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeFloat(float)"><!-- --></A><H3>
writeFloat</H3>
<PRE>
public void <B>writeFloat</B>(float&nbsp;val)
                throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入一个 32 位的 float 值。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeFloat(float)">writeFloat</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>val</CODE> - 要写入的 float 值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeDouble(double)"><!-- --></A><H3>
writeDouble</H3>
<PRE>
public void <B>writeDouble</B>(double&nbsp;val)
                 throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>写入一个 64 位的 double 值。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeDouble(double)">writeDouble</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>val</CODE> - 要写入的 double 值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeBytes(java.lang.String)"><!-- --></A><H3>
writeBytes</H3>
<PRE>
public void <B>writeBytes</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;str)
                throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>以字节序列形式写入一个 String。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeBytes(java.lang.String)">writeBytes</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>str</CODE> - 要写入的字节的 String
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeChars(java.lang.String)"><!-- --></A><H3>
writeChars</H3>
<PRE>
public void <B>writeChars</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;str)
                throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>以 char 序列形式写入一个 String。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeChars(java.lang.String)">writeChars</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>str</CODE> - 要写入的 char 的 String
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将数据写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<HR>

<A NAME="writeUTF(java.lang.String)"><!-- --></A><H3>
writeUTF</H3>
<PRE>
public void <B>writeUTF</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;str)
              throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>以 <a href="DataInput.html#modified-utf-8">UTF-8 修改版</a>格式写入此 String 的基本数据。注意，将 String 作为基本数据写入流中与将它作为 Object 写入流中明显不同。由 writeObject 写入的 String 实例最初是作为 String 写入流中的。然后，writeObject() 调用将对该字符串的引用写入流中。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 中的接口">DataOutput</A></CODE> 中的 <CODE><A HREF="../../java/io/DataOutput.html#writeUTF(java.lang.String)">writeUTF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>str</CODE> - 要写入的 String
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果在将输入写入底层流时发生 I/O 错误</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectOutputStream.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/ObjectOutput.html" title="java.io 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/io/ObjectOutputStream.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="ObjectOutputStream.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
