<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 12:48:08 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
Class (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Class (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Class.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/CharSequence.html" title="java.lang 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Class.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Class.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
类 Class&lt;T&gt;</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.lang.Class&lt;T&gt;</B>
</PRE>
<DL>
<DT><DT><B>类型参数：</B><DD><CODE>T</CODE> - 由此 <code>Class</code> 对象建模的类的类型。例如，<code>String.class</code> 的类型是 <code>Class&lt;String&gt;</code>。如果将被建模的类未知，则使用 <code>Class&lt;?&gt;</code>。</DL>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../java/io/Serializable.html" title="java.io 中的接口">Serializable</A>, <A HREF="../../java/lang/reflect/AnnotatedElement.html" title="java.lang.reflect 中的接口">AnnotatedElement</A>, <A HREF="../../java/lang/reflect/GenericDeclaration.html" title="java.lang.reflect 中的接口">GenericDeclaration</A>, <A HREF="../../java/lang/reflect/Type.html" title="java.lang.reflect 中的接口">Type</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public final class <B>Class&lt;T&gt;</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A><DT>implements <A HREF="../../java/io/Serializable.html" title="java.io 中的接口">Serializable</A>, <A HREF="../../java/lang/reflect/GenericDeclaration.html" title="java.lang.reflect 中的接口">GenericDeclaration</A>, <A HREF="../../java/lang/reflect/Type.html" title="java.lang.reflect 中的接口">Type</A>, <A HREF="../../java/lang/reflect/AnnotatedElement.html" title="java.lang.reflect 中的接口">AnnotatedElement</A></DL>
</PRE>

<P>
<code>Class</code> 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 <code>Class</code> 对象。基本的 Java 类型（<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code> 和 <code>double</code>）和关键字 <code>void</code> 也表示为 <code>Class</code> 对象。

<p> <code>Class</code> 没有公共构造方法。<code>Class</code> 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 <code>defineClass</code> 方法自动构造的。

<p> 以下示例使用 <code>Class</code> 对象来显示对象的类名：

<p> <blockquote><pre>
     void printClassName(Object obj) {
         System.out.println("The class of " + obj +
                            " is " + obj.getClass().getName());
     }
 </pre></blockquote>
 
<p> 还可以使用一个类字面值（JLS Section <A HREF="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#251530">15.8.2</A>）来获取指定类型（或 void）的 <code>Class</code> 对象。例如：

 <p> <blockquote><pre>
     System.out.println("The name of class Foo is: "+Foo.class.getName());
 </pre></blockquote>
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#defineClass(byte[], int, int)"><CODE>ClassLoader.defineClass(byte[], int, int)</CODE></A>, 
<A HREF="../../serialized-form.html#java.lang.Class">序列化表格</A></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;U&gt; <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;? extends U&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#asSubclass(java.lang.Class)">asSubclass</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;U&gt;&nbsp;clazz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;强制转换该 <tt>Class</tt> 对象，以表示指定的 class 对象所表示的类的一个子类。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#cast(java.lang.Object)">cast</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个对象强制转换成此 <tt>Class</tt> 对象所表示的类或接口。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#desiredAssertionStatus()">desiredAssertionStatus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要在调用此方法时将要初始化该类，则返回将分配给该类的断言状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#forName(java.lang.String)">forName</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;className)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回与带有给定字符串名的类或接口相关联的 <code>Class</code> 对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#forName(java.lang.String, boolean, java.lang.ClassLoader)">forName</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
        boolean&nbsp;initialize,
        <A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;loader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用给定的类加载器，返回与带有给定字符串名的类或接口相关联的 <code>Class</code> 对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;A extends <A HREF="../../java/lang/annotation/Annotation.html" title="java.lang.annotation 中的接口">Annotation</A>&gt; 
<BR>
A</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getAnnotation(java.lang.Class)">getAnnotation</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;A&gt;&nbsp;annotationClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/annotation/Annotation.html" title="java.lang.annotation 中的接口">Annotation</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getAnnotations()">getAnnotations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此元素上存在的所有注释。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getCanonicalName()">getCanonicalName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 Java Language Specification 中所定义的底层类的规范化名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getClasses()">getClasses</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个包含某些 <code>Class</code> 对象的数组，这些对象表示属于此 <code>Class</code> 对象所表示的类的成员的所有公共类和接口。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getClassLoader()">getClassLoader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回该类的类加载器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getComponentType()">getComponentType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示数组组件类型的 <code>Class</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类">Constructor</A>&lt;<A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getConstructor(java.lang.Class...)">getConstructor</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;...&nbsp;parameterTypes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个 <code>Constructor</code> 对象，它反映此 <code>Class</code> 对象所表示的类的指定公共构造方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类">Constructor</A>&lt;?&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getConstructors()">getConstructors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个包含某些 <code>Constructor</code> 对象的数组，这些对象反映此 <code>Class</code> 对象所表示的类的所有公共构造方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/annotation/Annotation.html" title="java.lang.annotation 中的接口">Annotation</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getDeclaredAnnotations()">getDeclaredAnnotations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回直接存在于此元素上的所有注释。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getDeclaredClasses()">getDeclaredClasses</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 <code>Class</code> 对象的一个数组，这些对象反映声明为此 <code>Class</code> 对象所表示的类的成员的所有类和接口。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类">Constructor</A>&lt;<A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getDeclaredConstructor(java.lang.Class...)">getDeclaredConstructor</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;...&nbsp;parameterTypes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个 <code>Constructor</code> 对象，该对象反映此 <code>Class</code> 对象所表示的类或接口的指定构造方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类">Constructor</A>&lt;?&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getDeclaredConstructors()">getDeclaredConstructors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 <code>Constructor</code> 对象的一个数组，这些对象反映此 <code>Class</code> 对象表示的类声明的所有构造方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Field.html" title="java.lang.reflect 中的类">Field</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getDeclaredField(java.lang.String)">getDeclaredField</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个 <code>Field</code> 对象，该对象反映此 <code>Class</code> 对象所表示的类或接口的指定已声明字段。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Field.html" title="java.lang.reflect 中的类">Field</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getDeclaredFields()">getDeclaredFields</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 <code>Field</code> 对象的一个数组，这些对象反映此 <code>Class</code> 对象所表示的类或接口所声明的所有字段。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类">Method</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getDeclaredMethod(java.lang.String, java.lang.Class...)">getDeclaredMethod</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                  <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;...&nbsp;parameterTypes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个 <code>Method</code> 对象，该对象反映此 <code>Class</code> 对象所表示的类或接口的指定已声明方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类">Method</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getDeclaredMethods()">getDeclaredMethods</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 <code>Method</code> 对象的一个数组，这些对象反映此 <code>Class</code> 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getDeclaringClass()">getDeclaringClass</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此 <code>Class</code> 对象所表示的类或接口是另一个类的成员，则返回的 <code>Class</code> 对象表示该对象的声明类。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getEnclosingClass()">getEnclosingClass</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回底层类的立即封闭类。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类">Constructor</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getEnclosingConstructor()">getEnclosingConstructor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果该 <tt>Class</tt> 对象表示构造方法中的一个本地或匿名类，则返回 <A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类"><CODE>Constructor</CODE></A> 对象，它表示底层类的立即封闭构造方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类">Method</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getEnclosingMethod()">getEnclosingMethod</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此 <tt>Class</tt> 对象表示某一方法中的一个本地或匿名类，则返回 <A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类"><CODE>Method</CODE></A> 对象，它表示底层类的立即封闭方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getEnumConstants()">getEnumConstants</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此 Class 对象不表示枚举类型，则返回枚举类的元素或 null。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Field.html" title="java.lang.reflect 中的类">Field</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getField(java.lang.String)">getField</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个 <code>Field</code> 对象，它反映此 <code>Class</code> 对象所表示的类或接口的指定公共成员字段。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Field.html" title="java.lang.reflect 中的类">Field</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getFields()">getFields</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个包含某些 <code>Field</code> 对象的数组，这些对象反映此 <code>Class</code> 对象所表示的类或接口的所有可访问公共字段。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Type.html" title="java.lang.reflect 中的接口">Type</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getGenericInterfaces()">getGenericInterfaces</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示某些接口的 <tt>Type</tt>，这些接口由此对象所表示的类或接口直接实现。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Type.html" title="java.lang.reflect 中的接口">Type</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getGenericSuperclass()">getGenericSuperclass</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示此 <tt>Class</tt> 所表示的实体（类、接口、基本类型或 void）的直接超类的 <tt>Type</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getInterfaces()">getInterfaces</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定此对象所表示的类或接口实现的接口。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类">Method</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getMethod(java.lang.String, java.lang.Class...)">getMethod</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
          <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;...&nbsp;parameterTypes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个 <code>Method</code> 对象，它反映此 <code>Class</code> 对象所表示的类或接口的指定公共成员方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类">Method</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getMethods()">getMethods</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个包含某些 <code>Method</code> 对象的数组，这些对象反映此 <code>Class</code> 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 <em>member</em> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getModifiers()">getModifiers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此类或接口以整数编码的 Java 语言修饰符。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getName()">getName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 <tt>String</tt> 的形式返回此 <tt>Class</tt> 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Package.html" title="java.lang 中的类">Package</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getPackage()">getPackage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取此类的包。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/security/ProtectionDomain.html" title="java.security 中的类">ProtectionDomain</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getProtectionDomain()">getProtectionDomain</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回该类的 <code>ProtectionDomain</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getResource(java.lang.String)">getResource</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找带有给定名称的资源。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/InputStream.html" title="java.io 中的类">InputStream</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getResourceAsStream(java.lang.String)">getResourceAsStream</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找具有给定名称的资源。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getSigners()">getSigners</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取此类的标记。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getSimpleName()">getSimpleName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回源代码中给出的底层类的简称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;? super <A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getSuperclass()">getSuperclass</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示此 <code>Class</code> 所表示的实体（类、接口、基本类型或 void）的超类的 <code>Class</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/reflect/TypeVariable.html" title="java.lang.reflect 中的接口">TypeVariable</A>&lt;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;<A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A>&gt;&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#getTypeParameters()">getTypeParameters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按声明顺序返回 <tt>TypeVariable</tt> 对象的一个数组，这些对象表示用此 <tt>GenericDeclaration</tt> 对象所表示的常规声明来声明的类型变量。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isAnnotation()">isAnnotation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此 <tt>Class</tt> 对象表示一个注释类型则返回 true。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isAnnotationPresent(java.lang.Class)">isAnnotationPresent</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;? extends <A HREF="../../java/lang/annotation/Annotation.html" title="java.lang.annotation 中的接口">Annotation</A>&gt;&nbsp;annotationClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果指定类型的注释存在于此元素上，则返回 true，否则返回 false。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isAnonymousClass()">isAnonymousClass</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当底层类是匿名类时返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isArray()">isArray</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定此 <code>Class</code> 对象是否表示一个数组类。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isAssignableFrom(java.lang.Class)">isAssignableFrom</A></B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;cls)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定此 <code>Class</code> 对象所表示的类或接口与指定的 <code>Class</code> 参数所表示的类或接口是否相同，或是否是其超类或超接口。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isEnum()">isEnum</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当该类声明为源代码中的枚举时返回 true。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isInstance(java.lang.Object)">isInstance</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定指定的 <code>Object</code> 是否与此 <code>Class</code> 所表示的对象赋值兼容。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isInterface()">isInterface</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定指定的 <code>Class</code> 对象是否表示一个接口类型。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isLocalClass()">isLocalClass</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当底层类是本地类时返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isMemberClass()">isMemberClass</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当底层类是成员类时返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isPrimitive()">isPrimitive</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定指定的 <code>Class</code> 对象是否表示一个基本类型。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#isSynthetic()">isSynthetic</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此类是复合类，则返回 <tt>true</tt>，否则 <tt>false</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#newInstance()">newInstance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建此 <tt>Class</tt> 对象所表示的类的一个新实例。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Class.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将对象转换为字符串。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>()</PRE>
<DL>
<DD>将对象转换为字符串。字符串的表示形式为字符串 "class" 或 "interface" 后面紧跟一个空格，然后是该类的完全限定名，它具有 <code>getName</code> 返回的那种格式。如果此 <code>Class</code> 对象表示一个基本类型，则此方法返回该基本类型的名称。如果该 <code>Class</code> 对象表示 void，则此方法返回 "void"。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示此 class 对象的字符串。</DL>
</DD>
</DL>
<HR>

<A NAME="forName(java.lang.String)"><!-- --></A><H3>
forName</H3>
<PRE>
public static <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>forName</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;className)
                        throws <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></PRE>
<DL>
<DD>返回与带有给定字符串名的类或接口相关联的 <code>Class</code> 对象。调用此方法等效于：

 <blockquote><pre>
  Class.forName(className, true, currentLoader)
 </pre></blockquote>

 其中 <code>currentLoader</code> 表示当前类的定义类加载器。

 <p> 例如，以下代码片段返回命名为 <code>java.lang.Thread</code> 的类的运行时 <code>Class</code> 描述符。

 <blockquote><pre>
   Class t = Class.forName("java.lang.Thread")
 </pre></blockquote>
 <p>
 调用 <tt>forName("X")</tt> 将导致命名为 <tt>X</tt> 的类被初始化。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>className</CODE> - 所需类的完全限定名。
<DT><B>返回：</B><DD>具有指定名的类的 <code>Class</code> 对象。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/LinkageError.html" title="java.lang 中的类">LinkageError</A></CODE> - 如果链接失败
<DD><CODE><A HREF="../../java/lang/ExceptionInInitializerError.html" title="java.lang 中的类">ExceptionInInitializerError</A></CODE> - 如果此方法所激发的初始化失败
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></CODE> - 如果无法定位该类</DL>
</DD>
</DL>
<HR>

<A NAME="forName(java.lang.String, boolean, java.lang.ClassLoader)"><!-- --></A><H3>
forName</H3>
<PRE>
public static <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>forName</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                               boolean&nbsp;initialize,
                               <A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;loader)
                        throws <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></PRE>
<DL>
<DD>使用给定的类加载器，返回与带有给定字符串名的类或接口相关联的 <code>Class</code> 对象。（以 <code>getName</code> 所返回的格式）给定一个类或接口的完全限定名，此方法会试图定位、加载和链接该类或接口。指定的类加载器用于加载该类或接口。如果参数 <code>loader</code> 为 null，则该类通过引导类加载器加载。只有 <code>initialize</code> 参数为 <code>true</code> 且以前未被初始化时，才初始化该类。

<p> 如果 <code>name</code> 表示一个基本类型或 void，则会尝试在未命名的包中定位用户定义的名为 <code>name</code> 的类。因此，该方法不能用于获得表示基本类型或 void 的任何 <code>Class</code> 对象。

<p> 如果 <code>name</code> 表示一个数组类，则会加载但不初始化该数组类的组件类型。

<p> 例如，在一个实例方法中，表达式：

 <blockquote><pre>
  Class.forName("Foo")
 </pre></blockquote>

 等效于：

 <blockquote><pre>
  Class.forName("Foo", true, this.getClass().getClassLoader())
 </pre></blockquote>

 注意，此方法会抛出与加载、链接或初始化相关的错误，<em>Java Language Specification</em> 的第 12.2、12.3 和 12.4 节对此进行了详细说明。
 注意，此方法不检查调用者是否可访问其请求的类。

<p> 如果 <code>loader</code> 为 <code>null</code>，也存在安全管理器，并且调用者的类加载器不为 null，则此方法通过 <code>RuntimePermission("getClassLoader")</code> 权限调用安全管理器的 <code>checkPermission</code> 方法，以确保可以访问引导类加载器。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 所需类的完全限定名<DD><CODE>initialize</CODE> - 是否必须初始化类<DD><CODE>loader</CODE> - 用于加载类的类加载器
<DT><B>返回：</B><DD>表示所需类的类对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/LinkageError.html" title="java.lang 中的类">LinkageError</A></CODE> - 如果链接失败
<DD><CODE><A HREF="../../java/lang/ExceptionInInitializerError.html" title="java.lang 中的类">ExceptionInInitializerError</A></CODE> - 如果该方法激发的初始化失败
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></CODE> - 如果指定的类加载器无法定位该类<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Class.html#forName(java.lang.String)"><CODE>forName(String)</CODE></A>, 
<A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类"><CODE>ClassLoader</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="newInstance()"><!-- --></A><H3>
newInstance</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A> <B>newInstance</B>()
              throws <A HREF="../../java/lang/InstantiationException.html" title="java.lang 中的类">InstantiationException</A>,
                     <A HREF="../../java/lang/IllegalAccessException.html" title="java.lang 中的类">IllegalAccessException</A></PRE>
<DL>
<DD>创建此 <tt>Class</tt> 对象所表示的类的一个新实例。如同用一个带有一个空参数列表的 <code>new</code> 表达式实例化该类。如果该类尚未初始化，则初始化这个类。

<p>注意，此方法传播 null 构造方法所抛出的任何异常，包括已检查的异常。使用此方法可以有效地绕过编译时的异常检查，而在其他情况下编译器都会执行该检查。
 <A HREF="../../java/lang/reflect/Constructor.html#newInstance(java.lang.Object...)"><CODE>Constructor.newInstance</CODE></A> 方法将该构造方法所抛出的任何异常包装在一个（已检查的）<A HREF="../../java/lang/reflect/InvocationTargetException.html" title="java.lang.reflect 中的类"><CODE>InvocationTargetException</CODE></A> 中，从而避免了这一问题。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此对象所表示的类的一个新分配的实例。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalAccessException.html" title="java.lang 中的类">IllegalAccessException</A></CODE> - 如果该类或其 null 构造方法是不可访问的。
<DD><CODE><A HREF="../../java/lang/InstantiationException.html" title="java.lang 中的类">InstantiationException</A></CODE> - 如果此 <code>Class</code> 表示一个抽象类、接口、数组类、基本类型或 void；
             或者该类没有 null 构造方法；
             或者由于其他某种原因导致实例化失败。
<DD><CODE><A HREF="../../java/lang/ExceptionInInitializerError.html" title="java.lang 中的类">ExceptionInInitializerError</A></CODE> - 如果该方法引发的初始化失败。
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.PUBLIC)</CODE></A></tt> 拒绝创建该类的新实例

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul></DL>
</DD>
</DL>
<HR>

<A NAME="isInstance(java.lang.Object)"><!-- --></A><H3>
isInstance</H3>
<PRE>
public boolean <B>isInstance</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</PRE>
<DL>
<DD>判定指定的 <code>Object</code> 是否与此 <code>Class</code> 所表示的对象赋值兼容。此方法是 Java 语言 <code>instanceof</code> 运算符的动态等效方法。如果指定的 <code>Object</code> 参数非空，且能够在不引发 <code>ClassCastException</code> 的情况下被强制转换成该 <code>Class</code> 对象所表示的引用类型，则该方法返回 true；否则返回 <code>false</code>。

<p> 特别地，当该 <code>Class</code> 对象表示一个已声明的类时，若指定的 <code>Object</code> 参数是所表示类（或其任一子类）的一个实例，则此方法返回 <code>true</code>；否则返回 <code>false</code>。如果此 <code>Class</code> 对象表示一个数组类，且通过身份转换或扩展引用转换，指定的 <code>Object</code> 参数能转换为一个数组类的对象，则返回 <code>true</code>；否则返回 <code>false</code>。如果此 <code>Class</code> 对象表示一个接口，且指定 <code>Object</code> 参数的类或任一超类实现了此接口，则此方法返回 <code>true</code>；否则返回 <code>false</code>。如果此 <code>Class</code> 对象表示一个基本类型，则此方法返回 <code>false</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 要检查的对象
<DT><B>返回：</B><DD>如果 <code>obj</code> 是此类的实例，则返回 true<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isAssignableFrom(java.lang.Class)"><!-- --></A><H3>
isAssignableFrom</H3>
<PRE>
public boolean <B>isAssignableFrom</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;cls)</PRE>
<DL>
<DD>判定此 <code>Class</code> 对象所表示的类或接口与指定的 <code>Class</code> 参数所表示的类或接口是否相同，或是否是其超类或超接口。如果是则返回 <code>true</code>；否则返回 <code>false</code>。如果该 <code>Class</code> 表示一个基本类型，且指定的 <code>Class</code> 参数正是该 <code>Class</code> 对象，则该方法返回 <code>true</code>；否则返回 <code>false</code>。

<p> 特别地，通过身份转换或扩展引用转换，此方法能测试指定 <code>Class</code> 参数所表示的类型能否转换为此 <code>Class</code> 对象所表示的类型。有关详细信息，请参阅 <em>Java Language Specification</em> 的第 5.1.1 和 5.1.4 节。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>cls</CODE> - 要检查的 <code>Class</code> 对象
<DT><B>返回：</B><DD>表明 <code>cls</code> 类型的对象能否赋予此类对象的 <code>boolean</code> 值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果指定的 Class 参数为 null。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isInterface()"><!-- --></A><H3>
isInterface</H3>
<PRE>
public boolean <B>isInterface</B>()</PRE>
<DL>
<DD>判定指定的 <code>Class</code> 对象是否表示一个接口类型。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果此对象表示一个接口，则返回 <code>true</code>；否则返回 <code>false</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="isArray()"><!-- --></A><H3>
isArray</H3>
<PRE>
public boolean <B>isArray</B>()</PRE>
<DL>
<DD>判定此 <code>Class</code> 对象是否表示一个数组类。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果此对象表示一个数组类，则返回 <code>true</code>；否则返回 <code>false</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isPrimitive()"><!-- --></A><H3>
isPrimitive</H3>
<PRE>
public boolean <B>isPrimitive</B>()</PRE>
<DL>
<DD>判定指定的 <code>Class</code> 对象是否表示一个基本类型。

<p> 有九种预定义的 <code>Class</code> 对象，表示八个基本类型和 void。这些类对象由 Java 虚拟机创建，与其表示的基本类型同名，即 <code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code> 和 <code>double</code>。

<p> 这些对象仅能通过下列声明为 public static final 的变量访问，也是使此方法返回 <code>true</code> 的仅有的几个 <code>Class</code> 对象。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当该类表示一个基本类型时，才返回 true<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Boolean.html#TYPE"><CODE>Boolean.TYPE</CODE></A>, 
<A HREF="../../java/lang/Character.html#TYPE"><CODE>Character.TYPE</CODE></A>, 
<A HREF="../../java/lang/Byte.html#TYPE"><CODE>Byte.TYPE</CODE></A>, 
<A HREF="../../java/lang/Short.html#TYPE"><CODE>Short.TYPE</CODE></A>, 
<A HREF="../../java/lang/Integer.html#TYPE"><CODE>Integer.TYPE</CODE></A>, 
<A HREF="../../java/lang/Long.html#TYPE"><CODE>Long.TYPE</CODE></A>, 
<A HREF="../../java/lang/Float.html#TYPE"><CODE>Float.TYPE</CODE></A>, 
<A HREF="../../java/lang/Double.html#TYPE"><CODE>Double.TYPE</CODE></A>, 
<A HREF="../../java/lang/Void.html#TYPE"><CODE>Void.TYPE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isAnnotation()"><!-- --></A><H3>
isAnnotation</H3>
<PRE>
public boolean <B>isAnnotation</B>()</PRE>
<DL>
<DD>如果此 <tt>Class</tt> 对象表示一个注释类型则返回 true。注意，如果此方法返回 true，则 <A HREF="../../java/lang/Class.html#isInterface()"><CODE>isInterface()</CODE></A> 也返回 true，因为所有的注释类型同时也是接口。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果此类对象表示一个注释类型，则返回 <tt>true</tt>；否则返回 <tt>false</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isSynthetic()"><!-- --></A><H3>
isSynthetic</H3>
<PRE>
public boolean <B>isSynthetic</B>()</PRE>
<DL>
<DD>如果此类是复合类，则返回 <tt>true</tt>，否则 <tt>false</tt>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当该类为复合类时才返回 <tt>true</tt>，Java 语言规范对此作了详细说明。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getName()"><!-- --></A><H3>
getName</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getName</B>()</PRE>
<DL>
<DD>以 <tt>String</tt> 的形式返回此 <tt>Class</tt> 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。
 
 <p> 如果此类对象表示的是非数组类型的引用类型，则返回该类的二进制名称，Java Language Specification, Second Edition 对此作了详细说明。

 <p> 如果此类对象表示一个基本类型或 void，则返回的名字是一个与该基本类型或 void 所对应的 Java 语言关键字相同的 <tt>String</tt>。
 
 <p> 如果此类对象表示一个数组类，则名字的内部形式为：表示该数组嵌套深度的一个或多个 '<tt>[</tt>' 字符加元素类型名。元素类型名的编码如下：

 <blockquote><table summary="Element types and encodings">
 <tr><th> Element Type <th> &nbsp;&nbsp;&nbsp; <th> Encoding
 <tr><td> boolean      <td> &nbsp;&nbsp;&nbsp; <td align=center> Z
 <tr><td> byte         <td> &nbsp;&nbsp;&nbsp; <td align=center> B
 <tr><td> char         <td> &nbsp;&nbsp;&nbsp; <td align=center> C
 <tr><td> class or interface  
                       <td> &nbsp;&nbsp;&nbsp; <td align=center> L<i>classname</i>;
 <tr><td> double       <td> &nbsp;&nbsp;&nbsp; <td align=center> D
 <tr><td> float        <td> &nbsp;&nbsp;&nbsp; <td align=center> F
 <tr><td> int          <td> &nbsp;&nbsp;&nbsp; <td align=center> I
 <tr><td> long         <td> &nbsp;&nbsp;&nbsp; <td align=center> J
 <tr><td> short        <td> &nbsp;&nbsp;&nbsp; <td align=center> S
 </table></blockquote>

<p> 类或接口名 <i>classname</i> 是上面指定类的二进制名称。

<p> 示例：
 <blockquote><pre>
 String.class.getName()
     returns "java.lang.String"
 byte.class.getName()
     returns "byte"
 (new Object[3]).getClass().getName()
     returns "[Ljava.lang.Object;"
 (new int[3][4][5][6][7][8][9]).getClass().getName()
     returns "[[[[[[[I"
 </pre></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此对象所表示的类或接口名。</DL>
</DD>
</DL>
<HR>

<A NAME="getClassLoader()"><!-- --></A><H3>
getClassLoader</H3>
<PRE>
public <A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A> <B>getClassLoader</B>()</PRE>
<DL>
<DD>返回该类的类加载器。有些实现可能使用 null 来表示引导类加载器。如果该类由引导类加载器加载，则此方法在这类实现中将返回 null。

<p> 如果存在安全管理器，并且调用者的类加载器不是 null，也不同于或是请求其类加载器的类的类加载器的祖先，则此方法通过 <code>RuntimePermission("getClassLoader")</code> 权限调用此安全管理器的 <code>checkPermission</code> 方法，以确保可以访问该类的类加载器。
 
<p>如果此对象表示一个基本类型或 void，则返回 null。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>加载此对象所表示的类或接口的类加载器。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器，并且 <code>checkPermission</code> 方法拒绝对该类类加载器的访问。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类"><CODE>ClassLoader</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>, 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTypeParameters()"><!-- --></A><H3>
getTypeParameters</H3>
<PRE>
public <A HREF="../../java/lang/reflect/TypeVariable.html" title="java.lang.reflect 中的接口">TypeVariable</A>&lt;<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;<A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A>&gt;&gt;[] <B>getTypeParameters</B>()</PRE>
<DL>
<DD>按声明顺序返回 <tt>TypeVariable</tt> 对象的一个数组，这些对象表示用此 <tt>GenericDeclaration</tt> 对象所表示的常规声明来声明的类型变量。如果底层常规声明不声明类型变量，则返回长度为 0 的数组。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/lang/reflect/GenericDeclaration.html" title="java.lang.reflect 中的接口">GenericDeclaration</A></CODE> 中的 <CODE><A HREF="../../java/lang/reflect/GenericDeclaration.html#getTypeParameters()">getTypeParameters</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示该常规声明所声明的类型变量的 <tt>TypeVariable</tt> 对象的一个数组
<DT><B>抛出：</B>
<DD><CODE>GenericSignatureFormatError</CODE> - 如果常规声明的常规签名不符合 Java Virtual Machine Specification, 3rd edition 规定的格式<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSuperclass()"><!-- --></A><H3>
getSuperclass</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;? super <A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A>&gt; <B>getSuperclass</B>()</PRE>
<DL>
<DD>返回表示此 <code>Class</code> 所表示的实体（类、接口、基本类型或 void）的超类的 <code>Class</code>。如果此 <code>Class</code> 表示 <code>Object</code> 类、一个接口、一个基本类型或 void，则返回 null。如果此对象表示一个数组类，则返回表示该 <code>Object</code> 类的 <code>Class</code> 对象。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此对象所表示的类的超类。</DL>
</DD>
</DL>
<HR>

<A NAME="getGenericSuperclass()"><!-- --></A><H3>
getGenericSuperclass</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Type.html" title="java.lang.reflect 中的接口">Type</A> <B>getGenericSuperclass</B>()</PRE>
<DL>
<DD>返回表示此 <tt>Class</tt> 所表示的实体（类、接口、基本类型或 void）的直接超类的 <tt>Type</tt>。
 
<p>如果超类是参数化类型，则返回的 <tt>Type</tt> 
对象必须准确反映源代码中所使用的实际类型参数。如果以前未曾创建表示超类的参数化类型，则创建这个类型。有关参数化类型创建过程的语义，请参阅 <A HREF="../../java/lang/reflect/ParameterizedType.html" title="java.lang.reflect 中的接口"><CODE>ParameterizedType</CODE></A> 声明。如果此 <tt>Class</tt> 表示 <tt>Object</tt>
 类、接口、基本类型或 void，则返回 null。如果此对象表示一个数组类，则返回表示 <tt>Object</tt> 类的 <tt>Class</tt> 对象。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此对象所表示的类的超类
<DT><B>抛出：</B>
<DD><CODE>GenericSignatureFormatError</CODE> - 如果常规类签名不符合 Java Virtual Machine Specification, 3rd edition 规定的格式
<DD><CODE><A HREF="../../java/lang/TypeNotPresentException.html" title="java.lang 中的类">TypeNotPresentException</A></CODE> - 如果常规超类引用不存在的类型声明
<DD><CODE>MalformedParameterizedTypeException</CODE> - 如果常规超类引用的参数化类型由于某种原因无法实例化<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPackage()"><!-- --></A><H3>
getPackage</H3>
<PRE>
public <A HREF="../../java/lang/Package.html" title="java.lang 中的类">Package</A> <B>getPackage</B>()</PRE>
<DL>
<DD>获取此类的包。此类的类加载器用于查找该包。如果该类是通过引导类加载器加载的，则搜索从 CLASSPATH 加载的包的集合，以查找该类的包。如果所有包对象都不是用该类的类加载器加载的，则返回 null。

 <p> 只有该类的附属清单中定义了信息，并且类加载器使用该清单中的属性创建了包实例时，包才具有版本和规范属性。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该类的包，如果存档或基本代码中没有可用的包信息，则返回 null。</DL>
</DD>
</DL>
<HR>

<A NAME="getInterfaces()"><!-- --></A><H3>
getInterfaces</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;[] <B>getInterfaces</B>()</PRE>
<DL>
<DD>确定此对象所表示的类或接口实现的接口。

<p> 如果此对象表示一个类，则返回值是一个数组，它包含了表示该类所实现的所有接口的对象。数组中接口对象顺序与此对象所表示的类的声明的 <code>implements</code> 子句中接口名顺序一致。例如，给定声明：
 <blockquote><pre>
 class Shimmer implements FloorWax, DessertTopping { ... }
</pre></blockquote>
 设 <code>s</code> 的值为 <code>Shimmer</code> 的一个实例；表达式：
 <blockquote><pre>
 s.getClass().getInterfaces()[0]
 </pre></blockquote>
 的值为表示 <code>FloorWax</code> 接口的 <code>Class</code> 对象；
 <blockquote><pre>
 s.getClass().getInterfaces()[1]
 </pre></blockquote>
 的值为表示 <code>DessertTopping</code> 接口的 <code>Class</code> 对象。

<p> 如果此对象表示一个接口，则该数组包含表示该接口扩展的所有接口的对象。数组中接口对象顺序与此对象所表示的接口的声明的 <code>extends</code> 子句中接口名顺序一致。

<p>如果此对象表示一个不实现任何接口的类或接口，则此方法返回一个长度为 0 的数组。

<p> 如果此对象表示一个基本类型或 void，则此方法返回一个长度为 0 的数组。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该类所实现的接口的一个数组。</DL>
</DD>
</DL>
<HR>

<A NAME="getGenericInterfaces()"><!-- --></A><H3>
getGenericInterfaces</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Type.html" title="java.lang.reflect 中的接口">Type</A>[] <B>getGenericInterfaces</B>()</PRE>
<DL>
<DD>返回表示某些接口的 <tt>Type</tt>，这些接口由此对象所表示的类或接口直接实现。

<p>如果超接口是参数化类型，则为它返回的 <tt>Type</tt> 对象必须准确反映源代码中所使用的实际类型参数。如果以前未曾创建表示每个超接口的参数化类型，则创建这个类型。有关参数化类型创建过程的语义，请参阅 <A HREF="../../java/lang/reflect/ParameterizedType.html" title="java.lang.reflect 中的接口"><CODE>ParameterizedType</CODE></A> 声明。

<p> 如果此对象表示一个类，则返回一个包含这样一些对象的数组，这些对象表示该类实现的所有接口。数组中接口对象顺序与此对象所表示的类的声明的 <tt>implements</tt> 子句中接口名顺序一致。对于数组类，接口 <tt>Cloneable</tt> 和 <tt>Serializable</tt> 以该顺序返回。

<p>如果此对象表示一个接口，则该数组包含表示该接口直接扩展的所有接口的对象。数组中接口对象顺序与此对象所表示的接口的声明的 <code>extends</code> 子句中接口名顺序一致。

<p>如果此对象表示一个不实现任何接口的类或接口，则此方法返回一个长度为 0 的数组。

<p>如果此对象表示一个基本类型或 void，则此方法返回一个长度为 0 的数组。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此类所实现的接口的一个数组
<DT><B>抛出：</B>
<DD><CODE>GenericSignatureFormatError</CODE> - 如果常规类签名不符合 Java Virtual Machine Specification, 3rd edition 规定的格式
<DD><CODE><A HREF="../../java/lang/TypeNotPresentException.html" title="java.lang 中的类">TypeNotPresentException</A></CODE> - 如果任意常规超接口引用不存在的类型声明
<DD><CODE>MalformedParameterizedTypeException</CODE> - 如果任意常规超接口引用的参数化类型由于某种原因无法实例化<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getComponentType()"><!-- --></A><H3>
getComponentType</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>getComponentType</B>()</PRE>
<DL>
<DD>返回表示数组组件类型的 <code>Class</code>。如果此类不表示数组类，则此方法返回 null。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果此类是数组，则返回表示此类组件类型的 <code>Class</code><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/reflect/Array.html" title="java.lang.reflect 中的类"><CODE>Array</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getModifiers()"><!-- --></A><H3>
getModifiers</H3>
<PRE>
public int <B>getModifiers</B>()</PRE>
<DL>
<DD>返回此类或接口以整数编码的 Java 语言修饰符。修饰符由 Java 虚拟机的 <code>public</code>、<code>protected</code>、<code>private</code>、<code>final</code>、<code>static</code>、<code>abstract</code> 和 <code>interface</code> 对应的常量组成；它们应当使用 <code>Modifier</code> 类的方法来解码。

<p> 如果底层类是数组类，则其 <code>public</code>、<code>private</code> 和 <code>protected</code> 修饰符与其组件类型的修饰符相同。如果此 <code>Class</code> 表示一个基本类型或 void，则其 <code>public</code> 修饰符始终为 <code>true</code>，<code>protected</code> 和 <code>private</code> 修饰符始终为 <code>false</code>。如果此对象表示一个数组类、一个基本类型或 void，则其 <code>final</code> 修饰符始终为 <code>true</code>，其接口修饰符始终为 <code>false</code>。该规范没有给定其他修饰符的值。

 <p><em>Java Virtual Machine Specification</em> 中的表 4.1 对修饰符编码进行了详细说明。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示该类修饰符的 <code>int</code><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/reflect/Modifier.html" title="java.lang.reflect 中的类"><CODE>Modifier</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getSigners()"><!-- --></A><H3>
getSigners</H3>
<PRE>
public <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>[] <B>getSigners</B>()</PRE>
<DL>
<DD>获取此类的标记。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此类的标记，若无标记则返回 null。特别地，如果此对象表示一个基本类型或 void，则此方法返回 null。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getEnclosingMethod()"><!-- --></A><H3>
getEnclosingMethod</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类">Method</A> <B>getEnclosingMethod</B>()</PRE>
<DL>
<DD>如果此 <tt>Class</tt> 对象表示某一方法中的一个本地或匿名类，则返回 <A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类"><CODE>Method</CODE></A> 对象，它表示底层类的立即封闭方法。否则返回 <tt>null</tt>。

特别地，如果底层类是由一个类型声明、实例初始值设定项或静态初始值设定项立即封闭的本地或匿名类，则此方法返回 <tt>null</tt>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果该类是本地或匿名类，则返回底层类的立即封闭方法；否则返回 <tt>null</tt>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getEnclosingConstructor()"><!-- --></A><H3>
getEnclosingConstructor</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类">Constructor</A>&lt;?&gt; <B>getEnclosingConstructor</B>()</PRE>
<DL>
<DD>如果该 <tt>Class</tt> 对象表示构造方法中的一个本地或匿名类，则返回 <A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类"><CODE>Constructor</CODE></A> 对象，它表示底层类的立即封闭构造方法。否则返回 <tt>null</tt>。特别地，如果底层类是由一个类型声明、实例初始值设定项或静态初始值设定项立即封闭的本地或匿名类，则此方法返回 <tt>null</tt>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果该类是本地或匿名类，则返回底层类的立即封闭构造方法；否则返回 <tt>null</tt>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDeclaringClass()"><!-- --></A><H3>
getDeclaringClass</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>getDeclaringClass</B>()</PRE>
<DL>
<DD>如果此 <code>Class</code> 对象所表示的类或接口是另一个类的成员，则返回的 <code>Class</code> 对象表示该对象的声明类。如果该类或接口不是其他类的成员，则此方法返回 null。如果此 <code>Class</code> 对象表示一个数组类、基本类型或 void，则此方法返回 null。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该类的声明类<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getEnclosingClass()"><!-- --></A><H3>
getEnclosingClass</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt; <B>getEnclosingClass</B>()</PRE>
<DL>
<DD>返回底层类的立即封闭类。如果底层类是顶层类，则此方法返回 <tt>null</tt>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>底层类的立即封闭类<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSimpleName()"><!-- --></A><H3>
getSimpleName</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getSimpleName</B>()</PRE>
<DL>
<DD>返回源代码中给出的底层类的简称。如果底层类是匿名的则返回一个空字符串。

<p>数组的简称即附带 "[]" 的组件类型的简称。特别地，组件类型为匿名的数组的简称是 "[]"。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>底层类的简称<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCanonicalName()"><!-- --></A><H3>
getCanonicalName</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getCanonicalName</B>()</PRE>
<DL>
<DD>返回 Java Language Specification 中所定义的底层类的规范化名称。如果底层类没有规范化名称（即如果底层类是一个组件类型没有规范化名称的本地类、匿名类或数组），则返回 null。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>底层类的规范化名称（如果存在的话）；否则返回 <tt>null</tt>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isAnonymousClass()"><!-- --></A><H3>
isAnonymousClass</H3>
<PRE>
public boolean <B>isAnonymousClass</B>()</PRE>
<DL>
<DD>当且仅当底层类是匿名类时返回 <tt>true</tt>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当此类是匿名类时，才返回 <tt>true</tt>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isLocalClass()"><!-- --></A><H3>
isLocalClass</H3>
<PRE>
public boolean <B>isLocalClass</B>()</PRE>
<DL>
<DD>当且仅当底层类是本地类时返回 <tt>true</tt>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当该类是本地类时，才返回 <tt>true</tt>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isMemberClass()"><!-- --></A><H3>
isMemberClass</H3>
<PRE>
public boolean <B>isMemberClass</B>()</PRE>
<DL>
<DD>当且仅当底层类是成员类时返回 <tt>true</tt>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当该类是成员类时，才返回 <tt>true</tt>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getClasses()"><!-- --></A><H3>
getClasses</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;[] <B>getClasses</B>()</PRE>
<DL>
<DD>返回一个包含某些 <code>Class</code> 对象的数组，这些对象表示属于此 <code>Class</code> 对象所表示的类的成员的所有公共类和接口。包括从超类继承的公共类和接口成员以及该类声明的公共类和接口成员。如果此 <code>Class</code> 对象没有公共成员类或接口，则此方法返回一个长度为 0 的数组。如果此 <code>Class</code> 对象表示一个基本类型、一个数组类或 void，则此方法也返回一个长度为 0 的数组。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示该类公共成员的 <code>Class</code> 对象的数组
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.PUBLIC)</CODE></A></tt> 方法拒绝访问该类中的类

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getFields()"><!-- --></A><H3>
getFields</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Field.html" title="java.lang.reflect 中的类">Field</A>[] <B>getFields</B>()
                  throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回一个包含某些 <code>Field</code> 对象的数组，这些对象反映此 <code>Class</code> 对象所表示的类或接口的所有可访问公共字段。返回数组中的元素没有排序，也没有任何特定的顺序。如果类或接口没有可访问的公共字段，或者表示一个数组类、一个基本类型或 void，则此方法返回长度为 0 的数组。

<p> 特别地，如果该 <code>Class</code> 对象表示一个类，则此方法返回该类及其所有超类的公共字段。如果该 <code>Class</code> 对象表示一个接口，则此方法返回该接口及其所有超接口的公共字段。

<p> 该方法不反映数组类的隐式长度字段。用户代码应使用 <code>Array</code> 类的方法来操作数组。

<p> 请参阅 <em>Java Language Specification</em> 的第 8.2 和 8.3 节。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示公共字段的 <code>Field</code> 对象的数组
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.PUBLIC)</CODE></A></tt> 拒绝访问该类中的字段

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMethods()"><!-- --></A><H3>
getMethods</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类">Method</A>[] <B>getMethods</B>()
                    throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回一个包含某些 <code>Method</code> 对象的数组，这些对象反映此 <code>Class</code> 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 <em>member</em> 方法。数组类返回从 <code>Object</code> 类继承的所有（公共）member 方法。返回数组中的元素没有排序，也没有任何特定的顺序。如果此 <code>Class</code> 对象表示没有公共成员方法的类或接口，或者表示一个基本类型或 void，则此方法返回长度为 0 的数组。

 <p> 类初始化方法 <code>&lt;clinit&gt;</code> 不包含在返回的数组中。如果类声明了带有相同参数类型的多个公共成员方法，则它们都会包含在返回的数组中。

 <p> 请参阅 <em>Java Language Specification</em> 的第 8.2 和 8.4 节。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示此类中公共方法的 <code>Method</code> 对象的数组
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.PUBLIC)</CODE></A></tt> 拒绝访问该类中的方法

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getConstructors()"><!-- --></A><H3>
getConstructors</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类">Constructor</A>&lt;?&gt;[] <B>getConstructors</B>()
                                 throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回一个包含某些 <code>Constructor</code> 对象的数组，这些对象反映此 <code>Class</code> 对象所表示的类的所有公共构造方法。如果该类没有公共构造方法，或者该类是一个数组类，或者该类反映一个基本类型或 void，则返回一个长度为 0 的数组。

注意，此方法返回 <code>Constructor&lt;T&gt;</code> 对象的数组（即取自此类构造方法的数组）时，此方法的返回类型是 <code>Constructor&lt;?&gt;[]</code>，<em>不是</em> 预期的 <code>Constructor&lt;T&gt;[]</code>。此少量信息的返回类型是必需的，因为从此方法返回之后，该数组可能被修改以保存不同类的 <code>Constructor</code> 对象，而这将违反 <code>Constructor&lt;T&gt;[]</code> 的类型保证。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示此类公共构造方法的 <code>Constructor</code> 对象数组
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.PUBLIC)</CODE></A></tt> 拒绝访问该类中的构造方法

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getField(java.lang.String)"><!-- --></A><H3>
getField</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Field.html" title="java.lang.reflect 中的类">Field</A> <B>getField</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
               throws <A HREF="../../java/lang/NoSuchFieldException.html" title="java.lang 中的类">NoSuchFieldException</A>,
                      <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回一个 <code>Field</code> 对象，它反映此 <code>Class</code> 对象所表示的类或接口的指定公共成员字段。<code>name</code> 参数是一个 <code>String</code>，用于指定所需字段的简称。

 <p> 要反映的字段由下面的算法确定。设 C 为此对象所表示的类：
 <OL>
 <LI> 如果 C 声明一个带有指定名的公共字段，则它就是要反映的字段。</LI>
 <LI> 如果在第 1 步中没有找到任何字段，则该算法被递归地应用于 C 的每一个直接超接口。直接超接口按其声明顺序进行搜索。</LI>
 <LI> 如果在第 1、2 两步没有找到任何字段，且 C 有一个超类 S，则在 S 上递归调用该算法。如果 C 没有超类，则抛出 <code>NoSuchFieldException</code>。
 </OL>

 <p> 请参阅 <em>Java Language Specification</em> 的第 8.2 和 8.3 节。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 字段名
<DT><B>返回：</B><DD>由 <code>name</code> 指定的该类的 <code>Field</code> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NoSuchFieldException.html" title="java.lang 中的类">NoSuchFieldException</A></CODE> - 如果没有找到带有指定名的字段。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>name</code> 为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.PUBLIC)</CODE></A></tt> 拒绝访问字段

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMethod(java.lang.String, java.lang.Class...)"><!-- --></A><H3>
getMethod</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类">Method</A> <B>getMethod</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                        <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;...&nbsp;parameterTypes)
                 throws <A HREF="../../java/lang/NoSuchMethodException.html" title="java.lang 中的类">NoSuchMethodException</A>,
                        <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回一个 <code>Method</code> 对象，它反映此 <code>Class</code> 对象所表示的类或接口的指定公共成员方法。<code>name</code> 参数是一个 <code>String</code>，用于指定所需方法的简称。<code>parameterTypes</code> 参数是按声明顺序标识该方法形参类型的 <code>Class</code> 对象的一个数组。如果 <code>parameterTypes</code> 为 <code>null</code>，则按空数组处理。

<p> 如果 <code>name</code> 是 "<code>&lt;init&gt;</code>;" 或 "<code>&lt;clinit&gt;</code>"，则将引发 <code>NoSuchMethodException</code>。否则，要反映的方法由下面的算法确定（设 C 为此对象所表示的类）：
 <OL>
 <LI> 在 C 中搜索任一<I>匹配的方法</I>。如果找不到匹配的方法，则将在 C 的超类上递归调用第 1 步算法。</LI>
 <LI> 如果在第 1 步中没有找到任何方法，则在 C 的超接口中搜索匹配的方法。如果找到了这样的方法，则反映该方法。</LI>
 </OL>

在 C 类中查找匹配的方法：如果 C 正好声明了一个具有指定名称的公共方法并且恰恰有相同的形参类型，则它就是反映的方法。如果在 C 中找到了多个这样的方法，并且其中有一个方法的返回类型比其他方法的返回类型都特殊，则反映该方法；否则将从中任选一个方法。

<p>注意，类中可以有多个匹配方法，因为尽管 Java 语言禁止类声明带有相同签名但不同返回类型的多个方法，但 Java 虚拟机并不禁止。这增加了虚拟机的灵活性，可以用来实现各种语言特性。例如，可以使用<A HREF="../../java/lang/reflect/Method.html#isBridge()">桥方法 (brige method)</A>实现协变返回；桥方法以及将被重写的方法将具有相同的签名，不同的返回类型。

 <p> 请参阅<em>Java 语言规范</em> 第 8.2 和 8.4 节。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 方法名<DD><CODE>parameterTypes</CODE> - 参数列表
<DT><B>返回：</B><DD>与指定的 <code>name</code> 和 <code>parameterTypes</code> 匹配的 <code>Method</code> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NoSuchMethodException.html" title="java.lang 中的类">NoSuchMethodException</A></CODE> - 如果找不到匹配的方法，或者方法名为 "&lt;init&gt;" 或 "&lt;clinit&gt;"
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>name</code> 为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.PUBLIC)</CODE></A></tt> 拒绝访问方法

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getConstructor(java.lang.Class...)"><!-- --></A><H3>
getConstructor</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类">Constructor</A>&lt;<A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A>&gt; <B>getConstructor</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;...&nbsp;parameterTypes)
                              throws <A HREF="../../java/lang/NoSuchMethodException.html" title="java.lang 中的类">NoSuchMethodException</A>,
                                     <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回一个 <code>Constructor</code> 对象，它反映此 <code>Class</code> 对象所表示的类的指定公共构造方法。<code>parameterTypes</code> 参数是 <code>Class</code> 对象的一个数组，这些 Class 对象按声明顺序标识构造方法的形参类型。

如果此 <code>Class</code> 对象表示非静态上下文中声明的内部类，则形参类型作为第一个参数包括显示封闭的实例。

<p> 要反映的构造方法是此 <code>Class</code> 对象所表示的类的公共构造方法，其形参类型与 <code>parameterTypes</code> 所指定的参数类型相匹配。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>parameterTypes</CODE> - 参数数组
<DT><B>返回：</B><DD>与指定的 <code>parameterTypes</code> 相匹配的公共构造方法的 <code>Constructor</code> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NoSuchMethodException.html" title="java.lang 中的类">NoSuchMethodException</A></CODE> - 如果找不到匹配的方法。
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.PUBLIC)</CODE></A></tt> 拒绝访问构造方法

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDeclaredClasses()"><!-- --></A><H3>
getDeclaredClasses</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;[] <B>getDeclaredClasses</B>()
                              throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回 <code>Class</code> 对象的一个数组，这些对象反映声明为此 <code>Class</code> 对象所表示的类的成员的所有类和接口。包括该类所声明的公共、保护、默认（包）访问及私有类和接口，但不包括继承的类和接口。如果该类不将任何类或接口声明为成员，或者此 <code>Class</code> 对象表示基本类型、数组类或 void，则此方法返回一个长度为 0 的数组。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD><code>Class</code> 对象的数组，表示该类的所有 declared 成员
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.DECLARED)</CODE></A></tt> 拒绝访问此类中已声明的类

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问此类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDeclaredFields()"><!-- --></A><H3>
getDeclaredFields</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Field.html" title="java.lang.reflect 中的类">Field</A>[] <B>getDeclaredFields</B>()
                          throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回 <code>Field</code> 对象的一个数组，这些对象反映此 <code>Class</code> 对象所表示的类或接口所声明的所有字段。包括公共、保护、默认（包）访问和私有字段，但不包括继承的字段。
返回数组中的元素没有排序，也没有任何特定的顺序。如果该类或接口不声明任何字段，或者此 <code>Class</code> 对象表示一个基本类型、一个数组类或 void，则此方法返回一个长度为 0 的数组。

<p> 请参阅 <em>Java Language Specification</em> 的第 8.2 和 8.3 节。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示此类所有已声明字段的 <code>Field</code> 对象的数组
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.DECLARED)</CODE></A></tt> 拒绝访问此类中已声明的字段

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDeclaredMethods()"><!-- --></A><H3>
getDeclaredMethods</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类">Method</A>[] <B>getDeclaredMethods</B>()
                            throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回 <code>Method</code> 对象的一个数组，这些对象反映此 <code>Class</code> 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。
返回数组中的元素没有排序，也没有任何特定的顺序。如果该类或接口不声明任何方法，或者此 <code>Class</code> 对象
表示一个基本类型、一个数组类或 void，则此方法返回一个长度为 0 的数组。类初始化方法 <code>&lt;clinit&gt;</code> 不包含在返回数组中。如果该类声明带有相同参数类型的多个公共成员方法，则它们都包含在返回的数组中。

 <p> 请参阅 <em>Java Language Specification</em> 第 8.2 节。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示此类所有声明方法的 <code>Method</code> 对象的数组
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.DECLARED)</CODE></A></tt> 拒绝访问该类中已声明的方法

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDeclaredConstructors()"><!-- --></A><H3>
getDeclaredConstructors</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类">Constructor</A>&lt;?&gt;[] <B>getDeclaredConstructors</B>()
                                         throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回 <code>Constructor</code> 对象的一个数组，这些对象反映此 <code>Class</code> 对象表示的类声明的所有构造方法。它们是公共、保护、默认（包）访问和私有构造方法。返回数组中的元素没有排序，也没有任何特定的顺序。如果该类存在一个默认构造方法，则它包含在返回的数组中。
如果此 <code>Class</code> 对象表示一个接口、一个基本类型、一个数组类或 void，则此方法返回一个长度为 0 的数组。

 <p> 请参阅 <em>Java Language Specification</em> 第 8.2 节。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>表示此类所有已声明的构造方法的 <code>Constructor</code> 对象的数组
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.DECLARED)</CODE></A></tt> 拒绝访问该类中已声明的构造方法

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问此类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDeclaredField(java.lang.String)"><!-- --></A><H3>
getDeclaredField</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Field.html" title="java.lang.reflect 中的类">Field</A> <B>getDeclaredField</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)
                       throws <A HREF="../../java/lang/NoSuchFieldException.html" title="java.lang 中的类">NoSuchFieldException</A>,
                              <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回一个 <code>Field</code> 对象，该对象反映此 <code>Class</code> 对象所表示的类或接口的指定已声明字段。<code>name</code> 参数是一个 <code>String</code>，它指定所需字段的简称。注意，此方法不反映数组类的 <code>length</code> 字段。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 字段名
<DT><B>返回：</B><DD>此类中指定字段的 <code>Field</code> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NoSuchFieldException.html" title="java.lang 中的类">NoSuchFieldException</A></CODE> - 如果找不到带有指定名称的字段。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>name</code> 为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.DECLARED)</CODE></A></tt> 拒绝访问已声明字段

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDeclaredMethod(java.lang.String, java.lang.Class...)"><!-- --></A><H3>
getDeclaredMethod</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Method.html" title="java.lang.reflect 中的类">Method</A> <B>getDeclaredMethod</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
                                <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;...&nbsp;parameterTypes)
                         throws <A HREF="../../java/lang/NoSuchMethodException.html" title="java.lang 中的类">NoSuchMethodException</A>,
                                <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回一个 <code>Method</code> 对象，该对象反映此 <code>Class</code> 对象所表示的类或接口的指定已声明方法。<code>name</code> 参数是一个 <code>String</code>，它指定所需方法的简称，<code>parameterTypes</code> 参数是 <code>Class</code> 对象的一个数组，它按声明顺序标识该方法的形参类型。如果在某个类中声明了带有相同参数类型的多个方法，并且其中有一个方法的返回类型比其他方法的返回类型都特殊，则返回该方法；否则将从中任选一个方法。如果名称是 "&lt;init&gt;” 或 “&lt;clinit&gt;"，则引发一个 <code>NoSuchMethodException</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 方法名<DD><CODE>parameterTypes</CODE> - 参数数组
<DT><B>返回：</B><DD>该类与指定名和参数相匹配的方法的 <code>Method</code> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NoSuchMethodException.html" title="java.lang 中的类">NoSuchMethodException</A></CODE> - 如果找不到匹配的方法。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>name</code> 为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.DECLARED)</CODE></A></tt> 拒绝访问已声明方法

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDeclaredConstructor(java.lang.Class...)"><!-- --></A><H3>
getDeclaredConstructor</H3>
<PRE>
public <A HREF="../../java/lang/reflect/Constructor.html" title="java.lang.reflect 中的类">Constructor</A>&lt;<A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A>&gt; <B>getDeclaredConstructor</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;...&nbsp;parameterTypes)
                                      throws <A HREF="../../java/lang/NoSuchMethodException.html" title="java.lang 中的类">NoSuchMethodException</A>,
                                             <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></PRE>
<DL>
<DD>返回一个 <code>Constructor</code> 对象，该对象反映此 <code>Class</code> 对象所表示的类或接口的指定构造方法。<code>parameterTypes</code> 参数是 <code>Class</code> 对象的一个数组，它按声明顺序标识构造方法的形参类型。

如果此 <code>Class</code> 对象表示非静态上下文中声明的内部类，则形参类型作为第一个参数包括显示封闭的实例。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>parameterTypes</CODE> - 参数数组
<DT><B>返回：</B><DD>带有指定参数列表的构造方法的 <code>Constructor</code> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NoSuchMethodException.html" title="java.lang 中的类">NoSuchMethodException</A></CODE> - 如果找不到匹配的方法。
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果存在安全管理器 <i>s</i>，并满足下列任一条件：

             <ul>

             <li> 调用 <tt><A HREF="../../java/lang/SecurityManager.html#checkMemberAccess(java.lang.Class, int)"><CODE>s.checkMemberAccess(this, Member.DECLARED)</CODE></A></tt> 拒绝访问已声明的构造方法

             <li> 调用者的类加载器不同于也不是当前类的类加载器的一个祖先，并且对 <tt><A HREF="../../java/lang/SecurityManager.html#checkPackageAccess(java.lang.String)"><CODE>s.checkPackageAccess()</CODE></A></tt> 的调用拒绝访问该类的包

             </ul><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getResourceAsStream(java.lang.String)"><!-- --></A><H3>
getResourceAsStream</H3>
<PRE>
public <A HREF="../../java/io/InputStream.html" title="java.io 中的类">InputStream</A> <B>getResourceAsStream</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>查找具有给定名称的资源。查找与给定类相关的资源的规则是通过定义类的 <A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">class loader</A> 实现的。此方法委托此对象的类加载器。如果此对象通过引导类加载器加载，则此方法将委托给 <A HREF="../../java/lang/ClassLoader.html#getSystemResourceAsStream(java.lang.String)"><CODE>ClassLoader.getSystemResourceAsStream(java.lang.String)</CODE></A>。

 <p> 在委托前，使用下面的算法从给定的资源名构造一个绝对资源名：

 <ul>

 <li> 如果 <tt>name</tt> 以 <tt>'/'</tt> 开始
 (<tt>'&#92;u002f'</tt>)，则绝对资源名是 <tt>'/'</tt> 后面的 <tt>name</tt> 的一部分。

 <li> 否则，绝对名具有以下形式：

 <blockquote><pre>
   <tt>modified_package_name</tt>/<tt>name</tt>
</pre></blockquote>

 <p> 其中 <tt>modified_package_name</tt> 是此对象的包名，该名用 <tt>'/'</tt> 取代了 <tt>'.'</tt> (<tt>'&#92;u002e'</tt>)。

 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 所需资源的名称
<DT><B>返回：</B><DD>一个 <A HREF="../../java/io/InputStream.html" title="java.io 中的类"><CODE>InputStream</CODE></A> 对象；如果找不到带有该名称的资源，则返回 <tt>null</tt>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>name</tt> 是 <tt>null</tt><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getResource(java.lang.String)"><!-- --></A><H3>
getResource</H3>
<PRE>
public <A HREF="../../java/net/URL.html" title="java.net 中的类">URL</A> <B>getResource</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>查找带有给定名称的资源。查找与给定类相关的资源的规则是通过定义类的 <A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">class loader</A> 实现的。此方法委托给此对象的类加载器。如果此对象通过引导类加载器加载，则此方法将委托给 <A HREF="../../java/lang/ClassLoader.html#getSystemResource(java.lang.String)"><CODE>ClassLoader.getSystemResource(java.lang.String)</CODE></A>。

 <p> 在委托前，使用下面的算法从给定的资源名构造一个绝对资源名：

 <ul>

 <li> 如果 <tt>name</tt> 以 <tt>'/'</tt>
 (<tt>'&#92;u002f'</tt>) 开始，则绝对资源名是 <tt>'/'</tt> 后面的 <tt>name</tt> 的一部分。

 <li> 否则，绝对名具有以下形式：

 <blockquote><pre>
   <tt>modified_package_name</tt>/<tt>name</tt>
</pre></blockquote>

 <p> 其中 <tt>modified_package_name</tt> 是此对象的包名，该名用 <tt>'/'</tt> 取代了 <tt>'.'</tt> (<tt>'&#92;u002e'</tt>)。

 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 所需资源的名称
<DT><B>返回：</B><DD>一个 <A HREF="../../java/net/URL.html" title="java.net 中的类"><CODE>URL</CODE></A> 对象；如果找不到带有该名称的资源，则返回 <tt>null</tt><DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getProtectionDomain()"><!-- --></A><H3>
getProtectionDomain</H3>
<PRE>
public <A HREF="../../java/security/ProtectionDomain.html" title="java.security 中的类">ProtectionDomain</A> <B>getProtectionDomain</B>()</PRE>
<DL>
<DD>返回该类的 <code>ProtectionDomain</code>。如果安装了安全管理器，则此方法首先通过 <code>RuntimePermission("getProtectionDomain")</code> 权限调用安全管理器的 <code>checkPermission</code> 方法，以确保可以获取 <code>ProtectionDomain</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该类的 ProtectionDomain
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 若安全管理器存在，并且其 <code>checkPermission</code> 方法不允许获取 ProtectionDomain。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/security/ProtectionDomain.html" title="java.security 中的类"><CODE>ProtectionDomain</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>, 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="desiredAssertionStatus()"><!-- --></A><H3>
desiredAssertionStatus</H3>
<PRE>
public boolean <B>desiredAssertionStatus</B>()</PRE>
<DL>
<DD>如果要在调用此方法时将要初始化该类，则返回将分配给该类的断言状态。
如果已经设置了该类的断言状态，则返回其最新设置；如果有包默认断言状态属于此类，则返回最特殊的相关包默认断言状态的最新设置；如果该类不是系统类（即它有类加载器），则返回其类加载器的默认断言状态；否则返回系统类默认断言状态。
<p>
很少有程序员需要此方法；它是为 JRE 自身提供的。（它使类能够在初始化时确定是否启用断言。）注意，不保证此方法在（或将要）初始化指定类时返回与（或将与）该指定类相关的实际断言状态。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>所需的指定类断言状态。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ClassLoader.html#setClassAssertionStatus(java.lang.String, boolean)"><CODE>ClassLoader.setClassAssertionStatus(java.lang.String, boolean)</CODE></A>, 
<A HREF="../../java/lang/ClassLoader.html#setPackageAssertionStatus(java.lang.String, boolean)"><CODE>ClassLoader.setPackageAssertionStatus(java.lang.String, boolean)</CODE></A>, 
<A HREF="../../java/lang/ClassLoader.html#setDefaultAssertionStatus(boolean)"><CODE>ClassLoader.setDefaultAssertionStatus(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isEnum()"><!-- --></A><H3>
isEnum</H3>
<PRE>
public boolean <B>isEnum</B>()</PRE>
<DL>
<DD>当且仅当该类声明为源代码中的枚举时返回 true。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当该类声明为源代码中的枚举时返回 true<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getEnumConstants()"><!-- --></A><H3>
getEnumConstants</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A>[] <B>getEnumConstants</B>()</PRE>
<DL>
<DD>如果此 Class 对象不表示枚举类型，则返回枚举类的元素或 null。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>以声明顺序返回一个数组，该数组包含构成此 Class 对象所表示的枚举类的值，或者在此 Class 对象不表示枚举类型时返回 null<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cast(java.lang.Object)"><!-- --></A><H3>
cast</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="Class 中的类型参数">T</A> <B>cast</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</PRE>
<DL>
<DD>将一个对象强制转换成此 <tt>Class</tt> 对象所表示的类或接口。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 要强制转换的对象
<DT><B>返回：</B><DD>强制转换返回该对象，若 obj 为 null 则返回 null
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类">ClassCastException</A></CODE> - 如果该对象不是 null 也不能分配给类型 T。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="asSubclass(java.lang.Class)"><!-- --></A><H3>
asSubclass</H3>
<PRE>
public &lt;U&gt; <A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;? extends U&gt; <B>asSubclass</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;U&gt;&nbsp;clazz)</PRE>
<DL>
<DD>强制转换该 <tt>Class</tt> 对象，以表示指定的 class 对象所表示的类的一个子类。检查强制转换的有效性，如果无效则抛出 <tt>ClassCastException</tt>。如果此方法成功了，它将始终返回对此 class 对象的一个引用。

<p>此方法的使用场合为：客户端需要“收缩转换” <tt>Class</tt> 对象的类型，以便将其传递给某个 API，且该 API 对它愿意接受的 <tt>Class</tt> 对象进行限制。强制转换会产生一个编译时警告，因为强制转换的正确性无法在运行时检查（因为常规类型是通过擦除实现的）。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <tt>Class</tt> 对象，它被强制转换以表示指定类对象的子类。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类">ClassCastException</A></CODE> - 如果该 <tt>Class</tt> 对象不表示指定类的子类（这里“子类”包括该类本身）。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAnnotation(java.lang.Class)"><!-- --></A><H3>
getAnnotation</H3>
<PRE>
public &lt;A extends <A HREF="../../java/lang/annotation/Annotation.html" title="java.lang.annotation 中的接口">Annotation</A>&gt; A <B>getAnnotation</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;A&gt;&nbsp;annotationClass)</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html#getAnnotation(java.lang.Class)">AnnotatedElement</A></CODE> 复制的描述</B></DD>
<DD>如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html" title="java.lang.reflect 中的接口">AnnotatedElement</A></CODE> 中的 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html#getAnnotation(java.lang.Class)">getAnnotation</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>annotationClass</CODE> - 对应于注释类型的 Class 对象
<DT><B>返回：</B><DD>如果该元素的指定注释类型的注释存在于此对象上，则返回这些注释，否则返回 null
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果给定的注释类为 null<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isAnnotationPresent(java.lang.Class)"><!-- --></A><H3>
isAnnotationPresent</H3>
<PRE>
public boolean <B>isAnnotationPresent</B>(<A HREF="../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;? extends <A HREF="../../java/lang/annotation/Annotation.html" title="java.lang.annotation 中的接口">Annotation</A>&gt;&nbsp;annotationClass)</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html#isAnnotationPresent(java.lang.Class)">AnnotatedElement</A></CODE> 复制的描述</B></DD>
<DD>如果指定类型的注释存在于此元素上，则返回 true，否则返回 false。此方法主要是为了便于访问标记注释而设计的。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html" title="java.lang.reflect 中的接口">AnnotatedElement</A></CODE> 中的 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html#isAnnotationPresent(java.lang.Class)">isAnnotationPresent</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>annotationClass</CODE> - 对应于注释类型的 Class 对象
<DT><B>返回：</B><DD>如果指定注释类型的注释存在于此对象上，则返回 true，否则返回 false
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果给定的注释类为 null<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAnnotations()"><!-- --></A><H3>
getAnnotations</H3>
<PRE>
public <A HREF="../../java/lang/annotation/Annotation.html" title="java.lang.annotation 中的接口">Annotation</A>[] <B>getAnnotations</B>()</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html#getAnnotations()">AnnotatedElement</A></CODE> 复制的描述</B></DD>
<DD>返回此元素上存在的所有注释。（如果此元素没有注释，则返回长度为零的数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html" title="java.lang.reflect 中的接口">AnnotatedElement</A></CODE> 中的 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html#getAnnotations()">getAnnotations</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此元素上存在的所有注释<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDeclaredAnnotations()"><!-- --></A><H3>
getDeclaredAnnotations</H3>
<PRE>
public <A HREF="../../java/lang/annotation/Annotation.html" title="java.lang.annotation 中的接口">Annotation</A>[] <B>getDeclaredAnnotations</B>()</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html#getDeclaredAnnotations()">AnnotatedElement</A></CODE> 复制的描述</B></DD>
<DD>返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html" title="java.lang.reflect 中的接口">AnnotatedElement</A></CODE> 中的 <CODE><A HREF="../../java/lang/reflect/AnnotatedElement.html#getDeclaredAnnotations()">getDeclaredAnnotations</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>直接存在于此元素上的所有注释<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Class.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/CharSequence.html" title="java.lang 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/lang/ClassCastException.html" title="java.lang 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Class.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Class.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
