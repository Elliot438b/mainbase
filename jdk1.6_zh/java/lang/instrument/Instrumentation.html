<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 12:48:46 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
Instrumentation (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Instrumentation (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Instrumentation.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/lang/instrument/IllegalClassFormatException.html" title="java.lang.instrument 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../java/lang/instrument/UnmodifiableClassException.html" title="java.lang.instrument 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/lang/instrument/Instrumentation.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Instrumentation.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang.instrument</FONT>
<BR>
接口 Instrumentation</H2>
<HR>
<DL>
<DT><PRE>public interface <B>Instrumentation</B></DL>
</PRE>

<P>
此类提供检测 Java 编程语言代码所需的服务。检测是向方法中添加字节码，以搜集各种工具所使用的数据。由于更改完全是进行添加，所以这些工具不修改应用程序的状态或行为。这种无害工具的例子包括镜像代理、分析器、覆盖分析器和事件记录器。

 <P>
获取 <code>Instrumentation</code> 接口的实例有两种方式：

 <ol>
   <li><p>当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 <code>premain</code> 方法一个 <code>Instrumentation</code> 实例。
     </p></li>
   <li><p> 当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 <code>agentmain</code> 方法一个 <code>Instrumentation</code> 实例。</p> </li> 
 </ol>
 <p> 
 这些机制在<A HREF="../../../java/lang/instrument/package-summary.html">包规范</A>中描述。
 <p>如果某个代理获得了 <code>Instrumentation</code> 实例，它便可以在任何时候调用该实例上的方法。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer)">addTransformer</A></B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口">ClassFileTransformer</A>&nbsp;transformer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册提供的转换器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer, boolean)">addTransformer</A></B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口">ClassFileTransformer</A>&nbsp;transformer,
               boolean&nbsp;canRetransform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册提供的转换器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)">appendToBootstrapClassLoaderSearch</A></B>(<A HREF="../../../java/util/jar/JarFile.html" title="java.util.jar 中的类">JarFile</A>&nbsp;jarfile)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定 JAR 文件，检测类由引导类加载器定义。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#appendToSystemClassLoaderSearch(java.util.jar.JarFile)">appendToSystemClassLoaderSearch</A></B>(<A HREF="../../../java/util/jar/JarFile.html" title="java.util.jar 中的类">JarFile</A>&nbsp;jarfile)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定 JAR 文件，检测类由系统类加载器定义。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#getAllLoadedClasses()">getAllLoadedClasses</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 JVM 当前加载的所有类的数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#getInitiatedClasses(java.lang.ClassLoader)">getInitiatedClasses</A></B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;loader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回所有初始化加载器是 <code>loader</code> 的类的数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#getObjectSize(java.lang.Object)">getObjectSize</A></B>(<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;objectToSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定对象使用的特定于实现的近似存储量。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#isModifiableClass(java.lang.Class)">isModifiableClass</A></B>(<A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;theClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定一个类是否可以被 <A HREF="../../../java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)">retransformation</A> 或 <A HREF="../../../java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)">redefinition</A> 修改。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#isNativeMethodPrefixSupported()">isNativeMethodPrefixSupported</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回当前 JVM 配置是否支持<A HREF="../../../java/lang/instrument/Instrumentation.html#setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer, java.lang.String)">设置本机方法前缀</A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported()">isRedefineClassesSupported</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回当前 JVM 配置是否支持类的重定义。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported()">isRetransformClassesSupported</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回当前 JVM 配置是否支持类的重转换。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)">redefineClasses</A></B>(<A HREF="../../../java/lang/instrument/ClassDefinition.html" title="java.lang.instrument 中的类">ClassDefinition</A>...&nbsp;definitions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用提供的类文件重定义提供的类集。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#removeTransformer(java.lang.instrument.ClassFileTransformer)">removeTransformer</A></B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口">ClassFileTransformer</A>&nbsp;transformer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注销提供的转换器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)">retransformClasses</A></B>(<A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;...&nbsp;classes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重转换提供的类集。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer, java.lang.String)">setNativeMethodPrefix</A></B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口">ClassFileTransformer</A>&nbsp;transformer,
                      <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;prefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过允许重试，将前缀应用到名称，此方法修改本机方法解析的失败处理。</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="addTransformer(java.lang.instrument.ClassFileTransformer, boolean)"><!-- --></A><H3>
addTransformer</H3>
<PRE>
void <B>addTransformer</B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口">ClassFileTransformer</A>&nbsp;transformer,
                    boolean&nbsp;canRetransform)</PRE>
<DL>
<DD>注册提供的转换器。所有以后的类定义对于该转换器都是可见的，任何已注册转换器所依赖的类定义除外。
加载类、<A HREF="../../../java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)">重定义</A>类时将调用该转换器。如果 <code>canRetransform</code> 为 true，那么<A HREF="../../../java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)">重转换</A>类时也将调用该转换器。 
有关转换调用的顺序，请参见 <A HREF="../../../java/lang/instrument/ClassFileTransformer.html#transform(java.lang.ClassLoader, java.lang.String, java.lang.Class, java.security.ProtectionDomain, byte[])"><CODE>ClassFileTransformer.transform</CODE></A>。
如果转换器在执行过程中抛出异常，JVM 将仍然按顺序调用其他已注册转换器。可以多次添加相同的转换器，但建议最好创建一个新的转换器类实例来避免这样做。
 <P>
此方法旨在用于检测，正如<A HREF="../../../java/lang/instrument/Instrumentation.html" title="java.lang.instrument 中的接口">类规范</A>所述。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>transformer</CODE> - 要注册的转换器<DD><CODE>canRetransform</CODE> - 此转换器的转换是否可以重转换
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果传递了 <code>null</code> 转换器
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果 <code>canRetransform</code> 为 true 但当前 JVM 的配置不允许重转换（<A HREF="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported()"><CODE>isRetransformClassesSupported()</CODE></A> 为 false）。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="addTransformer(java.lang.instrument.ClassFileTransformer)"><!-- --></A><H3>
addTransformer</H3>
<PRE>
void <B>addTransformer</B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口">ClassFileTransformer</A>&nbsp;transformer)</PRE>
<DL>
<DD>注册提供的转换器。
 <P>
 与 <code>addTransformer(transformer, false)</code> 相同。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>transformer</CODE> - 要注册的转换器
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果传递了一个 <code>null</code> 转换器<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer, boolean)"><CODE>addTransformer(ClassFileTransformer,boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeTransformer(java.lang.instrument.ClassFileTransformer)"><!-- --></A><H3>
removeTransformer</H3>
<PRE>
boolean <B>removeTransformer</B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口">ClassFileTransformer</A>&nbsp;transformer)</PRE>
<DL>
<DD>注销提供的转换器。以后的类定义将不再向该转换器显示。移除最新添加的转换器的匹配实例。由于类加载的多线程特性，在调用被移除后，转换器还可能接收调用。所以编写转换器时应防止出现这种情况。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>transformer</CODE> - 要注销的转换器
<DT><B>返回：</B><DD>如果找到并移除转换器，则返回 true；如果找不到转换器，则返回 false
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果传递了一个 <code>null</code> 转换器</DL>
</DD>
</DL>
<HR>

<A NAME="isRetransformClassesSupported()"><!-- --></A><H3>
isRetransformClassesSupported</H3>
<PRE>
boolean <B>isRetransformClassesSupported</B>()</PRE>
<DL>
<DD>返回当前 JVM 配置是否支持类的重转换。
转换已加载类是 JVM 的一个可选性能。
仅当 <code>Can-Retransform-Classes</code> 清单属性在代理 JAR 文件中设置为 <code>true</code>（如<A HREF="../../../java/lang/instrument/package-summary.html">包规范</A>所述），且 JVM 支持此性能时，才支持重转换。
 在单个 JVM 的单个实例化过程中，多次调用此方法将总是返回相同的答案。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果当前 JVM 配置支持类的重转换，则返回 true；如果不支持，则返回 false。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)"><CODE>retransformClasses(java.lang.Class<?>...)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="retransformClasses(java.lang.Class...)"><!-- --></A><H3>
retransformClasses</H3>
<PRE>
void <B>retransformClasses</B>(<A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;...&nbsp;classes)
                        throws <A HREF="../../../java/lang/instrument/UnmodifiableClassException.html" title="java.lang.instrument 中的类">UnmodifiableClassException</A></PRE>
<DL>
<DD>重转换提供的类集。

 <P>
 此函数为检测已加载类提供了方便。
当最初加载了类或<A HREF="../../../java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)">重定义</A>了类时，初始类文件字节可以使用 <A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口"><CODE>ClassFileTransformer</CODE></A> 转换。
 此函数返回转换进程（以前是否发生过转换）。
 此转换按以下步骤进行：
  <ul>
    <li>从初始类文件字节开始
    </li>
    <li>对于每个添加时 <code>canRetransform</code> 设为 false 的转换器，上一次类加载或重定义期间 <A HREF="../../../java/lang/instrument/ClassFileTransformer.html#transform(java.lang.ClassLoader, java.lang.String, java.lang.Class, java.security.ProtectionDomain, byte[])"><CODE>transform</CODE></A> 返回的字节将被重新用于转换的输出；注意，这等价于不做更改地重新应用前一个转换；没有调用 <A HREF="../../../java/lang/instrument/ClassFileTransformer.html#transform(java.lang.ClassLoader, java.lang.String, java.lang.Class, java.security.ProtectionDomain, byte[])"><CODE>transform</CODE></A> 的情况除外。
    </li>
    <li>对于每个添加时 <code>canRetransform</code> 设为 true 的转换器，在这些转换器中调用 <A HREF="../../../java/lang/instrument/ClassFileTransformer.html#transform(java.lang.ClassLoader, java.lang.String, java.lang.Class, java.security.ProtectionDomain, byte[])"><CODE>transform</CODE></A> 方法
    </li>
    <li>转换的类文件字节将作为类的新定义安装
    </li>
  </ul>
 <P>

转换的顺序在 <A HREF="../../../java/lang/instrument/ClassFileTransformer.html#transform(java.lang.ClassLoader, java.lang.String, java.lang.Class, java.security.ProtectionDomain, byte[])"><CODE>transform</CODE></A> 方法中描述。在自动重新应用不可重转换的转换时，也将使用这一顺序。 
 <P>

 最初的类文件字节表示（应用转换前）传递给 <A HREF="../../../java/lang/ClassLoader.html#defineClass(byte[], int, int)"><CODE>ClassLoader.defineClass</CODE></A> 或 <A HREF="../../../java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)"><CODE>redefineClasses</CODE></A> 的字节，但有可能不完全匹配。常量池的布局或内容可能不同。常量池的条目可能多一些或少一些。常量池条目的顺序可能不同，但是，方法字节码中常量池的索引将是对应的。一些属性可能不存在。在顺序没有意义的地方（例如，方法的顺序），可能不保留顺序。

 <P>
 此方法在一个集合上操作，以便允许同时对多个类进行相互依赖的更改（重转换类 A 要求重转换类 B）。
 <P>
 如果重转换的方法有活动的堆栈帧，那么这些活动的帧将继续运行原方法的字节码。重转换的方法将用于新的调用。

 <P>
此方法不会引起任何初始化操作，JVM 惯例语义下发生的初始化除外。换句话说，重定义一个类不会引起其初始化方法的运行。静态变量的值将与调用之前的值一样。

 <P>
 重转换类的实例不受影响。

 <P>
 重转换可能会更改方法体、常量池和属性。重转换不得添加、移除、重命名字段或方法；不得更改方法签名、继承关系。在以后的版本中，可能会取消这些限制。在应用转换之前，类文件字节不会被检查、验证和安装。如果结果字节错误，此方法将抛出异常。

 <P>
如果此方法抛出异常，则不会重转换任何类。
 <P>
此方法旨在用于检测，正如<A HREF="../../../java/lang/instrument/Instrumentation.html" title="java.lang.instrument 中的接口">类规范</A>所述。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>classes</CODE> - 要转换的类数组；
                允许长度为 0 数组，在这种情况下，此方法不执行任何操作
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/instrument/UnmodifiableClassException.html" title="java.lang.instrument 中的类">UnmodifiableClassException</A></CODE> - 如果不能修改指定的类（<A HREF="../../../java/lang/instrument/Instrumentation.html#isModifiableClass(java.lang.Class)"><CODE>isModifiableClass(java.lang.Class<?>)</CODE></A> 返回 <code>false</code>）
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果 JVM 的当前配置不允许重转换（<A HREF="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported()"><CODE>isRetransformClassesSupported()</CODE></A> 为 false），或者重转换试图做出不受支持的更改
<DD><CODE><A HREF="../../../java/lang/ClassFormatError.html" title="java.lang 中的类">ClassFormatError</A></CODE> - 如果数据不包含有效的类
<DD><CODE><A HREF="../../../java/lang/NoClassDefFoundError.html" title="java.lang 中的类">NoClassDefFoundError</A></CODE> - 如果类文件中的名称不等于类的名称
<DD><CODE><A HREF="../../../java/lang/UnsupportedClassVersionError.html" title="java.lang 中的类">UnsupportedClassVersionError</A></CODE> - 如果类文件版本号不受支持
<DD><CODE><A HREF="../../../java/lang/ClassCircularityError.html" title="java.lang 中的类">ClassCircularityError</A></CODE> - 如果新类包含循环
<DD><CODE><A HREF="../../../java/lang/LinkageError.html" title="java.lang 中的类">LinkageError</A></CODE> - 如果发生链接错误
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果提供的类数组或其任意组件为 <code>null</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported()"><CODE>isRetransformClassesSupported()</CODE></A>, 
<A HREF="../../../java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer, boolean)"><CODE>addTransformer(java.lang.instrument.ClassFileTransformer, boolean)</CODE></A>, 
<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口"><CODE>ClassFileTransformer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isRedefineClassesSupported()"><!-- --></A><H3>
isRedefineClassesSupported</H3>
<PRE>
boolean <B>isRedefineClassesSupported</B>()</PRE>
<DL>
<DD>返回当前 JVM 配置是否支持类的重定义。重定义已加载类是 JVM 的一个可选性能。
仅当 <code>Can-Retransform-Classes</code> 清单属性在代理 JAR 文件中设置为 <code>true</code>（如<A HREF="../../../java/lang/instrument/package-summary.html">包规范</A>所述），且 JVM 支持此性能时，才支持重转换。
在执行单个 JVM 的单实例化过程中，对此方法的多次调用将始终返回同一应答。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果当前 JVM 配置支持类的重定义，则为 true，否则为 false。<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)"><CODE>redefineClasses(java.lang.instrument.ClassDefinition...)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="redefineClasses(java.lang.instrument.ClassDefinition...)"><!-- --></A><H3>
redefineClasses</H3>
<PRE>
void <B>redefineClasses</B>(<A HREF="../../../java/lang/instrument/ClassDefinition.html" title="java.lang.instrument 中的类">ClassDefinition</A>...&nbsp;definitions)
                     throws <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A>,
                            <A HREF="../../../java/lang/instrument/UnmodifiableClassException.html" title="java.lang.instrument 中的类">UnmodifiableClassException</A></PRE>
<DL>
<DD>使用提供的类文件重定义提供的类集。
 <P>
此方法用于替代类的定义，而不引用现有的类文件字节，这与 fix-and-continue 调试过程中重新编译源代码时所做的一样。需要转换现有类文件字节的地方（例如，字节码检测中）应该使用 <A HREF="../../../java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)"><CODE>retransformClasses</CODE></A>。
<P>
此方法在一个集合上操作，以便允许同时对多个类进行相互依赖的更改（重定义类 A 要求重定义类 B）。

 <P>
如果重定义的方法有活动的堆栈帧，那么这些活动的帧将继续运行原方法的字节码。将在新的调用上使用此重定义的方法。

 <P>
此方法不会引起任何初始化操作，JVM 惯例语义下发生的初始化除外。换句话说，重定义一个类不会引起其初始化方法的运行。静态变量的值将与调用之前的值一样。

 <P>
重定义类的实例不受影响。

 <P>
重定义可能会更改方法体、常量池和属性。重定义不得添加、移除、重命名字段或方法；不得更改方法签名、继承关系。在以后的版本中，可能会取消这些限制。在应用转换之前，类文件字节不会被检查、验证和安装。如果结果字节错误，此方法将抛出异常。


 <P>
如果此方法抛出异常，则不会重定义任何类。
 <P>
此方法旨在用于检测，正如<A HREF="../../../java/lang/instrument/Instrumentation.html" title="java.lang.instrument 中的接口">类规范</A>所述。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>definitions</CODE> - 要使用相应定义来进行重定义的类数组；允许长度为 0 数组，在这种情况下，此方法不执行任何操作
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/instrument/UnmodifiableClassException.html" title="java.lang.instrument 中的类">UnmodifiableClassException</A></CODE> - 如果无法修改指定的类（<A HREF="../../../java/lang/instrument/Instrumentation.html#isModifiableClass(java.lang.Class)"><CODE>isModifiableClass(java.lang.Class<?>)</CODE></A> 返回 <code>false</code>）
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果 JVM 的当前配置不允许重定义（<A HREF="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported()"><CODE>isRedefineClassesSupported()</CODE></A> 为 false）或重定义试图做出不受支持的更改
<DD><CODE><A HREF="../../../java/lang/ClassFormatError.html" title="java.lang 中的类">ClassFormatError</A></CODE> - 如果数据不包含有效类
<DD><CODE><A HREF="../../../java/lang/NoClassDefFoundError.html" title="java.lang 中的类">NoClassDefFoundError</A></CODE> - 如果类文件中的名称与类名称不相等
<DD><CODE><A HREF="../../../java/lang/UnsupportedClassVersionError.html" title="java.lang 中的类">UnsupportedClassVersionError</A></CODE> - 如果类文件版本号不受支持
<DD><CODE><A HREF="../../../java/lang/ClassCircularityError.html" title="java.lang 中的类">ClassCircularityError</A></CODE> - 如果新类包含循环
<DD><CODE><A HREF="../../../java/lang/LinkageError.html" title="java.lang 中的类">LinkageError</A></CODE> - 如果发生链接错误
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果提供的定义数组或其任何组件为 <code>null</code>。
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 中的类">ClassNotFoundException</A></CODE> - 不会抛出（存在只是为了兼容）<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported()"><CODE>isRedefineClassesSupported()</CODE></A>, 
<A HREF="../../../java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer, boolean)"><CODE>addTransformer(java.lang.instrument.ClassFileTransformer, boolean)</CODE></A>, 
<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口"><CODE>ClassFileTransformer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isModifiableClass(java.lang.Class)"><!-- --></A><H3>
isModifiableClass</H3>
<PRE>
boolean <B>isModifiableClass</B>(<A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>&lt;?&gt;&nbsp;theClass)</PRE>
<DL>
<DD>确定一个类是否可以被 <A HREF="../../../java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)">retransformation</A> 或 <A HREF="../../../java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)">redefinition</A> 修改。
如果类可以被修改，那么此方法返回 <code>true</code>。
如果类不能被修改，那么此方法返回 <code>false</code>。
 <P>
对于要重转换的类，<A HREF="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported()"><CODE>isRetransformClassesSupported()</CODE></A> 也必须为 true。但 <code>isRetransformClassesSupported()</code> 的值不影响此函数返回的值。
对于要重定义的类，<A HREF="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported()"><CODE>isRedefineClassesSupported()</CODE></A> 也必须为 true。但 <code>isRedefineClassesSupported()</code> 的值不影响此函数返回的值。
 <P>
基本类（例如 <code>java.lang.Integer.TYPE</code>）和数组类不可修改。
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果指定的类为 <code>null</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)"><CODE>retransformClasses(java.lang.Class<?>...)</CODE></A>, 
<A HREF="../../../java/lang/instrument/Instrumentation.html#isRetransformClassesSupported()"><CODE>isRetransformClassesSupported()</CODE></A>, 
<A HREF="../../../java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)"><CODE>redefineClasses(java.lang.instrument.ClassDefinition...)</CODE></A>, 
<A HREF="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported()"><CODE>isRedefineClassesSupported()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAllLoadedClasses()"><!-- --></A><H3>
getAllLoadedClasses</H3>
<PRE>
<A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>[] <B>getAllLoadedClasses</B>()</PRE>
<DL>
<DD>返回 JVM 当前加载的所有类的数组。
<P>
<DD><DL>

<DT><B>返回：</B><DD>包含 JVM 加载的所有类的数组；如果没有，则返回长度为 0 数组</DL>
</DD>
</DL>
<HR>

<A NAME="getInitiatedClasses(java.lang.ClassLoader)"><!-- --></A><H3>
getInitiatedClasses</H3>
<PRE>
<A HREF="../../../java/lang/Class.html" title="java.lang 中的类">Class</A>[] <B>getInitiatedClasses</B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;loader)</PRE>
<DL>
<DD>返回所有初始化加载器是 <code>loader</code> 的类的数组。如果提供的加载器为 <code>null</code>，则返回由引导类加载器初始化的类。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>loader</CODE> - 将返回其初始化类列表的加载器
<DT><B>返回：</B><DD>包含初始化加载器是 <code>loader</code> 的类的数组；如果没有，则返回长度为 0 数组</DL>
</DD>
</DL>
<HR>

<A NAME="getObjectSize(java.lang.Object)"><!-- --></A><H3>
getObjectSize</H3>
<PRE>
long <B>getObjectSize</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;objectToSize)</PRE>
<DL>
<DD>返回指定对象使用的特定于实现的近似存储量。该结果可能包括对象的部分或全部开销，因此，在一个实现中进行比较时较为有用，但不能用于实现之间的比较。

该估计值在 JVM 的单个调用期间可能发生变化。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>objectToSize</CODE> - 需要确定大小的对象
<DT><B>返回：</B><DD>指定对象使用的特定于实现的近似存储量
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果提供的 Object 为 <code>null</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)"><!-- --></A><H3>
appendToBootstrapClassLoaderSearch</H3>
<PRE>
void <B>appendToBootstrapClassLoaderSearch</B>(<A HREF="../../../java/util/jar/JarFile.html" title="java.util.jar 中的类">JarFile</A>&nbsp;jarfile)</PRE>
<DL>
<DD>指定 JAR 文件，检测类由引导类加载器定义。

 <p> 当虚拟机的内置类加载器（称为“引导类加载器”）未能成功搜索到类时，<A HREF="../../../java/util/jar/JarFile.html" title="java.util.jar 中的类"><CODE>JAR 文件</CODE></A>中的条目也将被搜索。 
 
 <p> 可以多次使用此方法，按照调用此方法的顺序添加多个要搜索的 JAR 文件。
 
 <p> 除了需要引导类加载器为检测而定义的类或资源外，代理应该注意确保 JAR 不包含任何其他类或资源。
违反此规定将导致难以诊断的不可预料行为。例如，假设有加载器 L，L 的代理父加载器为引导类加载器。
此外，有一个类 C 的方法，有一个 L 定义的类，引用了非公共存取类 C$1。如果 JAR 文件包含类 C$1，那么引导类加载器的代理将导致 C$1 被引导类加载器定义。此例中将抛出 <code>IllegalAccessError</code>，这可能导致应用程序失败。一个避免这类问题的办法是，对检测类使用唯一的包名称。

 <p> <a href="http://java.sun.com/docs/books/vmspec/">Java 虚拟机规范</a>规定，后续尝试解析 Java 虚拟机以前未能成功解析的符号引用将总是失败，并抛出与最初解析尝试失败时相同的错误。因此，如果 JAR 文件包含的某个条目对应于 Java 虚拟机未能成功解析引用的类，那么后续尝试解析该引用将总是失败，并抛出与最初解析尝试失败时相同的错误。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>jarfile</CODE> - 当引导类加载器未成功搜索到类时要搜索的 JAR 文件。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>jarfile</code> 为 <code>null</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#appendToSystemClassLoaderSearch(java.util.jar.JarFile)"><CODE>appendToSystemClassLoaderSearch(java.util.jar.JarFile)</CODE></A>, 
<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 中的类"><CODE>ClassLoader</CODE></A>, 
<A HREF="../../../java/util/jar/JarFile.html" title="java.util.jar 中的类"><CODE>JarFile</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="appendToSystemClassLoaderSearch(java.util.jar.JarFile)"><!-- --></A><H3>
appendToSystemClassLoaderSearch</H3>
<PRE>
void <B>appendToSystemClassLoaderSearch</B>(<A HREF="../../../java/util/jar/JarFile.html" title="java.util.jar 中的类">JarFile</A>&nbsp;jarfile)</PRE>
<DL>
<DD>指定 JAR 文件，检测类由系统类加载器定义。 

当代理的系统类加载器（参见 <A HREF="../../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>getSystemClassLoader()</CODE></A>）未能成功搜索到类时，<A HREF="../../../java/util/jar/JarFile.html" title="java.util.jar 中的类"><CODE>JarFile</CODE></A> 中的条目也将被搜索。

 <p> 可以多次使用此方法，按照调用此方法的顺序添加多个要搜索的 JAR 文件。


 <p> 除了需要系统类加载器为检测而定义的类或资源外，代理应该注意确保 JAR 不包含任何其他类或资源。
违反此规定将导致难以诊断的不可预料行为。（参见 <A HREF="../../../java/lang/instrument/Instrumentation.html#appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)"><CODE>appendToBootstrapClassLoaderSearch</CODE></A>）。

 <p> 如果实现了名为 <code>appendToClassPathForInstrumentation</code> 的方法（带有一个类型为 <code>java.lang.String</code> 的参数），那么系统类加载器支持添加要搜索的 JAR 文件。不要求该方法具有 <code>public</code> 访问权。JAR 文件名可以通过对 <code>jarfile</code> 调用 <A HREF="../../../java/util/zip/ZipFile.html#getName()"><CODE>getName()</CODE></A> 方法获取，并将作为参数提供给 <code>appendtoClassPathForInstrumentation</code> 方法。

 <p> <a href="http://java.sun.com/docs/books/vmspec/">Java 虚拟机规范</a>规定，后续尝试解析 Java 虚拟机以前未能成功解析的符号引用将总是失败，并抛出与最初解析尝试失败时相同的错误。因此，如果 JAR 文件包含的某个条目对应于 Java 虚拟机未能成功解析引用的类，那么后续尝试解析该引用将总是失败，并抛出与最初解析尝试失败时相同的错误。

 <p> 此方法不更改 <code>java.class.path</code> <A HREF="../../../java/lang/System.html#getProperties()"><CODE>系统属性</CODE></A>的值。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>jarfile</CODE> - 当系统类加载器未成功搜索到类时要搜索的 JAR 文件。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果系统类加载器不支持添加要搜索的 JAR 文件。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>jarfile</code> 为 <code>null</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)"><CODE>appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)</CODE></A>, 
<A HREF="../../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>ClassLoader.getSystemClassLoader()</CODE></A>, 
<A HREF="../../../java/util/jar/JarFile.html" title="java.util.jar 中的类"><CODE>JarFile</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isNativeMethodPrefixSupported()"><!-- --></A><H3>
isNativeMethodPrefixSupported</H3>
<PRE>
boolean <B>isNativeMethodPrefixSupported</B>()</PRE>
<DL>
<DD>返回当前 JVM 配置是否支持<A HREF="../../../java/lang/instrument/Instrumentation.html#setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer, java.lang.String)">设置本机方法前缀</A>。
设置本机方法前缀是 JVM 的一个可选性能。
仅当 <code>Can-Set-Native-Method-Prefix</code> 清单属性在代理 JAR 文件中设置为 <code>true</code>（如<A HREF="../../../java/lang/instrument/package-summary.html">包规范</A>所述），且 JVM 支持此性能时，才支持设置本机方法前缀。
 在单个 JVM 的单个实例化过程中，多次调用此方法将总是返回相同的应答。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果当前 JVM 配置支持设置本机方法前缀，则返回 true；否则返回 false。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer, java.lang.String)"><CODE>setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer, java.lang.String)"><!-- --></A><H3>
setNativeMethodPrefix</H3>
<PRE>
void <B>setNativeMethodPrefix</B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口">ClassFileTransformer</A>&nbsp;transformer,
                           <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;prefix)</PRE>
<DL>
<DD>通过允许重试，将前缀应用到名称，此方法修改本机方法解析的失败处理。
当与 <A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 中的接口"><CODE>ClassFileTransformer</CODE></A> 一起使用时，它允许检测本机方法。
 <p/>
由于本机方法不能直接检测（它们没有字节码），因此必须使用可以检测的非本机方法包装它们。例如，如果有：
 <pre>
   native boolean foo(int x);</pre>
 <p/>
那么可以转换类文件（在类的初始定义过程中使用 ClassFileTransformer），使之变成：
 <pre>
   boolean foo(int x) {
     <i>... record entry to foo ...</i>
     return wrapped_foo(x);
   }
   
   native boolean wrapped_foo(int x);</pre>
 <p/>
其中 <code>foo</code> 变为实际本机方法的包装器，并带有附加前缀 "wrapped_"。注意，将 "wrapped_" 作为前缀并不合适，因为它很有可能与现有方法重名，因此 "$$$MyAgentWrapped$$$_" 之类更加合适，但那将减少这些示例的可读性。
 <p/>
包装器将允许在本机方法调用上收集数据，但现在的问题在于如何连接包装的方法与本机实现。 
也就是说，方法 <code>wrapped_foo</code> 需要被解析为 <code>foo</code> 的本机实现，即：
 <pre>
   Java_somePackage_someClass_foo(JNIEnv* env, jint x)</pre>
 <p/>
 此函数允许指定前缀并进行恰当的解析。
明确地说，当标准解析失败时，解析将重新尝试考虑前缀。进行解析有两种方式，使用 JNI 函数 <code>RegisterNatives</code> 的显式解析和常规自动解析。对于 <code>RegisterNatives</code>，JVM 将尝试以下关联：

 <pre>
   method(foo) -> nativeImplementation(foo)</pre>
 <p/>
若此操作失败，解析将重试，将指定的前缀添加到方法名，生成校正解析：
 <pre>
   method(wrapped_foo) -> nativeImplementation(foo)</pre>
 <p/>
 对于自动解析，JVM 将尝试： 
 <pre>
   method(wrapped_foo) -> nativeImplementation(wrapped_foo)</pre>
 <p/>
若此操作失败，解析将重试，从实现名删除指定的前缀，生成校正解析：
 <pre>
   method(wrapped_foo) -> nativeImplementation(foo)</pre>
 <p/>
 注意，前缀只在标准解析失败时使用，因此可以有选择地包装本机方法。
 <p/>
 每个 <code>ClassFileTransformer</code> 可以执行其本身的字节代码转换，因此可能要应用多个包装器层。所以每个转换器需要其自己的前缀。转换是按顺序应用的，因此前缀（如果应用）也将按相同的顺序应用（参见 <A HREF="../../../java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer, boolean)"><CODE>addTransformer</CODE></A>）。
所以，如果三个转换器应用了包装器，<code>foo</code> 将变为 <code>$trans3_$trans2_$trans1_foo</code>。但是，如果第二个转换器没有对 <code>foo</code> 应用包装器，那么它将是 <code>$trans3_$trans1_foo</code>。要有效的确定前缀序列，仅当其非本机包装器存在时才应用中间前缀。因此，在最后一个示例中，即使 <code>$trans1_foo</code> 不是本机方法，<code>$trans1_</code> 前缀也将应用，因为 <code>$trans1_foo</code> 存在。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>transformer</CODE> - 使用此前缀包装的 ClassFileTransformer。<DD><CODE>prefix</CODE> - 已应用到包装的本机方法的前缀。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果传入 <code>null</code> 转换器。
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果 JVM 的当前配置不允许设置本机方法前缀（<A HREF="../../../java/lang/instrument/Instrumentation.html#isNativeMethodPrefixSupported()"><CODE>isNativeMethodPrefixSupported()</CODE></A> 为 false）。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果转换器没有注册（参见 <A HREF="../../../java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer, boolean)"><CODE>addTransformer</CODE></A>）。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Instrumentation.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/lang/instrument/IllegalClassFormatException.html" title="java.lang.instrument 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../java/lang/instrument/UnmodifiableClassException.html" title="java.lang.instrument 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/lang/instrument/Instrumentation.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Instrumentation.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
