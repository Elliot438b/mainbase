<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 12:48:40 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
Thread (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Thread (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Thread.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/System.html" title="java.lang 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/lang/Thread.State.html" title="java.lang 中的枚举"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Thread.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Thread.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
类 Thread</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.lang.Thread</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Thread</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A><DT>implements <A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A></DL>
</PRE>

<P>
<i>线程</i> 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。
<p>
每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个守护程序。当某个线程中运行的代码创建一个新 <code>Thread</code> 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。
<p>
当 Java 虚拟机启动时，通常都会有单个非守护线程（它通常会调用某个指定类的 <code>main</code> 方法）。Java 虚拟机会继续执行线程，直到下列任一情况出现时为止：
<ul>
<li>调用了 <code>Runtime</code> 类的 <code>exit</code> 方法，并且安全管理器允许退出操作发生。
<li>非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 <code>run</code> 方法之外的异常。
</ul>
<p>
创建新执行线程有两种方法。一种方法是将类声明为 <code>Thread</code> 的子类。该子类应重写 <code>Thread</code> 类的 <code>run</code> 方法。接下来可以分配并启动该子类的实例。例如，计算大于某一规定值的质数的线程可以写成：
 <p><hr><blockquote><pre>
     class PrimeThread extends Thread {
         long minPrime;
         PrimeThread(long minPrime) {
             this.minPrime = minPrime;
         }
 
         public void run() {
             // compute primes larger than minPrime
             &nbsp;.&nbsp;.&nbsp;.
         }
     }
 </pre></blockquote><hr>
 <p>
 然后，下列代码会创建并启动一个线程：
 <p><blockquote><pre>
     PrimeThread p = new PrimeThread(143);
     p.start();
 </pre></blockquote>
 <p>
 创建线程的另一种方法是声明实现 <code>Runnable</code> 接口的类。该类然后实现 <code>run</code> 方法。然后可以分配该类的实例，在创建 <code>Thread</code> 时作为一个参数来传递并启动。采用这种风格的同一个例子如下所示：
 <p><hr><blockquote><pre>
     class PrimeRun implements Runnable {
         long minPrime;
         PrimeRun(long minPrime) {
             this.minPrime = minPrime;
         }
 
         public void run() {
             // compute primes larger than minPrime
             &nbsp;.&nbsp;.&nbsp;.
         }
     }
 </pre></blockquote><hr>
 <p>
 然后，下列代码会创建并启动一个线程：
 <p><blockquote><pre>
     PrimeRun p = new PrimeRun(143);
     new Thread(p).start();
 </pre></blockquote>
 <p>
 每个线程都有一个标识名，多个线程可以同名。如果线程创建时没有指定标识名，就会为其生成一个新名称。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口"><CODE>Runnable</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>Runtime.exit(int)</CODE></A>, 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>嵌套类摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.State.html" title="java.lang 中的枚举">Thread.State</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 中的接口">Thread.UncaughtExceptionHandler</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 <tt>Thread</tt> 因未捕获的异常而突然终止时，调用处理程序的接口。</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#MAX_PRIORITY">MAX_PRIORITY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程可以具有的最高优先级。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#MIN_PRIORITY">MIN_PRIORITY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程可以具有的最低优先级。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#NORM_PRIORITY">NORM_PRIORITY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分配给线程的默认优先级。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread()">Thread</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分配新的 <code>Thread</code> 对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.Runnable)">Thread</A></B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分配新的 <code>Thread</code> 对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.Runnable, java.lang.String)">Thread</A></B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;target,
       <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分配新的 <code>Thread</code> 对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.String)">Thread</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分配新的 <code>Thread</code> 对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable)">Thread</A></B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A>&nbsp;group,
       <A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分配新的 <code>Thread</code> 对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)">Thread</A></B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A>&nbsp;group,
       <A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;target,
       <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分配新的 <code>Thread</code> 对象，以便将 <code>target</code> 作为其运行对象，将指定的 <code>name</code> 作为其名称，并作为 <code>group</code> 所引用的线程组的一员。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long)">Thread</A></B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A>&nbsp;group,
       <A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;target,
       <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
       long&nbsp;stackSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分配新的 <code>Thread</code> 对象，以便将 <code>target</code> 作为其运行对象，将指定的 <code>name</code> 作为其名称，作为 <code>group</code> 所引用的线程组的一员，并具有指定的<i>堆栈大小</i>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.String)">Thread</A></B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A>&nbsp;group,
       <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分配新的 <code>Thread</code> 对象。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#activeCount()">activeCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回当前线程的线程组中活动线程的数目。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#checkAccess()">checkAccess</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定当前运行的线程是否有权修改该线程。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#countStackFrames()">countStackFrames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>该调用的定义依赖于 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>，但它遭到了反对。此外，该调用的结果从来都不是意义明确的。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#currentThread()">currentThread</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回对当前正在执行的线程对象的引用。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#destroy()">destroy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>该方法最初用于破坏该线程，但不作任何清除。它所保持的任何监视器都会保持锁定状态。不过，该方法决不会被实现。即使要实现，它也极有可能以 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A> 方式被死锁。如果目标线程被破坏时保持一个保护关键系统资源的锁，则任何线程在任何时候都无法再次访问该资源。如果另一个线程曾试图锁定该资源，则会出现死锁。这类死锁通常会证明它们自己是“冻结”的进程。有关更多信息，请参阅<a href="http://java.sun.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？</a>。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#dumpStack()">dumpStack</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将当前线程的堆栈跟踪打印至标准错误流。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#enumerate(java.lang.Thread[])">enumerate</A></B>(<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>[]&nbsp;tarray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将当前线程的线程组及其子组中的每一个活动线程复制到指定的数组中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Map.html" title="java.util 中的接口">Map</A>&lt;<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>,<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 中的类">StackTraceElement</A>[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getAllStackTraces()">getAllStackTraces</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回所有活动线程的堆栈跟踪的一个映射。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getContextClassLoader()">getContextClassLoader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回该线程的上下文 ClassLoader。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 中的接口">Thread.UncaughtExceptionHandler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getDefaultUncaughtExceptionHandler()">getDefaultUncaughtExceptionHandler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回线程由于未捕获到异常而突然终止时调用的默认处理程序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getId()">getId</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回该线程的标识符。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getName()">getName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回该线程的名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getPriority()">getPriority</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回线程的优先级。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 中的类">StackTraceElement</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getStackTrace()">getStackTrace</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回一个表示该线程堆栈转储的堆栈跟踪元素数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Thread.State.html" title="java.lang 中的枚举">Thread.State</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getState()">getState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回该线程的状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getThreadGroup()">getThreadGroup</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回该线程所属的线程组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 中的接口">Thread.UncaughtExceptionHandler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getUncaughtExceptionHandler()">getUncaughtExceptionHandler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回该线程由于未捕获到异常而突然终止时调用的处理程序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#holdsLock(java.lang.Object)">holdsLock</A></B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当当前线程在指定的对象上保持监视器锁时，才返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#interrupt()">interrupt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中断线程。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#interrupted()">interrupted</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试当前线程是否已经中断。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#isAlive()">isAlive</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试线程是否处于活动状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#isDaemon()">isDaemon</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试该线程是否为守护线程。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#isInterrupted()">isInterrupted</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试线程是否已经中断。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#join()">join</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待该线程终止。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#join(long)">join</A></B>(long&nbsp;millis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待该线程终止的时间最长为 <code>millis</code> 毫秒。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#join(long, int)">join</A></B>(long&nbsp;millis,
     int&nbsp;nanos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待该线程终止的时间最长为 <code>millis</code> 毫秒 + <code>nanos</code> 纳秒。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#resume()">resume</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>该方法只与 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A> 一起使用，但 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A> 已经遭到反对，因为它具有死锁倾向。有关更多信息，请参阅<a href="http://java.sun.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？</a>。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#run()">run</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果该线程是使用独立的 <code>Runnable</code> 运行对象构造的，则调用该 <code>Runnable</code> 对象的 <code>run</code> 方法；否则，该方法不执行任何操作并返回。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setContextClassLoader(java.lang.ClassLoader)">setContextClassLoader</A></B>(<A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置该线程的上下文 ClassLoader。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setDaemon(boolean)">setDaemon</A></B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将该线程标记为守护线程或用户线程。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)">setDefaultUncaughtExceptionHandler</A></B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 中的接口">Thread.UncaughtExceptionHandler</A>&nbsp;eh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置当线程由于未捕获到异常而突然终止，并且没有为该线程定义其他处理程序时所调用的默认处理程序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setName(java.lang.String)">setName</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改变线程名称，使之与参数 <code>name</code> 相同。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setPriority(int)">setPriority</A></B>(int&nbsp;newPriority)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更改线程的优先级。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)">setUncaughtExceptionHandler</A></B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 中的接口">Thread.UncaughtExceptionHandler</A>&nbsp;eh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置该线程由于未捕获到异常而突然终止时调用的处理程序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#sleep(long)">sleep</A></B>(long&nbsp;millis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#sleep(long, int)">sleep</A></B>(long&nbsp;millis,
      int&nbsp;nanos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#start()">start</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使该线程开始执行；Java 虚拟机调用该线程的 <code>run</code> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#stop()">stop</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>该方法具有固有的不安全性。用 Thread.stop 来终止线程将释放它已经锁定的所有监视器（作为沿堆栈向上传播的未检查 <code>ThreadDeath</code> 异常的一个自然后果）。如果以前受这些监视器保护的任何对象都处于一种不一致的状态，则损坏的对象将对其他线程可见，这有可能导致任意的行为。<code>stop</code> 的许多使用都应由只修改某些变量以指示目标线程应该停止运行的代码来取代。目标线程应定期检查该变量，并且如果该变量指示它要停止运行，则从其运行方法依次返回。如果目标线程等待很长时间（例如基于一个条件变量），则应使用 <code>interrupt</code> 方法来中断该等待。有关更多信息，请参阅<a href="http://java.sun.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？</a>。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#stop(java.lang.Throwable)">stop</A></B>(<A HREF="../../java/lang/Throwable.html" title="java.lang 中的类">Throwable</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>该方法具有固有的不安全性。有关详细信息，请参阅 <A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A>。
该方法的附加危险是它可用于生成目标线程未准备处理的异常（包括若没有该方法该线程不太可能抛出的已检查的异常）。
有关更多信息，请参阅<a href="http://java.sun.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？</a>。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#suspend()">suspend</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>该方法已经遭到反对，因为它具有固有的死锁倾向。如果目标线程挂起时在保护关键系统资源的监视器上保持有锁，则在目标线程重新开始以前任何线程都不能访问该资源。如果重新开始目标线程的线程想在调用 <code>resume</code> 之前锁定该监视器，则会发生死锁。这类死锁通常会证明自己是“冻结”的进程。有关更多信息，请参阅<a href="http://java.sun.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？</a>。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回该线程的字符串表示形式，包括线程名称、优先级和线程组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#yield()">yield</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暂停当前正在执行的线程对象，并执行其他线程。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>字段详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MIN_PRIORITY"><!-- --></A><H3>
MIN_PRIORITY</H3>
<PRE>
public static final int <B>MIN_PRIORITY</B></PRE>
<DL>
<DD>线程可以具有的最低优先级。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../constant-values.html#java.lang.Thread.MIN_PRIORITY">常量字段值</A></DL>
</DL>
<HR>

<A NAME="NORM_PRIORITY"><!-- --></A><H3>
NORM_PRIORITY</H3>
<PRE>
public static final int <B>NORM_PRIORITY</B></PRE>
<DL>
<DD>分配给线程的默认优先级。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../constant-values.html#java.lang.Thread.NORM_PRIORITY">常量字段值</A></DL>
</DL>
<HR>

<A NAME="MAX_PRIORITY"><!-- --></A><H3>
MAX_PRIORITY</H3>
<PRE>
public static final int <B>MAX_PRIORITY</B></PRE>
<DL>
<DD>线程可以具有的最高优先级。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../constant-values.html#java.lang.Thread.MAX_PRIORITY">常量字段值</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Thread()"><!-- --></A><H3>
Thread</H3>
<PRE>
public <B>Thread</B>()</PRE>
<DL>
<DD>分配新的 <code>Thread</code> 对象。这种构造方法与 <code>Thread(null, null,</code> <i>gname</i><code>)</code> 具有相同的作用，其中 <b><i>gname</i></b> 是一个新生成的名称。自动生成的名称的形式为 <code>"Thread-"+</code><i>n</i>，其中的 <i>n</i> 为整数。
<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A></DL>
</DL>
<HR>

<A NAME="Thread(java.lang.Runnable)"><!-- --></A><H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;target)</PRE>
<DL>
<DD>分配新的 <code>Thread</code> 对象。这种构造方法与 <code>Thread(null, target,</code><i>gname</i><code>)</code> 具有相同的作用，其中的 <i>gname</i> 是一个新生成的名称。自动生成的名称的形式为 <code>“Thread-”+</code><i>n</i>，其中的 <i>n</i> 为整数。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>target</CODE> - 其 <code>run</code> 方法被调用的对象。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A></DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.Runnable)"><!-- --></A><H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A>&nbsp;group,
              <A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;target)</PRE>
<DL>
<DD>分配新的 <code>Thread</code> 对象。这种构造方法与 <code>Thread(group, target,</code> <i>gname</i><code>)</code> 具有相同的作用，其中的 <i>gname</i> 是一个新生成的名称。自动生成的名称的形式为 <code>"Thread-"+</code><i>n</i> ，其中的 <i>n</i> 为整数。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>group</CODE> - 线程组。<DD><CODE>target</CODE> - 其 <code>run</code> 方法被调用的对象。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程无法在指定的线程组中创建线程。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A></DL>
</DL>
<HR>

<A NAME="Thread(java.lang.String)"><!-- --></A><H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>分配新的 <code>Thread</code> 对象。这种构造方法与 <code>Thread(null, null, name)</code> 具有相同的作用。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 新线程的名称。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A></DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.String)"><!-- --></A><H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A>&nbsp;group,
              <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>分配新的 <code>Thread</code> 对象。这种构造方法与 <code>Thread(group, null, name)</code> 具有相同的作用。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>group</CODE> - 线程组。<DD><CODE>name</CODE> - 新线程的名称。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程无法在指定的线程组中创建线程。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A></DL>
</DL>
<HR>

<A NAME="Thread(java.lang.Runnable, java.lang.String)"><!-- --></A><H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;target,
              <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>分配新的 <code>Thread</code> 对象。这种构造方法与 <code>Thread(null, target, name)</code> 具有相同的作用。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>target</CODE> - 其 <code>run</code> 方法被调用的对象。<DD><CODE>name</CODE> - 新线程的名称。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A></DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><!-- --></A><H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A>&nbsp;group,
              <A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;target,
              <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>分配新的 <code>Thread</code> 对象，以便将 <code>target</code> 作为其运行对象，将指定的 <code>name</code> 作为其名称，并作为 <code>group</code> 所引用的线程组的一员。
<p>
如果 <code>group</code> 为 <code>null</code>，并且有安全管理器，则该组由安全管理器的 <code>getThreadGroup</code> 方法确定。如果 <code>group</code> 为 <code>null</code>，并且没有安全管理器，或安全管理器的 <code>getThreadGroup</code> 方法返回 <code>null</code>，则该组与创建新线程的线程被设定为相同的 ThreadGroup。
  
<p>如果有安全管理器，则其 <code>checkAccess</code> 方法通过 ThreadGroup 作为其参数被调用。
<p>此外，当被重写 <code>getContextClassLoader</code> 或 <code>setContextClassLoader</code> 方法的子类构造方法直接或间接调用时，其 <code>checkPermission</code> 方法通过 <code>RuntimePermission("enableContextClassLoaderOverride")</code> 权限调用。其结果可能是 SecurityException。

<p>
如果 <code>target</code> 参数不是 <code>null</code>，则 <code>target</code> 的 <code>run</code> 方法在启动该线程时调用。如果 target 参数为 <code>null</code>，则该线程的 <code>run</code> 方法在该线程启动时调用。
<p>
新创建线程的优先级被设定为创建该线程的线程的优先级，即当前正在运行的线程的优先级。方法 <code>setPriority</code> 可用于将优先级更改为一个新值。
<p>
当且仅当创建新线程的线程当前被标记为守护线程时，新创建的线程才被标记为守护线程。方法 <code>setDaemon </code> 可用于改变线程是否为守护线程。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>group</CODE> - 线程组。<DD><CODE>target</CODE> - 其 <code>run</code> 方法被调用的对象。<DD><CODE>name</CODE> - 新线程的名称。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程无法在指定的线程组中创建线程，或者无法重写上下文类加载器方法。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runnable.html#run()"><CODE>Runnable.run()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#setDaemon(boolean)"><CODE>setDaemon(boolean)</CODE></A>, 
<A HREF="../../java/lang/Thread.html#setPriority(int)"><CODE>setPriority(int)</CODE></A>, 
<A HREF="../../java/lang/ThreadGroup.html#checkAccess()"><CODE>ThreadGroup.checkAccess()</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(java.lang.Thread)</CODE></A></DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long)"><!-- --></A><H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A>&nbsp;group,
              <A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;target,
              <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name,
              long&nbsp;stackSize)</PRE>
<DL>
<DD>分配新的 <code>Thread</code> 对象，以便将 <code>target</code> 作为其运行对象，将指定的 <code>name</code> 作为其名称，作为 <code>group</code> 所引用的线程组的一员，并具有指定的<i>堆栈大小</i>。

<p>除了允许指定线程堆栈大小以外，这种构造方法与 <A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup,Runnable,String)</CODE></A> 完全一样。堆栈大小是虚拟机要为该线程堆栈分配的地址空间的近似字节数。<b>
<tt>stackSize</tt> 参数（如果有）的作用具有高度的平台依赖性。</b>

<p>在某些平台上，指定一个较高的 <tt>stackSize</tt> 参数值可能使线程在抛出 <A HREF="../../java/lang/StackOverflowError.html" title="java.lang 中的类"><CODE>StackOverflowError</CODE></A> 之前达到较大的递归深度。同样，指定一个较低的值将允许较多的线程并发地存在，且不会抛出 <A HREF="../../java/lang/OutOfMemoryError.html" title="java.lang 中的类"><CODE>OutOfMemoryError</CODE></A>（或其他内部错误）。<tt>stackSize</tt> 参数的值与最大递归深度和并发程度之间的关系细节与平台有关。<b>在某些平台上，<tt>stackSize</tt> 参数的值无论如何不会起任何作用。</b>
 
<p>作为建议，可以让虚拟机自由处理 <tt>stackSize</tt> 参数。如果指定值对于平台来说过低，则虚拟机可能使用某些特定于平台的最小值；如果指定值过高，则虚拟机可能使用某些特定于平台的最大值。
同样，虚拟机还会视情况自由地舍入指定值（或完全忽略它）。

<p>将 <tt>stackSize</tt> 参数值指定为零将使这种构造方法与 <tt>Thread(ThreadGroup, Runnable, String)</tt> 构造方法具有完全相同的作用。

<p><i>由于这种构造方法的行为具有平台依赖性，因此在使用它时要非常小心。执行特定计算所必需的线程堆栈大小可能会因 JRE 实现的不同而不同。鉴于这种不同，仔细调整堆栈大小参数可能是必需的，而且可能要在支持应用程序运行的 JRE 实现上反复调整。</i>

<p>实现注意事项：鼓励 Java 平台实现者文档化其 <tt>stackSize parameter</tt> 的实现行为。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>group</CODE> - 线程组。<DD><CODE>target</CODE> - 其 <code>run</code> 方法被调用的对象。<DD><CODE>name</CODE> - 新线程的名称。<DD><CODE>stackSize</CODE> - 新线程的预期堆栈大小，为零时表示忽略该参数。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程无法在指定的线程组中创建线程。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="currentThread()"><!-- --></A><H3>
currentThread</H3>
<PRE>
public static <A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A> <B>currentThread</B>()</PRE>
<DL>
<DD>返回对当前正在执行的线程对象的引用。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当前执行的线程。</DL>
</DD>
</DL>
<HR>

<A NAME="yield()"><!-- --></A><H3>
yield</H3>
<PRE>
public static void <B>yield</B>()</PRE>
<DL>
<DD>暂停当前正在执行的线程对象，并执行其他线程。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sleep(long)"><!-- --></A><H3>
sleep</H3>
<PRE>
public static void <B>sleep</B>(long&nbsp;millis)
                  throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></PRE>
<DL>
<DD>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。该线程不丢失任何监视器的所属权。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>millis</CODE> - 以毫秒为单位的休眠时间。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></CODE> - 如果任何线程中断了当前线程。当抛出该异常时，当前线程的<i>中断状态</i> 被清除。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>Object.notify()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sleep(long, int)"><!-- --></A><H3>
sleep</H3>
<PRE>
public static void <B>sleep</B>(long&nbsp;millis,
                         int&nbsp;nanos)
                  throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></PRE>
<DL>
<DD>在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。该线程不丢失任何监视器的所属权。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>millis</CODE> - 以毫秒为单位的休眠时间。<DD><CODE>nanos</CODE> - 要休眠的另外 0-999999 纳秒。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 millis 值为负或 nanos 值不在 0-999999 范围内。
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></CODE> - 如果任何线程中断了当前线程。当抛出该异常时，当前线程的<i>中断状态</i> 被清除。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>Object.notify()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="start()"><!-- --></A><H3>
start</H3>
<PRE>
public void <B>start</B>()</PRE>
<DL>
<DD>使该线程开始执行；Java 虚拟机调用该线程的 <code>run</code> 方法。
 <p>
 结果是两个线程并发地运行；当前线程（从调用返回给 <code>start</code> 方法）和另一个线程（执行其 <code>run</code> 方法）。
 <p>
 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalThreadStateException.html" title="java.lang 中的类">IllegalThreadStateException</A></CODE> - 如果线程已经启动。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="run()"><!-- --></A><H3>
run</H3>
<PRE>
public void <B>run</B>()</PRE>
<DL>
<DD>如果该线程是使用独立的 <code>Runnable</code> 运行对象构造的，则调用该 <code>Runnable</code> 对象的 <code>run</code> 方法；否则，该方法不执行任何操作并返回。
<p>
<code>Thread</code> 的子类应该重写该方法。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>接口 <CODE><A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A></CODE> 中的 <CODE><A HREF="../../java/lang/Runnable.html#run()">run</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#start()"><CODE>start()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stop()"><!-- --></A><H3>
stop</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public final void <B>stop</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>该方法具有固有的不安全性。用 Thread.stop 来终止线程将释放它已经锁定的所有监视器（作为沿堆栈向上传播的未检查 <code>ThreadDeath</code> 异常的一个自然后果）。如果以前受这些监视器保护的任何对象都处于一种不一致的状态，则损坏的对象将对其他线程可见，这有可能导致任意的行为。<code>stop</code> 的许多使用都应由只修改某些变量以指示目标线程应该停止运行的代码来取代。目标线程应定期检查该变量，并且如果该变量指示它要停止运行，则从其运行方法依次返回。如果目标线程等待很长时间（例如基于一个条件变量），则应使用 <code>interrupt</code> 方法来中断该等待。有关更多信息，请参阅<a href="http://java.sun.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？</a>。</I>
<P>
<DD>强迫线程停止执行。
<p>
如果安装了安全管理器，则以 <code>this</code> 作为其参数调用 <code>checkAccess</code> 方法。这可能引发 <code>SecurityException</code>（在当前线程中）。
<p>
如果该线程不同于当前线程（即当前线程试图终止除它本身以外的某一线程），则安全管理器的 <code>checkPermission</code> 方法（带有 <code>RuntimePermission("stopThread")</code> 参数）也会被调用。这会再次抛出 <code>SecurityException</code>（在当前线程中）。
<p>
无论该线程在做些什么，它所代表的线程都被迫异常停止，并抛出一个新创建的 <code>ThreadDeath</code> 对象，作为异常。
<p>
停止一个尚未启动的线程是允许的。
如果最后启动了该线程，它会立即终止。
<p>
应用程序通常不应试图捕获 <code>ThreadDeath</code>，除非它必须执行某些异常的清除操作（注意，抛出 <code>ThreadDeath</code> 将导致 <code>try</code> 语句的 <code>finally</code> 子句在线程正式终止前执行）。如果 <code>catch</code> 子句捕获了一个 <code>ThreadDeath</code> 对象，则重新抛出该对象很重要，因为这样该线程才会真正终止。
<p>
对其他未捕获的异常作出反应的顶级错误处理程序不会打印输出消息，或者另外通知应用程序未捕获到的异常是否为 <code>ThreadDeath</code> 的一个实例。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程不能修改该线程。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#interrupt()"><CODE>interrupt()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#start()"><CODE>start()</CODE></A>, 
<A HREF="../../java/lang/ThreadDeath.html" title="java.lang 中的类"><CODE>ThreadDeath</CODE></A>, 
<A HREF="../../java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread, java.lang.Throwable)"><CODE>ThreadGroup.uncaughtException(Thread,Throwable)</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(Thread)</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stop(java.lang.Throwable)"><!-- --></A><H3>
stop</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public final void <B>stop</B>(<A HREF="../../java/lang/Throwable.html" title="java.lang 中的类">Throwable</A>&nbsp;obj)</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>该方法具有固有的不安全性。有关详细信息，请参阅 <A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A>。
该方法的附加危险是它可用于生成目标线程未准备处理的异常（包括若没有该方法该线程不太可能抛出的已检查的异常）。
有关更多信息，请参阅<a href="http://java.sun.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？</a>。</I>
<P>
<DD>强迫线程停止执行。
<p>
如果安装了安全管理器，则调用该线程的 <code>checkAccess</code> 方法，这可能引发 <code>SecurityException</code>（在当前线程中）。 
<p>
如果该线程不同于当前线程（即当前线程试图终止除它本身以外的某一线程），或者 <code>obj</code> 不是 <code>ThreadDeath</code> 的一个实例，则安全管理器的 <code>checkPermission</code> 方法（带有 <code>RuntimePermission("stopThread")</code> 参数）也会被调用。
此外，这可能抛出 <code>SecurityException</code>（在当前线程中）。
<p>
如果参数 <code>obj</code> 为 null，则抛出 <code>NullPointerException</code>（在当前线程中）。
<p>
无论该线程在做些什么，它所代表的线程都被迫异常停止，并抛出 <code>Throwable</code> 对象 <code>obj</code>，作为一个异常。这是一种不正常的操作，通常情况下，应使用不带任何参数的 <code>stop</code> 方法。
<p>
停止一个尚未启动的线程是允许的。
如果最后启动了该线程，它会立即终止。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 要抛出的可抛出对象。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程不能修改该线程。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 obj 为 <tt>null</tt>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#interrupt()"><CODE>interrupt()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#start()"><CODE>start()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(Thread)</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="interrupt()"><!-- --></A><H3>
interrupt</H3>
<PRE>
public void <B>interrupt</B>()</PRE>
<DL>
<DD>中断线程。
 
<p> 如果当前线程没有中断它自己（这在任何情况下都是允许的），则该线程的 <A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess</CODE></A> 方法就会被调用，这可能抛出 <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类"><CODE>SecurityException</CODE></A>。

<p> 如果线程在调用 <A HREF="../../java/lang/Object.html" title="java.lang 中的类"><CODE>Object</CODE></A> 类的 <A HREF="../../java/lang/Object.html#wait()"><CODE>wait()</CODE></A>、<A HREF="../../java/lang/Object.html#wait(long)"><CODE>wait(long)</CODE></A> 或 <A HREF="../../java/lang/Object.html#wait(long, int)"><CODE>wait(long, int)</CODE></A> 方法，或者该类的 <A HREF="../../java/lang/Thread.html#join()"><CODE>join()</CODE></A>、<A HREF="../../java/lang/Thread.html#join(long)"><CODE>join(long)</CODE></A>、<A HREF="../../java/lang/Thread.html#join(long, int)"><CODE>join(long, int)</CODE></A>、<A HREF="../../java/lang/Thread.html#sleep(long)"><CODE>sleep(long)</CODE></A> 或 <A HREF="../../java/lang/Thread.html#sleep(long, int)"><CODE>sleep(long, int)</CODE></A> 方法过程中受阻，则其中断状态将被清除，它还将收到一个 <A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类"><CODE>InterruptedException</CODE></A>。

<p> 如果该线程在<A HREF="../../java/nio/channels/InterruptibleChannel.html" title="java.nio.channels 中的接口"><CODE></code>可中断的通道<code></CODE></A>上的 I/O 操作中受阻，则该通道将被关闭，该线程的中断状态将被设置并且该线程将收到一个 <A HREF="../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 中的类"><CODE>ClosedByInterruptException</CODE></A>。

<p> 如果该线程在一个 <A HREF="../../java/nio/channels/Selector.html" title="java.nio.channels 中的类"><CODE>Selector</CODE></A> 中受阻，则该线程的中断状态将被设置，它将立即从选择操作返回，并可能带有一个非零值，就好像调用了选择器的 <A HREF="../../java/nio/channels/Selector.html#wakeup()"><CODE>wakeup</CODE></A> 方法一样。

<p> 如果以前的条件都没有保存，则该线程的中断状态将被设置。</p>

<p> 中断一个不处于活动状态的线程不需要任何作用。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程无法修改该线程</DL>
</DD>
</DL>
<HR>

<A NAME="interrupted()"><!-- --></A><H3>
interrupted</H3>
<PRE>
public static boolean <B>interrupted</B>()</PRE>
<DL>
<DD>测试当前线程是否已经中断。线程的<i>中断状态</i> 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。

<p>线程中断被忽略，因为在中断时不处于活动状态的线程将由此返回 false 的方法反映出来。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果当前线程已经中断，则返回 <code>true</code>；否则返回 <code>false</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#isInterrupted()"><CODE>isInterrupted()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isInterrupted()"><!-- --></A><H3>
isInterrupted</H3>
<PRE>
public boolean <B>isInterrupted</B>()</PRE>
<DL>
<DD>测试线程是否已经中断。线程的<i>中断状态</i> 不受该方法的影响。

<p>线程中断被忽略，因为在中断时不处于活动状态的线程将由此返回 false 的方法反映出来。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果该线程已经中断，则返回 <code>true</code>；否则返回 <code>false</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#interrupted()"><CODE>interrupted()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="destroy()"><!-- --></A><H3>
destroy</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public void <B>destroy</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>该方法最初用于破坏该线程，但不作任何清除。它所保持的任何监视器都会保持锁定状态。不过，该方法决不会被实现。即使要实现，它也极有可能以 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A> 方式被死锁。如果目标线程被破坏时保持一个保护关键系统资源的锁，则任何线程在任何时候都无法再次访问该资源。如果另一个线程曾试图锁定该资源，则会出现死锁。这类死锁通常会证明它们自己是“冻结”的进程。有关更多信息，请参阅<a href="http://java.sun.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？</a>。</I>
<P>
<DD>抛出 <A HREF="../../java/lang/NoSuchMethodError.html" title="java.lang 中的类"><CODE>NoSuchMethodError</CODE></A>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NoSuchMethodError.html" title="java.lang 中的类">NoSuchMethodError</A></CODE> - 始终</DL>
</DD>
</DL>
<HR>

<A NAME="isAlive()"><!-- --></A><H3>
isAlive</H3>
<PRE>
public final boolean <B>isAlive</B>()</PRE>
<DL>
<DD>测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果该线程处于活动状态，则返回 <code>true</code>；否则返回 <code>false</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="suspend()"><!-- --></A><H3>
suspend</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public final void <B>suspend</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>该方法已经遭到反对，因为它具有固有的死锁倾向。如果目标线程挂起时在保护关键系统资源的监视器上保持有锁，则在目标线程重新开始以前任何线程都不能访问该资源。如果重新开始目标线程的线程想在调用 <code>resume</code> 之前锁定该监视器，则会发生死锁。这类死锁通常会证明自己是“冻结”的进程。有关更多信息，请参阅<a href="http://java.sun.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？</a>。</I>
<P>
<DD>挂起线程。
<p>
首先，调用线程的 <code>checkAccess</code> 方法，且不带任何参数。这可能抛出 <code>SecurityException</code>（在当前线程中）。
<p>
如果线程处于活动状态则被挂起，且不再有进一步的活动，除非重新开始。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程不能修改该线程。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resume()"><!-- --></A><H3>
resume</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public final void <B>resume</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>该方法只与 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A> 一起使用，但 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A> 已经遭到反对，因为它具有死锁倾向。有关更多信息，请参阅<a href="http://java.sun.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？</a>。</I>
<P>
<DD>重新开始挂起的进程。
<p>
首先，调用线程的 <code>checkAccess</code> 方法，且不带任何参数。这可能抛出 <code>SecurityException</code>（在当前线程中）。
<p>
如果线程处于活动状态但被挂起，则它会在执行过程中重新开始并允许继续活动。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程不能修改该线程。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setPriority(int)"><!-- --></A><H3>
setPriority</H3>
<PRE>
public final void <B>setPriority</B>(int&nbsp;newPriority)</PRE>
<DL>
<DD>更改线程的优先级。
 <p>
 首先调用线程的 <code>checkAccess</code> 方法，且不带任何参数。这可能抛出 <code>SecurityException</code>。
 <p>
 在其他情况下，线程优先级被设定为指定的 <code>newPriority</code> 和该线程的线程组的最大允许优先级相比较小的一个。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>newPriority</CODE> - 要为线程设定的优先级
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果优先级不在 <code>MIN_PRIORITY</code> 到 <code>MAX_PRIORITY</code> 范围内。
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程无法修改该线程。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#getPriority()"><CODE>getPriority()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#getThreadGroup()"><CODE>getThreadGroup()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#MAX_PRIORITY"><CODE>MAX_PRIORITY</CODE></A>, 
<A HREF="../../java/lang/Thread.html#MIN_PRIORITY"><CODE>MIN_PRIORITY</CODE></A>, 
<A HREF="../../java/lang/ThreadGroup.html#getMaxPriority()"><CODE>ThreadGroup.getMaxPriority()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPriority()"><!-- --></A><H3>
getPriority</H3>
<PRE>
public final int <B>getPriority</B>()</PRE>
<DL>
<DD>返回线程的优先级。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该线程的优先级。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#setPriority(int)"><CODE>setPriority(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setName(java.lang.String)"><!-- --></A><H3>
setName</H3>
<PRE>
public final void <B>setName</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>改变线程名称，使之与参数 <code>name</code> 相同。
 <p>
 首先调用线程的 <code>checkAccess</code> 方法，且不带任何参数。这可能抛出 <code>SecurityException</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 该线程的新名称。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程不能修改该线程。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#getName()"><CODE>getName()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getName()"><!-- --></A><H3>
getName</H3>
<PRE>
public final <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getName</B>()</PRE>
<DL>
<DD>返回该线程的名称。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该线程的名称。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#setName(java.lang.String)"><CODE>setName(String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getThreadGroup()"><!-- --></A><H3>
getThreadGroup</H3>
<PRE>
public final <A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类">ThreadGroup</A> <B>getThreadGroup</B>()</PRE>
<DL>
<DD>返回该线程所属的线程组。
 如果该线程已经终止（停止运行），该方法则返回 null。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该线程的线程组。</DL>
</DD>
</DL>
<HR>

<A NAME="activeCount()"><!-- --></A><H3>
activeCount</H3>
<PRE>
public static int <B>activeCount</B>()</PRE>
<DL>
<DD>返回当前线程的线程组中活动线程的数目。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>当前线程的线程组中活动线程的数目。</DL>
</DD>
</DL>
<HR>

<A NAME="enumerate(java.lang.Thread[])"><!-- --></A><H3>
enumerate</H3>
<PRE>
public static int <B>enumerate</B>(<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>[]&nbsp;tarray)</PRE>
<DL>
<DD>将当前线程的线程组及其子组中的每一个活动线程复制到指定的数组中。该方法只调用当前线程的线程组的 <code>enumerate</code> 方法，且带有数组参数。
<p>
首先，如果有安全管理器，则 <code>enumerate</code> 方法调用安全管理器的 <code>checkAccess</code> 方法，并将线程组作为其参数。这可能导致抛出 <code>SecurityException</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>tarray</CODE> - 要复制到的线程对象数组
<DT><B>返回：</B><DD>放入该数组的线程数
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <code>checkAccess</code> 方法不允许该操作。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ThreadGroup.html#enumerate(java.lang.Thread[])"><CODE>ThreadGroup.enumerate(Thread[])</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.ThreadGroup)"><CODE>SecurityManager.checkAccess(ThreadGroup)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="countStackFrames()"><!-- --></A><H3>
countStackFrames</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public int <B>countStackFrames</B>()</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>该调用的定义依赖于 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>，但它遭到了反对。此外，该调用的结果从来都不是意义明确的。</I>
<P>
<DD>计算该线程中的堆栈帧数。线程必须挂起。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该线程中的堆栈帧数。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalThreadStateException.html" title="java.lang 中的类">IllegalThreadStateException</A></CODE> - 如果该线程未挂起。</DL>
</DD>
</DL>
<HR>

<A NAME="join(long)"><!-- --></A><H3>
join</H3>
<PRE>
public final void <B>join</B>(long&nbsp;millis)
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></PRE>
<DL>
<DD>等待该线程终止的时间最长为 <code>millis</code> 毫秒。超时为 <code>0</code> 意味着要一直等下去。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>millis</CODE> - 以毫秒为单位的等待时间。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></CODE> - 如果任何线程中断了当前线程。当抛出该异常时，当前线程的<i>中断状态</i> 被清除。</DL>
</DD>
</DL>
<HR>

<A NAME="join(long, int)"><!-- --></A><H3>
join</H3>
<PRE>
public final void <B>join</B>(long&nbsp;millis,
                       int&nbsp;nanos)
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></PRE>
<DL>
<DD>等待该线程终止的时间最长为 <code>millis</code> 毫秒 + <code>nanos</code> 纳秒。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>millis</CODE> - 以毫秒为单位的等待时间。<DD><CODE>nanos</CODE> - 要等待的 0-999999 附加纳秒。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 millis 值为负，则 nanos 的值不在 0-999999 范围内。
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></CODE> - 如果任何线程中断了当前线程。当抛出该异常时，当前线程的<i>中断状态</i> 被清除。</DL>
</DD>
</DL>
<HR>

<A NAME="join()"><!-- --></A><H3>
join</H3>
<PRE>
public final void <B>join</B>()
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></PRE>
<DL>
<DD>等待该线程终止。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></CODE> - 如果任何线程中断了当前线程。当抛出该异常时，当前线程的<i>中断状态</i> 被清除。</DL>
</DD>
</DL>
<HR>

<A NAME="dumpStack()"><!-- --></A><H3>
dumpStack</H3>
<PRE>
public static void <B>dumpStack</B>()</PRE>
<DL>
<DD>将当前线程的堆栈跟踪打印至标准错误流。该方法仅用于调试。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Throwable.html#printStackTrace()"><CODE>Throwable.printStackTrace()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setDaemon(boolean)"><!-- --></A><H3>
setDaemon</H3>
<PRE>
public final void <B>setDaemon</B>(boolean&nbsp;on)</PRE>
<DL>
<DD>将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。
 <p>
 该方法必须在启动线程前调用。
 <p>
 该方法首先调用该线程的 <code>checkAccess</code> 方法，且不带任何参数。这可能抛出 <code>SecurityException</code>（在当前线程中）。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>on</CODE> - 如果为 <code>true</code>，则将该线程标记为守护线程。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalThreadStateException.html" title="java.lang 中的类">IllegalThreadStateException</A></CODE> - 如果该线程处于活动状态。
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程无法修改该线程。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#isDaemon()"><CODE>isDaemon()</CODE></A>, 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isDaemon()"><!-- --></A><H3>
isDaemon</H3>
<PRE>
public final boolean <B>isDaemon</B>()</PRE>
<DL>
<DD>测试该线程是否为守护线程。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果该线程是守护线程，则返回 <code>true</code>；否则返回 <code>false</code>。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#setDaemon(boolean)"><CODE>setDaemon(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkAccess()"><!-- --></A><H3>
checkAccess</H3>
<PRE>
public final void <B>checkAccess</B>()</PRE>
<DL>
<DD>判定当前运行的线程是否有权修改该线程。
 <p>
 如果有安全管理器，则调用其 <code>checkAccess</code> 方法，并将该线程作为其参数。这可能导致抛出 <code>SecurityException</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果不允许当前线程访问该线程。<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(Thread)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>()</PRE>
<DL>
<DD>返回该线程的字符串表示形式，包括线程名称、优先级和线程组。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该线程的字符串表示形式。</DL>
</DD>
</DL>
<HR>

<A NAME="getContextClassLoader()"><!-- --></A><H3>
getContextClassLoader</H3>
<PRE>
public <A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A> <B>getContextClassLoader</B>()</PRE>
<DL>
<DD>返回该线程的上下文 ClassLoader。上下文 ClassLoader 由线程创建者提供，供运行于该线程中的代码在加载类和资源时使用。如果未设定，则默认为父线程的 ClassLoader 上下文。原始线程的上下文 ClassLoader 通常设定为用于加载应用程序的类加载器。

<p>首先，如果有安全管理器，并且调用者的类加载器不是 null，也不同于其上下文类加载器正在被请求的线程上下文类加载器的祖先，则通过 <code>RuntimePermission("getClassLoader")</code> 权限调用该安全管理器的 <code>checkPermission</code> 方法，查看是否可以获取上下文 ClassLoader。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该线程的上下文 ClassLoader<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#setContextClassLoader(java.lang.ClassLoader)"><CODE>setContextClassLoader(java.lang.ClassLoader)</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>, 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setContextClassLoader(java.lang.ClassLoader)"><!-- --></A><H3>
setContextClassLoader</H3>
<PRE>
public void <B>setContextClassLoader</B>(<A HREF="../../java/lang/ClassLoader.html" title="java.lang 中的类">ClassLoader</A>&nbsp;cl)</PRE>
<DL>
<DD>设置该线程的上下文 ClassLoader。上下文 ClassLoader 可以在创建线程设置，并允许创建者在加载类和资源时向该线程中运行的代码提供适当的类加载器。

<p>首先，如果有安全管理器，则通过 <code>RuntimePermission("setContextClassLoader")</code> 权限调用其 <code>checkPermission</code> 方法，查看是否可以设置上下文 ClassLoader。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>cl</CODE> - 该线程的上下文 ClassLoader
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程无法设置上下文 ClassLoader。<DT><B>从以下版本开始：</B></DT>
  <DD>1.2</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#getContextClassLoader()"><CODE>getContextClassLoader()</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>, 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="holdsLock(java.lang.Object)"><!-- --></A><H3>
holdsLock</H3>
<PRE>
public static boolean <B>holdsLock</B>(<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</PRE>
<DL>
<DD>当且仅当当前线程在指定的对象上保持监视器锁时，才返回 <tt>true</tt>。

<p>该方法旨在使程序能够断言当前线程已经保持一个指定的锁：
<pre>
     assert Thread.holdsLock(obj);
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 用于测试锁所属权的对象
<DT><B>返回：</B><DD>如果当前线程在指定的对象上保持监视器锁，则返回 <tt>true</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 obj 为 <tt>null</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getStackTrace()"><!-- --></A><H3>
getStackTrace</H3>
<PRE>
public <A HREF="../../java/lang/StackTraceElement.html" title="java.lang 中的类">StackTraceElement</A>[] <B>getStackTrace</B>()</PRE>
<DL>
<DD>返回一个表示该线程堆栈转储的堆栈跟踪元素数组。如果该线程尚未启动或已经终止，则该方法将返回一个零长度数组。如果返回的数组不是零长度的，则其第一个元素代表堆栈顶，它是该序列中最新的方法调用。最后一个元素代表堆栈底，是该序列中最旧的方法调用。

<p>如果有安全管理器，并且该线程不是当前线程，则通过
<tt>RuntimePermission("getStackTrace")</tt> 权限调用安全管理器的 <tt>checkPermission</tt> 方法，查看是否可以获取堆栈跟踪。

<p>某些虚拟机在某些情况下可能会从堆栈跟踪中省略一个或多个堆栈帧。在极端情况下，没有该线程堆栈跟踪信息的虚拟机可以从该方法返回一个零长度数组。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD><tt>StackTraceElement</tt> 数组，每个数组代表一个堆栈帧。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <tt>checkPermission</tt> 方法不允许获取线程的堆栈跟踪。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>, 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A>, 
<A HREF="../../java/lang/Throwable.html#getStackTrace()"><CODE>Throwable.getStackTrace()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAllStackTraces()"><!-- --></A><H3>
getAllStackTraces</H3>
<PRE>
public static <A HREF="../../java/util/Map.html" title="java.util 中的接口">Map</A>&lt;<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>,<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 中的类">StackTraceElement</A>[]&gt; <B>getAllStackTraces</B>()</PRE>
<DL>
<DD>返回所有活动线程的堆栈跟踪的一个映射。映射键是线程，而每个映射值都是一个 <tt>StackTraceElement</tt> 数组，该数组表示相应 <tt>Thread</tt> 的堆栈转储。
返回的堆栈跟踪的格式都是针对 <A HREF="../../java/lang/Thread.html#getStackTrace()"><CODE>getStackTrace</CODE></A> 方法指定的。

<p>在调用该方法的同时，线程可能也在执行。每个线程的堆栈跟踪仅代表一个快照，并且每个堆栈跟踪都可以在不同时间获得。如果虚拟机没有线程的堆栈跟踪信息，则映射值中将返回一个零长度数组。

<p>如果有安全管理器，则通过 <tt>RuntimePermission("getStackTrace")</tt> 权限和 <tt>RuntimePermission("modifyThreadGroup")</tt> 权限调用其 <tt>checkPermission</tt> 方法，查看是否可以获取所有线程的堆栈跟踪。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>从 <tt>Thread</tt> 到 <tt>StackTraceElement</tt> 数组的一个 <tt>Map</tt>，代表相应线程的堆栈跟踪。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <tt>checkPermission</tt> 方法不允许获取线程的堆栈跟踪。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#getStackTrace()"><CODE>getStackTrace()</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>, 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A>, 
<A HREF="../../java/lang/Throwable.html#getStackTrace()"><CODE>Throwable.getStackTrace()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getId()"><!-- --></A><H3>
getId</H3>
<PRE>
public long <B>getId</B>()</PRE>
<DL>
<DD>返回该线程的标识符。线程 ID 是一个正的 <tt>long</tt> 数，在创建该线程时生成。线程 ID 是唯一的，并终生不变。线程终止时，该线程 ID 可以被重新使用。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该线程的 ID。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getState()"><!-- --></A><H3>
getState</H3>
<PRE>
public <A HREF="../../java/lang/Thread.State.html" title="java.lang 中的枚举">Thread.State</A> <B>getState</B>()</PRE>
<DL>
<DD>返回该线程的状态。
 该方法用于监视系统状态，不用于同步控制。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该线程的状态。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><!-- --></A><H3>
setDefaultUncaughtExceptionHandler</H3>
<PRE>
public static void <B>setDefaultUncaughtExceptionHandler</B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 中的接口">Thread.UncaughtExceptionHandler</A>&nbsp;eh)</PRE>
<DL>
<DD>设置当线程由于未捕获到异常而突然终止，并且没有为该线程定义其他处理程序时所调用的默认处理程序。

<p>未捕获到的异常处理首先由线程控制，然后由线程的 <A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类"><CODE>ThreadGroup</CODE></A> 对象控制，最后由未捕获到的默认异常处理程序控制。如果线程不设置明确的未捕获到的异常处理程序，并且该线程的线程组（包括父线程组）未特别指定其 <tt>uncaughtException</tt> 方法，则将调用默认处理程序的 <tt>uncaughtException</tt> 方法。
<p>通过设置未捕获到的默认异常处理程序，应用程序可以为那些已经接受系统提供的任何“默认”行为的线程改变未捕获到的异常处理方式（如记录到某一特定设备或文件）。

<p>请注意，未捕获到的默认异常处理程序通常不应顺从该线程的 <tt>ThreadGroup</tt> 对象，因为这可能导致无限递归。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>eh</CODE> - 用作未捕获到的默认异常处理程序的对象。
 如果为 <tt>null</tt>，则没有默认处理程序。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在并拒绝 <tt><A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A>
         (&quot;setDefaultUncaughtExceptionHandler&quot;)</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><CODE>setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</CODE></A>, 
<A HREF="../../java/lang/Thread.html#getUncaughtExceptionHandler()"><CODE>getUncaughtExceptionHandler()</CODE></A>, 
<A HREF="../../java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread, java.lang.Throwable)"><CODE>ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultUncaughtExceptionHandler()"><!-- --></A><H3>
getDefaultUncaughtExceptionHandler</H3>
<PRE>
public static <A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 中的接口">Thread.UncaughtExceptionHandler</A> <B>getDefaultUncaughtExceptionHandler</B>()</PRE>
<DL>
<DD>返回线程由于未捕获到异常而突然终止时调用的默认处理程序。如果返回值为 <tt>null</tt>，则没有默认处理程序。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><CODE>setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getUncaughtExceptionHandler()"><!-- --></A><H3>
getUncaughtExceptionHandler</H3>
<PRE>
public <A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 中的接口">Thread.UncaughtExceptionHandler</A> <B>getUncaughtExceptionHandler</B>()</PRE>
<DL>
<DD>返回该线程由于未捕获到异常而突然终止时调用的处理程序。如果该线程尚未明确设置未捕获到的异常处理程序，则返回该线程的 <tt>ThreadGroup</tt> 对象，除非该线程已经终止，在这种情况下，将返回 <tt>null</tt>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><!-- --></A><H3>
setUncaughtExceptionHandler</H3>
<PRE>
public void <B>setUncaughtExceptionHandler</B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 中的接口">Thread.UncaughtExceptionHandler</A>&nbsp;eh)</PRE>
<DL>
<DD>设置该线程由于未捕获到异常而突然终止时调用的处理程序。
<p>通过明确设置未捕获到的异常处理程序，线程可以完全控制它对未捕获到的异常作出响应的方式。
如果没有设置这样的处理程序，则该线程的 <tt>ThreadGroup</tt> 对象将充当其处理程序。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>eh</CODE> - 用作该线程未捕获到的异常处理程序的对象。如果为 <tt>null</tt>，则该线程没有明确的处理程序。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果当前线程无权修改该线程。<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><CODE>setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</CODE></A>, 
<A HREF="../../java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread, java.lang.Throwable)"><CODE>ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Thread.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/System.html" title="java.lang 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/lang/Thread.State.html" title="java.lang 中的枚举"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Thread.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Thread.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
