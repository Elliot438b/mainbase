<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 12:48:28 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
Runtime (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Runtime (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Runtime.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/lang/RuntimeException.html" title="java.lang 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Runtime.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Runtime.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
类 Runtime</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="继承者 "><B>java.lang.Runtime</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Runtime</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A></DL>
</PRE>

<P>
每个 Java 应用程序都有一个 <code>Runtime</code> 类实例，使应用程序能够与其运行的环境相连接。可以通过 <code>getRuntime</code> 方法获取当前运行时。 
 <p>
应用程序不能创建自己的 Runtime 类实例。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.0</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#getRuntime()"><CODE>getRuntime()</CODE></A></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#addShutdownHook(java.lang.Thread)">addShutdownHook</A></B>(<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>&nbsp;hook)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册新的虚拟机来关闭钩子。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#availableProcessors()">availableProcessors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向 Java 虚拟机返回可用处理器的数目。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#exec(java.lang.String)">exec</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;command)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在单独的进程中执行指定的字符串命令。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#exec(java.lang.String[])">exec</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;cmdarray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在单独的进程中执行指定命令和变量。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#exec(java.lang.String[], java.lang.String[])">exec</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;cmdarray,
     <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;envp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在指定环境的独立进程中执行指定命令和变量。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#exec(java.lang.String[], java.lang.String[], java.io.File)">exec</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;cmdarray,
     <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;envp,
     <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;dir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在指定环境和工作目录的独立进程中执行指定的命令和变量。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#exec(java.lang.String, java.lang.String[])">exec</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;command,
     <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;envp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在指定环境的单独进程中执行指定的字符串命令。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#exec(java.lang.String, java.lang.String[], java.io.File)">exec</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;command,
     <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;envp,
     <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;dir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在有指定环境和工作目录的独立进程中执行指定的字符串命令。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#exit(int)">exit</A></B>(int&nbsp;status)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过启动虚拟机的关闭序列，终止当前正在运行的 Java 虚拟机。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#freeMemory()">freeMemory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 Java 虚拟机中的空闲内存量。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#gc()">gc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行垃圾回收器。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/InputStream.html" title="java.io 中的类">InputStream</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#getLocalizedInputStream(java.io.InputStream)">getLocalizedInputStream</A></B>(<A HREF="../../java/io/InputStream.html" title="java.io 中的类">InputStream</A>&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>从 JDK&nbsp;1.1 开始，将本地编码字节流转换为 Unicode 字符流的首选方法是使用 <code>InputStreamReader</code> 和 <code>BufferedReader</code> 类。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#getLocalizedOutputStream(java.io.OutputStream)">getLocalizedOutputStream</A></B>(<A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>从 JDK&nbsp;1.1 开始，将 Unicode 字符流转换为本地编码字节流的首选方法是使用 <code>OutputStreamWriter</code>、<code>BufferedWriter</code> 和 <code>PrintWriter</code> 类。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Runtime.html" title="java.lang 中的类">Runtime</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#getRuntime()">getRuntime</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回与当前 Java 应用程序相关的运行时对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#halt(int)">halt</A></B>(int&nbsp;status)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;强行终止目前正在运行的 Java 虚拟机。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#load(java.lang.String)">load</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;filename)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载作为动态库的指定文件名。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#loadLibrary(java.lang.String)">loadLibrary</A></B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;libname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载具有指定库名的动态库。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#maxMemory()">maxMemory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 Java 虚拟机试图使用的最大内存量。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#removeShutdownHook(java.lang.Thread)">removeShutdownHook</A></B>(<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>&nbsp;hook)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取消注册某个先前已注册的虚拟机关闭钩子。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#runFinalization()">runFinalization</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行挂起 finalization 的所有对象的终止方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#runFinalizersOnExit(boolean)">runFinalizersOnExit</A></B>(boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>已过时。</B>&nbsp;<I>此方法本身具有不安全性。它可能对正在使用的对象调用终结方法，而其他线程正在操作这些对象，从而导致不正确的行为或死锁。</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#totalMemory()">totalMemory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 Java 虚拟机中的内存总量。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#traceInstructions(boolean)">traceInstructions</A></B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启用／禁用指令跟踪。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Runtime.html#traceMethodCalls(boolean)">traceMethodCalls</A></B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启用／禁用方法调用跟踪。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getRuntime()"><!-- --></A><H3>
getRuntime</H3>
<PRE>
public static <A HREF="../../java/lang/Runtime.html" title="java.lang 中的类">Runtime</A> <B>getRuntime</B>()</PRE>
<DL>
<DD>返回与当前 Java 应用程序相关的运行时对象。<code>Runtime</code> 类的大多数方法是实例方法，并且必须根据当前的运行时对象对其进行调用。
<P>
<DD><DL>

<DT><B>返回：</B><DD>与当前 Java 应用程序相关的 <code>Runtime</code> 对象。</DL>
</DD>
</DL>
<HR>

<A NAME="exit(int)"><!-- --></A><H3>
exit</H3>
<PRE>
public void <B>exit</B>(int&nbsp;status)</PRE>
<DL>
<DD>通过启动虚拟机的关闭序列，终止当前正在运行的 Java 虚拟机。此方法从不正常返回。可以将变量作为一个状态码；根据惯例，非零的状态码表示非正常终止。

<p> 虚拟机的关闭序列包含两个阶段。在第一个阶段中，会以某种未指定的顺序启动所有已注册的<A HREF="../../java/lang/Runtime.html#addShutdownHook(java.lang.Thread)"><CODE>关闭钩子 (hook)</CODE></A>（如果有的话），并且允许它们同时运行直至结束。在第二个阶段中，如果已启用<A HREF="../../java/lang/Runtime.html#runFinalizersOnExit(boolean)"><CODE>退出终结</CODE></A>，则运行所有未调用的终结方法。一旦完成这个阶段，虚拟机就会<A HREF="../../java/lang/Runtime.html#halt(int)"><CODE>暂停</CODE></A>。

<p> 如果在虚拟机已开始其关闭序列后才调用此方法，那么若正在运行关闭钩子，则将无限期地阻断此方法。如果已经运行完关闭钩子，并且已启用退出终结 (on-exit finalization)，那么此方法将利用给定的状态码（如果状态码是非零值）暂停虚拟机；否则将无限期地阻断虚拟机。

<p> <tt><A HREF="../../java/lang/System.html#exit(int)"><CODE>System.exit</CODE></A></tt> 方法是调用此方法的一种传统而便捷的方式。 <p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>status</CODE> - 终止状态。按照惯例，非零的状态码表明非正常终止。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <tt><A HREF="../../java/lang/SecurityManager.html#checkExit(int)"><CODE>checkExit</CODE></A></tt> 方法不允许存在指定的状态<DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类"><CODE>SecurityException</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkExit(int)"><CODE>SecurityManager.checkExit(int)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#addShutdownHook(java.lang.Thread)"><CODE>addShutdownHook(java.lang.Thread)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#removeShutdownHook(java.lang.Thread)"><CODE>removeShutdownHook(java.lang.Thread)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#runFinalizersOnExit(boolean)"><CODE>runFinalizersOnExit(boolean)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#halt(int)"><CODE>halt(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addShutdownHook(java.lang.Thread)"><!-- --></A><H3>
addShutdownHook</H3>
<PRE>
public void <B>addShutdownHook</B>(<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>&nbsp;hook)</PRE>
<DL>
<DD>注册新的虚拟机来关闭钩子。

<p> Java 虚拟机会为了响应以下两类事件而<i>关闭</i>：

   <ul>

<p> <li> 程序正常<i>退出</i>，这发生在最后的非守护线程退出时，或者在调用 <tt><A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>exit</CODE></A></tt>（等同于 <tt><A HREF="../../java/lang/System.html#exit(int)"><CODE>System.exit</CODE></A></tt>）方法时。或者，

<p> <li> 为响应用户中断而<i>终止</i> 虚拟机，如键入 <tt>^C</tt>；或发生系统事件，比如用户注销或系统关闭。

   </ul>

<p> <i>关闭钩子</i> 只是一个已初始化但尚未启动的线程。虚拟机开始启用其关闭序列时，它会以某种未指定的顺序启动所有已注册的关闭钩子，并让它们同时运行。运行完所有的钩子后，如果已启用退出终结，那么虚拟机接着会运行所有未调用的终结方法。最后，虚拟机会暂停。注意，关闭序列期间会继续运行守护线程，如果通过调用 <tt><A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>exit</CODE></A></tt> 方法来发起关闭序列，那么也会继续运行非守护线程。

<p> 一旦开始了关闭序列，则只能通过调用 <tt><A HREF="../../java/lang/Runtime.html#halt(int)"><CODE>halt</CODE></A></tt> 方法来停止这个序列，此方法可强行终止虚拟机。

<p> 一旦开始了关闭序列，则不可能注册新的关闭钩子或取消注册先前已注册的钩子。尝试执行这些操作会导致抛出 <tt><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 中的类"><CODE>IllegalStateException</CODE></A></tt>。

<p> 关闭钩子可在虚拟机生命周期中的特定时间运行，因此应保护性地对其进行编码。特别是应将关闭钩子编写为线程安全的，并尽可能地避免死锁。关闭钩子还应该不盲目地依靠某些服务，这些服务可能已注册了自己的关闭钩子，所以其本身可能正处于关闭进程中。例如，试图使用其他基于线程的服务（如 AWT 事件指派线程）可能导致死锁。

<p> 关闭钩子应该快速地完成其工作。当程序调用 <tt><A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>exit</CODE></A></tt> 时，虚拟机应该迅速地关闭并退出。由于用户注销或系统关闭而终止虚拟机时，底层的操作系统可能只允许在固定的时间内关闭并退出。因此在关闭钩子中尝试进行任何用户交互或执行长时间的计算都是不明智的。

<p> 与其他所有线程一样，通过调用线程 <tt><A HREF="../../java/lang/ThreadGroup.html" title="java.lang 中的类"><CODE>ThreadGroup</CODE></A></tt> 对象的 <tt><A HREF="../../java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread, java.lang.Throwable)"><CODE>uncaughtException</CODE></A></tt> 方法，可在关闭钩子中处理未捕获的异常。此方法的默认实现是将该异常的堆栈跟踪打印至 <tt><A HREF="../../java/lang/System.html#err"><CODE>System.err</CODE></A></tt> 并终止线程；它不会导致虚拟机退出或暂停。

<p> 仅在很少的情况下，虚拟机可能会<i>中止</i>，也就是没有完全关闭就停止运行。虚拟机被外部终止时会出现这种现象，比如在 Unix 上使用 <tt>SIGKILL</tt> 信号或者在 Microsoft Windows 上调用 <tt>TerminateProcess</tt>。如果由于内部数据结构损坏或试图访问不存在的内存而导致本机方法执行错误，那么可能也会中止虚拟机。如果虚拟机中止，则无法保证是否将运行关闭钩子。 <p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>hook</CODE> - 一个已初始化但尚未启动的 <tt><A HREF="../../java/lang/Thread.html" title="java.lang 中的类"><CODE>Thread</CODE></A></tt> 对象
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果指定的钩子已注册，或者可以确定钩子正在运行或者已运行完毕
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果虚拟机已经处于关闭进程中
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在并且拒绝 <tt><A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A>(&quot;shutdownHooks&quot;)</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.3</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#removeShutdownHook(java.lang.Thread)"><CODE>removeShutdownHook(java.lang.Thread)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#halt(int)"><CODE>halt(int)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>exit(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeShutdownHook(java.lang.Thread)"><!-- --></A><H3>
removeShutdownHook</H3>
<PRE>
public boolean <B>removeShutdownHook</B>(<A HREF="../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>&nbsp;hook)</PRE>
<DL>
<DD>取消注册某个先前已注册的虚拟机关闭钩子。 <p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>hook</CODE> - 要删除的钩子
<DT><B>返回：</B><DD>如果指定的钩子先前已注册并且成功地取消注册，则返回 <tt>true</tt>，其他情况返回 <tt>false</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果虚拟机已经处于关闭进程中
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在并且拒绝 <tt><A HREF="../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A>(&quot;shutdownHooks&quot;)</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.3</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#addShutdownHook(java.lang.Thread)"><CODE>addShutdownHook(java.lang.Thread)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>exit(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="halt(int)"><!-- --></A><H3>
halt</H3>
<PRE>
public void <B>halt</B>(int&nbsp;status)</PRE>
<DL>
<DD>强行终止目前正在运行的 Java 虚拟机。此方法从不正常返回。 

<p> 应小心使用此方法。与 <tt><A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>exit</CODE></A></tt> 方法不同，此方法不会启动关闭钩子，并且如果已启用退出终结，此方法也不会运行未调用的终结方法。如果已经发起关闭序列，那么此方法不会等待所有正在运行的关闭钩子或终结方法完成其工作。 <p>
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>status</CODE> - 终止状态。按照惯例，非零的状态码表明非正常终止。如果已经调用了 <tt><A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>exit</CODE></A></tt>（<tt><A HREF="../../java/lang/System.html#exit(int)"><CODE>System.exit</CODE></A></tt> 也一样）方法，那么该状态码将重写已传递至此方法的状态码。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <tt><A HREF="../../java/lang/SecurityManager.html#checkExit(int)"><CODE>checkExit</CODE></A></tt> 方法不允许具有指定状态时退出<DT><B>从以下版本开始：</B></DT>
  <DD>1.3</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>exit(int)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#addShutdownHook(java.lang.Thread)"><CODE>addShutdownHook(java.lang.Thread)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#removeShutdownHook(java.lang.Thread)"><CODE>removeShutdownHook(java.lang.Thread)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="runFinalizersOnExit(boolean)"><!-- --></A><H3>
runFinalizersOnExit</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public static void <B>runFinalizersOnExit</B>(boolean&nbsp;value)</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>此方法本身具有不安全性。它可能对正在使用的对象调用终结方法，而其他线程正在操作这些对象，从而导致不正确的行为或死锁。</I>
<P>
<DD>在退出时启用或禁用终结；这样做可指定拥有未被自动调用终结方法的所有对象的终结方法，并将在退出 Java 运行时前运行此终结方法。默认情况下，禁用退出终结。
 
<p>如果有安全管理器，则首先使用 0 作为变量来调用其 <code>checkExit</code> 方法，以确保允许退出。这可能会导致 SecurityException。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>value</CODE> - 如果启用退出时终结，则该参数为 true，如果禁用退出时终结，则该参数为 false
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在并且其 <code>checkExit</code> 方法不允许退出。<DT><B>从以下版本开始：</B></DT>
  <DD>JDK1.1</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>exit(int)</CODE></A>, 
<A HREF="../../java/lang/Runtime.html#gc()"><CODE>gc()</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkExit(int)"><CODE>SecurityManager.checkExit(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="exec(java.lang.String)"><!-- --></A><H3>
exec</H3>
<PRE>
public <A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A> <B>exec</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;command)
             throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>在单独的进程中执行指定的字符串命令。

<p>这是一个很有用的方法。对于 <tt>exec(command)</tt> 形式的调用而言，其行为与调用 <tt><A HREF="../../java/lang/Runtime.html#exec(java.lang.String, java.lang.String[], java.io.File)"><CODE>exec</CODE></A>(command, null, null)</tt> 完全相同。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>command</CODE> - 一条指定的系统命令。
<DT><B>返回：</B><DD>一个新的 <A HREF="../../java/lang/Process.html" title="java.lang 中的类"><CODE>Process</CODE></A> 对象，用于管理子进程
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <A HREF="../../java/lang/SecurityManager.html#checkExec(java.lang.String)"><CODE>checkExec</CODE></A> 方法不允许创建子进程
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>command</code> 为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>command</code> 为空<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#exec(java.lang.String[], java.lang.String[], java.io.File)"><CODE>exec(String[], String[], File)</CODE></A>, 
<A HREF="../../java/lang/ProcessBuilder.html" title="java.lang 中的类"><CODE>ProcessBuilder</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="exec(java.lang.String, java.lang.String[])"><!-- --></A><H3>
exec</H3>
<PRE>
public <A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A> <B>exec</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;command,
                    <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;envp)
             throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>在指定环境的单独进程中执行指定的字符串命令。

<p>这是一个很有用的方法。对于 <tt>exec(command, envp)</tt> 形式的调用而言，其行为与调用 <tt><A HREF="../../java/lang/Runtime.html#exec(java.lang.String, java.lang.String[], java.io.File)"><CODE>exec</CODE></A>(command, envp, null)</tt> 完全相同。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>command</CODE> - 一条指定的系统命令。<DD><CODE>envp</CODE> - 字符串数组，其中每个元素的环境变量的设置格式为 <i>name</i>=<i>value</i>；如果子进程应该继承当前进程的环境，或该参数为 <tt>null</tt>。
<DT><B>返回：</B><DD>一个新的 <A HREF="../../java/lang/Process.html" title="java.lang 中的类"><CODE>Process</CODE></A> 对象，用于管理子进程
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <A HREF="../../java/lang/SecurityManager.html#checkExec(java.lang.String)"><CODE>checkExec</CODE></A> 方法不允许创建子进程
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>command</code> 为 <code>null</code>，或 <code>envp</code> 的元素之一为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>command</code> 为空<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#exec(java.lang.String[], java.lang.String[], java.io.File)"><CODE>exec(String[], String[], File)</CODE></A>, 
<A HREF="../../java/lang/ProcessBuilder.html" title="java.lang 中的类"><CODE>ProcessBuilder</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="exec(java.lang.String, java.lang.String[], java.io.File)"><!-- --></A><H3>
exec</H3>
<PRE>
public <A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A> <B>exec</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;command,
                    <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;envp,
                    <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;dir)
             throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>在有指定环境和工作目录的独立进程中执行指定的字符串命令。

<p>这是一个很有用的方法。对于 <tt>exec(command, envp, dir)</tt> 形式的调用而言，其行为与调用 <tt><A HREF="../../java/lang/Runtime.html#exec(java.lang.String[], java.lang.String[], java.io.File)"><CODE>exec</CODE></A>(cmdarray, envp, dir)</tt> 完全相同，其中 <code>cmdarray</code> 是 <code>command</code> 中所有标记的数组。

<p>更准确地说，可以使用通过调用 <code>new <A HREF="../../java/util/StringTokenizer.html" title="java.util 中的类"><CODE>StringTokenizer</CODE></A>(command)</code> 创建的 <A HREF="../../java/util/StringTokenizer.html" title="java.util 中的类"><CODE>StringTokenizer</CODE></A> 将 <code>command</code> 字符串拆解成标记，调用时不对字符类别做进一步的修改。然后将标记生成器所生成的标记以相同的顺序放入新的字符串数组 <code>cmdarray</code> 中。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>command</CODE> - 一条指定的系统命令。<DD><CODE>envp</CODE> - 字符串数组，其中每个元素的环境变量的设置格式为 <i>name</i>=<i>value</i>；如果子进程应该继承当前进程的环境，或该参数为 <tt>null</tt>。<DD><CODE>dir</CODE> - 子进程的工作目录；如果子进程应该继承当前进程的工作目录，则该参数为 <tt>null</tt>。
<DT><B>返回：</B><DD>一个新的 <A HREF="../../java/lang/Process.html" title="java.lang 中的类"><CODE>Process</CODE></A> 对象，用于管理子进程
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <A HREF="../../java/lang/SecurityManager.html#checkExec(java.lang.String)"><CODE>checkExec</CODE></A> 方法不允许创建子进程
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>command</code> 为 <code>null</code>，或者 <code>envp</code> 的某个元素为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <code>command</code> 为空<DT><B>从以下版本开始：</B></DT>
  <DD>1.3</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ProcessBuilder.html" title="java.lang 中的类"><CODE>ProcessBuilder</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="exec(java.lang.String[])"><!-- --></A><H3>
exec</H3>
<PRE>
public <A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A> <B>exec</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;cmdarray)
             throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>在单独的进程中执行指定命令和变量。

<p>这是一个很有用的方法。对于 <tt>exec(cmdarray)</tt> 形式的调用而言，其行为与调用 <tt><A HREF="../../java/lang/Runtime.html#exec(java.lang.String[], java.lang.String[], java.io.File)"><CODE>exec</CODE></A>(cmdarray, null, null)</tt> 完全相同。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>cmdarray</CODE> - 包含所调用命令及其参数的数组。
<DT><B>返回：</B><DD>一个新的 <A HREF="../../java/lang/Process.html" title="java.lang 中的类"><CODE>Process</CODE></A> 对象，用于管理子进程
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <A HREF="../../java/lang/SecurityManager.html#checkExec(java.lang.String)"><CODE>checkExec</CODE></A> 方法不允许创建子进程
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>cmdarray</code> 为 <code>null</code>，或者 <code>cmdarray</code> 的某个元素为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 中的类">IndexOutOfBoundsException</A></CODE> - 如果 <code>cmdarray</code> 是一个空数组（长度为 <code>0</code>）<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ProcessBuilder.html" title="java.lang 中的类"><CODE>ProcessBuilder</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="exec(java.lang.String[], java.lang.String[])"><!-- --></A><H3>
exec</H3>
<PRE>
public <A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A> <B>exec</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;cmdarray,
                    <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;envp)
             throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>在指定环境的独立进程中执行指定命令和变量。

<p>这是一个很有用的方法。对于 <tt>exec(cmdarray, envp)</tt> 形式的调用而言，其行为与调用 <tt><A HREF="../../java/lang/Runtime.html#exec(java.lang.String[], java.lang.String[], java.io.File)"><CODE>exec</CODE></A>(cmdarray, envp, null)</tt> 完全相同。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>cmdarray</CODE> - 包含所调用命令及其参数的数组。<DD><CODE>envp</CODE> - 字符串数组，其中每个元素的环境变量的设置格式为 <i>name</i>=<i>value</i>；如果子进程应该继承当前进程的环境，或该参数为 <tt>null</tt>。
<DT><B>返回：</B><DD>一个新的 <A HREF="../../java/lang/Process.html" title="java.lang 中的类"><CODE>Process</CODE></A> 对象，用于管理子进程
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <A HREF="../../java/lang/SecurityManager.html#checkExec(java.lang.String)"><CODE>checkExec</CODE></A> 方法不允许创建子进程
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>cmdarray</code> 为 <code>null</code>，或者 <code>cmdarray</code> 的某个元素为 <code>null</code>，或者 <code>envp</code> 的某个元素为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 中的类">IndexOutOfBoundsException</A></CODE> - 如果 <code>cmdarray</code> 是一个空数组（长度为 <code>0</code>）<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ProcessBuilder.html" title="java.lang 中的类"><CODE>ProcessBuilder</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="exec(java.lang.String[], java.lang.String[], java.io.File)"><!-- --></A><H3>
exec</H3>
<PRE>
public <A HREF="../../java/lang/Process.html" title="java.lang 中的类">Process</A> <B>exec</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;cmdarray,
                    <A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>[]&nbsp;envp,
                    <A HREF="../../java/io/File.html" title="java.io 中的类">File</A>&nbsp;dir)
             throws <A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></PRE>
<DL>
<DD>在指定环境和工作目录的独立进程中执行指定的命令和变量。

<p>给定的字符串数组 <code>cmdarray</code> 表示一个命令行标记，字符串数组 <code>envp</code> 则表示“环境”变量设置，此方法会创建一个新进程，而指定的命令就在这个进程中执行。

<p>此方法检查 <code>cmdarray</code> 是否是一条有效的操作系统命令。哪些命令有效取决于系统，但是该命令至少必须有一个非 null 字符串的非空列表。

<p>如果 <tt>envp</tt> 为 <tt>null</tt>，那么子进程会继承当前进程的环境设置。

<p><A HREF="../../java/lang/ProcessBuilder.html#start()"><CODE>ProcessBuilder.start()</CODE></A> 现在是启用一个具有已修改环境的进程的首选方法。

<p><tt>dir</tt> 指定了新子进程的工作目录。如果 <tt>dir</tt> 为 <tt>null</tt>，那么子进程会继承当前进程的当前工作目录。

<p>如果安全管理器存在，则用数组 <code>cmdarray</code> 的第一个元素作为变量来调用安全管理器的 <A HREF="../../java/lang/SecurityManager.html#checkExec(java.lang.String)"><CODE>checkExec</CODE></A> 方法。这可能导致抛出 <A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类"><CODE>SecurityException</CODE></A>。

<p>启动操作系统进程的方式完全取决于系统。其中有很多方面会导致错误：
 <ul>
<li>未找到操作系统程序文件。
<li>对程序文件的访问被拒绝。
<li>工作目录不存在。
 </ul>

<p>这些情况都会抛出一个异常。该异常的具体特性取决于系统，但它总是 <A HREF="../../java/io/IOException.html" title="java.io 中的类"><CODE>IOException</CODE></A> 的一个子类。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>cmdarray</CODE> - 包含所调用命令及其参数的数组。<DD><CODE>envp</CODE> - 字符串数组，其中每个元素的环境变量的设置格式为 <i>name</i>=<i>value</i>，如果子进程应该继承当前进程的环境，或该参数为 <tt>null</tt>。<DD><CODE>dir</CODE> - 子进程的工作目录；如果子进程应该继承当前进程的工作目录，则该参数为 <tt>null</tt>。
<DT><B>返回：</B><DD>一个新的 <A HREF="../../java/lang/Process.html" title="java.lang 中的类"><CODE>Process</CODE></A> 对象，用于管理子进程
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <A HREF="../../java/lang/SecurityManager.html#checkExec(java.lang.String)"><CODE>checkExec</CODE></A> 方法不允许创建子进程
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果发生 I/O 错误
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>cmdarray</code> 为 <code>null</code>，或者 <code>cmdarray</code> 的某个元素为 <code>null</code>，抑或 <code>envp</code> 的某个元素为 <code>null</code>
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 中的类">IndexOutOfBoundsException</A></CODE> - 如果 <code>cmdarray</code> 是一个空数组（长度为 <code>0</code>）<DT><B>从以下版本开始：</B></DT>
  <DD>1.3</DD>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/ProcessBuilder.html" title="java.lang 中的类"><CODE>ProcessBuilder</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="availableProcessors()"><!-- --></A><H3>
availableProcessors</H3>
<PRE>
public int <B>availableProcessors</B>()</PRE>
<DL>
<DD>向 Java 虚拟机返回可用处理器的数目。

<p> 该值在特定的虚拟机调用期间可能发生更改。因此，对可用处理器数目很敏感的应用程序应该不定期地轮询该属性，并相应地调整其资源用法。 </p>
<P>
<DD><DL>

<DT><B>返回：</B><DD>虚拟机可用的最大处理器数目；从不小于 1<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="freeMemory()"><!-- --></A><H3>
freeMemory</H3>
<PRE>
public long <B>freeMemory</B>()</PRE>
<DL>
<DD>返回 Java 虚拟机中的空闲内存量。调用 <code>gc</code> 方法可能导致 <code>freeMemory</code> 返回值的增加。
<P>
<DD><DL>

<DT><B>返回：</B><DD>供将来分配对象使用的当前可用内存的近似总量，以字节为单位。</DL>
</DD>
</DL>
<HR>

<A NAME="totalMemory()"><!-- --></A><H3>
totalMemory</H3>
<PRE>
public long <B>totalMemory</B>()</PRE>
<DL>
<DD>返回 Java 虚拟机中的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。
 <p>
注意，保存任意给定类型的一个对象所需的内存量可能取决于实现方法。
<P>
<DD><DL>

<DT><B>返回：</B><DD>目前为当前和后续对象提供的内存总量，以字节为单位。</DL>
</DD>
</DL>
<HR>

<A NAME="maxMemory()"><!-- --></A><H3>
maxMemory</H3>
<PRE>
public long <B>maxMemory</B>()</PRE>
<DL>
<DD>返回 Java 虚拟机试图使用的最大内存量。如果内存本身没有限制，则返回值 <A HREF="../../java/lang/Long.html#MAX_VALUE"><CODE>Long.MAX_VALUE</CODE></A>。 </p>
<P>
<DD><DL>

<DT><B>返回：</B><DD>虚拟机试图使用的最大内存量，以字节为单位。<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="gc()"><!-- --></A><H3>
gc</H3>
<PRE>
public void <B>gc</B>()</PRE>
<DL>
<DD>运行垃圾回收器。调用此方法意味着 Java 虚拟机做了一些努力来回收未用对象，以便能够快速地重用这些对象当前占用的内存。当控制从方法调用中返回时，虚拟机已经尽最大努力回收了所有丢弃的对象。 
 <p>
名称 <code>gc</code> 代表“垃圾回收器”。虚拟机根据需要在单独的线程中自动执行回收过程，甚至不用显式调用 <code>gc</code> 方法。
 <p>
方法 <A HREF="../../java/lang/System.html#gc()"><CODE>System.gc()</CODE></A> 是调用此方法的一种传统而便捷的方式。
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="runFinalization()"><!-- --></A><H3>
runFinalization</H3>
<PRE>
public void <B>runFinalization</B>()</PRE>
<DL>
<DD>运行挂起 finalization 的所有对象的终止方法。调用此方法意味着 Java 虚拟机做了一些努力运行已被丢弃对象的 <code>finalize</code> 方法，但是这些对象的 <code>finalize</code> 方法还没有运行。当控制从方法调用中返回时，Java 虚拟机已经尽最大努力去完成所有未执行的终止方法。 
 <p>
如果不显式调用 <code>runFinalization</code> 方法，则 Java 虚拟机会根据需要在单独的线程中自动执行此终止过程。 
 <p>
方法 <A HREF="../../java/lang/System.html#runFinalization()"><CODE>System.runFinalization()</CODE></A> 是调用此方法的一种传统而便捷的方式。
<P>
<DD><DL>
<DT><B>另请参见：</B><DD><A HREF="../../java/lang/Object.html#finalize()"><CODE>Object.finalize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="traceInstructions(boolean)"><!-- --></A><H3>
traceInstructions</H3>
<PRE>
public void <B>traceInstructions</B>(boolean&nbsp;on)</PRE>
<DL>
<DD>启用／禁用指令跟踪。如果 <code>boolean</code> 变量为 <code>true</code>，则执行此方法意味着让 Java 虚拟机发送虚拟机中每条指令执行的调试信息。该信息的格式，以及虚拟机所发送的文件或其他输出流的格式取决于主机的环境。如果虚拟机不支持此功能，则忽略这一请求。跟踪输出的目的地取决于系统。 
 <p>
如果 <code>boolean</code> 变量为 <code>false</code>，则执行此方法时将使 Java 虚拟机停止执行详细的指令跟踪。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>on</CODE> - 为 <code>true</code> 时启用指令跟踪；为 <code>false</code> 时则禁用此功能。</DL>
</DD>
</DL>
<HR>

<A NAME="traceMethodCalls(boolean)"><!-- --></A><H3>
traceMethodCalls</H3>
<PRE>
public void <B>traceMethodCalls</B>(boolean&nbsp;on)</PRE>
<DL>
<DD>启用／禁用方法调用跟踪。如果 <code>boolean</code> 变量为 <code>true</code>，则执行此方法意味着让 Java 虚拟机发送虚拟机中每个方法的调试信息。该信息的格式，以及虚拟机所发送的文件或其他输出流的格式取决于主机的环境。如果虚拟机不支持此功能，则忽略这一请求。  
 <p>
使用变量 false 调用此方法意味着虚拟机停止发送每个调用的调试信息。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>on</CODE> - 为 <code>true</code> 时启用指令跟踪；为 <code>false</code> 时则禁用此功能。</DL>
</DD>
</DL>
<HR>

<A NAME="load(java.lang.String)"><!-- --></A><H3>
load</H3>
<PRE>
public void <B>load</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;filename)</PRE>
<DL>
<DD>加载作为动态库的指定文件名。文件名变量必须是一个完整的路径名，（例如 <code>Runtime.getRuntime().load("/home/avh/lib/libX11.so");</code>）。
 <p>
首先，如果有安全管理器，则用 <code>filename</code> 作为参数调用 <code>checkLink</code> 方法。这可能导致安全异常。 
 <p>
这与 <A HREF="../../java/lang/Runtime.html#loadLibrary(java.lang.String)"><CODE>loadLibrary(String)</CODE></A> 方法类似，但它接受通用文件名作为变量，而不仅仅是库名，从而能够加载所有的本机代码文件。
 <p>
方法 <A HREF="../../java/lang/System.html#load(java.lang.String)"><CODE>System.load(String)</CODE></A> 是调用此方法的一种传统而便捷的方式。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>filename</CODE> - 要加载的文件。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <code>checkLink</code> 方法不允许加载指定的动态库
<DD><CODE><A HREF="../../java/lang/UnsatisfiedLinkError.html" title="java.lang 中的类">UnsatisfiedLinkError</A></CODE> - 如果文件不存在。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>filename</code> 为 <code>null</code><DT><B>另请参见：</B><DD><A HREF="../../java/lang/Runtime.html#getRuntime()"><CODE>getRuntime()</CODE></A>, 
<A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类"><CODE>SecurityException</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkLink(java.lang.String)"><CODE>SecurityManager.checkLink(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="loadLibrary(java.lang.String)"><!-- --></A><H3>
loadLibrary</H3>
<PRE>
public void <B>loadLibrary</B>(<A HREF="../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;libname)</PRE>
<DL>
<DD>加载具有指定库名的动态库。从以前获取库文件的本地文件系统中加载含有本机代码的文件。这一过程的细节取决于实现方法。可以以某种特定于系统的方式完成从库名到特定文件名的映射。  
 <p>
首先，如果有安全管理器，则用 <code>libname</code> 作为参数调用 <code>checkLink</code> 方法。这可能导致安全性异常。 
 <p>
方法 <A HREF="../../java/lang/System.html#loadLibrary(java.lang.String)"><CODE>System.loadLibrary(String)</CODE></A> 是调用此方法的一种传统而便捷的方式。如果在某个类实现中使用本机方法，则标准的策略是将本机代码放入一个库文件中（称为 <code>LibFile</code>），然后在类声明中放入一个静态的初始值设定项：
 <blockquote><pre>
static { System.loadLibrary("LibFile"); }
 </pre></blockquote>
当加载并初始化这个类时，也将加载实现本机方法所需的本机代码。 
 <p>
如果用相同库名多次调用此方法，则忽略第二次及后续的调用。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>libname</CODE> - 库名。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在，并且其 <code>checkLink</code> 方法不允许加载指定的动态库
<DD><CODE><A HREF="../../java/lang/UnsatisfiedLinkError.html" title="java.lang 中的类">UnsatisfiedLinkError</A></CODE> - 如果库不存在。
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <code>libname</code> 为 <code>null</code><DT><B>另请参见：</B><DD><A HREF="../../java/lang/SecurityException.html" title="java.lang 中的类"><CODE>SecurityException</CODE></A>, 
<A HREF="../../java/lang/SecurityManager.html#checkLink(java.lang.String)"><CODE>SecurityManager.checkLink(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLocalizedInputStream(java.io.InputStream)"><!-- --></A><H3>
getLocalizedInputStream</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public <A HREF="../../java/io/InputStream.html" title="java.io 中的类">InputStream</A> <B>getLocalizedInputStream</B>(<A HREF="../../java/io/InputStream.html" title="java.io 中的类">InputStream</A>&nbsp;in)</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>从 JDK&nbsp;1.1 开始，将本地编码字节流转换为 Unicode 字符流的首选方法是使用 <code>InputStreamReader</code> 和 <code>BufferedReader</code> 类。</I>
<P>
<DD>创建输入流的本地化版本。此方法获取 <code>InputStream</code>，并返回除本地化外其他所有方面都和变量等效的 <code>InputStream</code>，这些方面包括：作为本地字符集中的字符从流中被读取，并将它们从本地字符集自动转换为 Unicode。 
 <p>
如果参数已经是本地化流，则可作为结果返回。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>in</CODE> - 要本地化的 InputStream
<DT><B>返回：</B><DD>已本地化的输入流<DT><B>另请参见：</B><DD><A HREF="../../java/io/InputStream.html" title="java.io 中的类"><CODE>InputStream</CODE></A>, 
<A HREF="../../java/io/BufferedReader.html#BufferedReader(java.io.Reader)"><CODE>BufferedReader.BufferedReader(java.io.Reader)</CODE></A>, 
<A HREF="../../java/io/InputStreamReader.html#InputStreamReader(java.io.InputStream)"><CODE>InputStreamReader.InputStreamReader(java.io.InputStream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLocalizedOutputStream(java.io.OutputStream)"><!-- --></A><H3>
getLocalizedOutputStream</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 中的注释">@Deprecated</A>
</FONT>public <A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A> <B>getLocalizedOutputStream</B>(<A HREF="../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A>&nbsp;out)</PRE>
<DL>
<DD><B>已过时。</B>&nbsp;<I>从 JDK&nbsp;1.1 开始，将 Unicode 字符流转换为本地编码字节流的首选方法是使用 <code>OutputStreamWriter</code>、<code>BufferedWriter</code> 和 <code>PrintWriter</code> 类。</I>
<P>
<DD>创建输出流的本地化版本。此方法获取 <code>OutputStream</code>，并返回除本地化外其他所有方面都和变量等效的 <code>OutputStream</code>，这些方面包括：作为 Unicode 字符被写入流中，并被自动转换为本地字符集。 
 <p>
如果参数已经是本地流，则可作为结果返回。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>out</CODE> - 要本地化的 OutputStream
<DT><B>返回：</B><DD>已本地化的输出流<DT><B>另请参见：</B><DD><A HREF="../../java/io/OutputStream.html" title="java.io 中的类"><CODE>OutputStream</CODE></A>, 
<A HREF="../../java/io/BufferedWriter.html#BufferedWriter(java.io.Writer)"><CODE>BufferedWriter.BufferedWriter(java.io.Writer)</CODE></A>, 
<A HREF="../../java/io/OutputStreamWriter.html#OutputStreamWriter(java.io.OutputStream)"><CODE>OutputStreamWriter.OutputStreamWriter(java.io.OutputStream)</CODE></A>, 
<A HREF="../../java/io/PrintWriter.html#PrintWriter(java.io.OutputStream)"><CODE>PrintWriter.PrintWriter(java.io.OutputStream)</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Runtime.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/Runnable.html" title="java.lang 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../java/lang/RuntimeException.html" title="java.lang 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Runtime.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="Runtime.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;构造方法&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
