<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 12:46:21 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
TextLayout (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="TextLayout (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/TextLayout.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/awt/font/TextLayout.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="TextLayout.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt.font</FONT>
<BR>
类 TextLayout</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="继承者 "><B>java.awt.font.TextLayout</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../../java/lang/Cloneable.html" title="java.lang 中的接口">Cloneable</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public final class <B>TextLayout</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A><DT>implements <A HREF="../../../java/lang/Cloneable.html" title="java.lang 中的接口">Cloneable</A></DL>
</PRE>

<P>
<code>TextLayout</code> 是样式字符数据的不可变图形表示形式。
 <p>
它提供以下功能：
 <ul>
<li>隐式双向分析和重排序
<li>光标定位和移动，包括针对混向文本的拆分光标
<li>，包括针对混向文本的逻辑和可视高亮显示
<li>多个基线（罗马字体、悬挂和居中）
<li>命中测试
<li>调整
<li>默认字体替换
<li>规格信息，如 ascent、descent 和 advance
<li>呈现
 </ul>
 <p>
<code>TextLayout</code> 对象可以使用其 <code>draw</code> 方法呈现。
 <p>
可以直接或通过使用 <A HREF="../../../java/awt/font/LineBreakMeasurer.html" title="java.awt.font 中的类"><CODE>LineBreakMeasurer</CODE></A> 构造 <code>TextLayout</code>。直接构造时，源文本表示一个段落。<code>LineBreakMeasurer</code> 允许带样式的文本断行，以适应特定的宽度。有关更多信息，请参阅 <code>LineBreakMeasurer</code> 文档。
 <p>
<code>TextLayout</code> 的逻辑构造过程如下：
 <ul>
<li>提取并检查段落属性
<li>对文本进行双向重排分析，并在需要时计算重排信息
<li>根据样式排列对文本进行分段
<li>为样式排列选择的字体，如果存在 <A HREF="../../../java/awt/font/TextAttribute.html#FONT"><CODE>TextAttribute.FONT</CODE></A> 属性，则首先使用该字体，否则，通过使用已定义的属性计算默认字体
<li>如果文本位于多个基线上，则排列或子排列被进一步拆分为共享公共基线的子排列
<li>使用所选字体为每个排列生成字形向量
<li>对字形向量执行最后的双向重排
 </ul>
 <p>
从 <code>TextLayout</code> 对象的方法返回的所有图形信息都相对于 <code>TextLayout</code> 的原点，它是 <code>TextLayout</code> 对象的基线与其左边缘的交叉点。同样，假定传递到 <code>TextLayout</code> 对象方法的坐标也相对于 <code>TextLayout</code> 对象的原点。客户端通常需要在 <code>TextLayout</code> 对象的坐标系和另一对象（如 <A HREF="../../../java/awt/Graphics.html" title="java.awt 中的类"><CODE>Graphics</CODE></A> 对象）中的坐标系之间进行转换。
 <p>
根据样式文本创建 <code>TextLayout</code> 对象，但它们不保留对其源文本的引用。因此，对先前用来生成 <code>TextLayout</code> 文本的改动不会影响 <code>TextLayout</code>。
 <p>
<code>TextLayout</code> 对象的三个方法（<code>getNextRightHit</code>、<code>getNextLeftHit</code> 和 <code>hitTestChar</code>）都返回 <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类"><CODE>TextHitInfo</CODE></A> 实例。这些 <code>TextHitInfo</code> 对象中的偏移量相对于 <code>TextLayout</code> 的起始处，而<b>不是</b>相对于用来创建 <code>TextLayout</code> 的文本。同样，接受 <code>TextHitInfo</code> 实例作为参数的 <code>TextLayout</code> 方法将 <code>TextHitInfo</code> 对象的偏移量看做相对于 <code>TextLayout</code>，而不是其他任何基础文本存储模型。
 <p>
<strong>示例</strong>：<p>
构造并绘制 <code>TextLayout</code> 及其边界矩形：
 <blockquote><pre>
   Graphics2D g = ...;
   Point2D loc = ...;
   Font font = Font.getFont("Helvetica-bold-italic");
   FontRenderContext frc = g.getFontRenderContext();
   TextLayout layout = new TextLayout("This is a string", font, frc);
   layout.draw(g, (float)loc.getX(), (float)loc.getY());

   Rectangle2D bounds = layout.getBounds();
   bounds.setRect(bounds.getX()+loc.getX(),
                  bounds.getY()+loc.getY(),
                  bounds.getWidth(),
                  bounds.getHeight());
   g.draw(bounds);
 </pre>
 </blockquote>
 <p>
对 <code>TextLayout</code> 进行命中测试（确定哪个字符位于特定图形位置上）：
 <blockquote><pre>
   Point2D click = ...;
   TextHitInfo hit = layout.hitTestChar(
                         (float) (click.getX() - loc.getX()),
                         (float) (click.getY() - loc.getY()));
 </pre>
 </blockquote>
 <p>
对按下向右方向键进行响应：
 <blockquote><pre>
   int insertionIndex = ...;
   TextHitInfo next = layout.getNextRightHit(insertionIndex);
   if (next != null) {
       // translate graphics to origin of layout on screen
       g.translate(loc.getX(), loc.getY());
       Shape[] carets = layout.getCaretShapes(next.getInsertionIndex());
       g.draw(carets[0]);
       if (carets[1] != null) {
           g.draw(carets[1]);
       }
   }
 </pre></blockquote>
 <p>
绘制一个对应于源文本中子字符串的选择范围。选择的区域在视觉上可能是不连续的：
 <blockquote><pre>
   // selStart, selLimit should be relative to the layout,
   // not to the source text

   int selStart = ..., selLimit = ...;
   Color selectionColor = ...;
   Shape selection = layout.getLogicalHighlightShape(selStart, selLimit);
   // selection may consist of disjoint areas
   // graphics is assumed to be tranlated to origin of layout
   g.setColor(selectionColor);
   g.fill(selection);
 </pre></blockquote>
 <p>
绘制一个视觉上连续的选择范围。选择范围可能对应源文本中的多个子字符串。通过 <code>getLogicalRangesForVisualSelection()</code> 可以获得相应源文本的子字符串范围：
 <blockquote><pre>
   TextHitInfo selStart = ..., selLimit = ...;
   Shape selection = layout.getVisualHighlightShape(selStart, selLimit);
   g.setColor(selectionColor);
   g.fill(selection);
   int[] ranges = getLogicalRangesForVisualSelection(selStart, selLimit);
   // ranges[0], ranges[1] is the first selection range,
   // ranges[2], ranges[3] is the second selection range, etc.
 </pre></blockquote>
 <p>
注：字体旋转可能导致文本基线旋转，多次进行不同的旋转可能够导致基线弯曲或出现 Z 形转角。为了处理好这种（少有的）可能性，需要指定一些 API 返回规格，并采用“相对于基线的坐标中”的参数（比如 ascent 和 advance），以及其他一些“标准坐标中”的规格和参数（比如 getBounds）。相对于基线的坐标中的值将 'x' 坐标映射到沿基线的某段距离处（正 x 表示沿基线的正方向），将 'y' 坐标映射到 'x' 坐标处基线垂直方向的某段距离处（正 y 表示从基线向量顺时针旋转 90 度）。标准坐标中的值是沿 x 轴和 y 轴进行测量的，0,0 是 TextLayout 的原点。用于每个相关 API 的文档都将指示哪些值位于坐标系中。通常，与测量有关的 API 位于与相对于基线的坐标中，而与显示有关的 API 则位于标准坐标中。
<P>

<P>
<DL>
<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html" title="java.awt.font 中的类"><CODE>LineBreakMeasurer</CODE></A>, 
<A HREF="../../../java/awt/font/TextAttribute.html" title="java.awt.font 中的类"><CODE>TextAttribute</CODE></A>, 
<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类"><CODE>TextHitInfo</CODE></A>, 
<A HREF="../../../java/awt/font/LayoutPath.html" title="java.awt.font 中的类"><CODE>LayoutPath</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>嵌套类摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类">TextLayout.CaretPolicy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义确定强插入符位置的策略。</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类">TextLayout.CaretPolicy</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#DEFAULT_CARET_POLICY">DEFAULT_CARET_POLICY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端未指定策略时使用此 <code>CaretPolicy</code>。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#TextLayout(java.text.AttributedCharacterIterator, java.awt.font.FontRenderContext)">TextLayout</A></B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 中的接口">AttributedCharacterIterator</A>&nbsp;text,
           <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 中的类">FontRenderContext</A>&nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据样式文本上的迭代器构造一个 <code>TextLayout</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#TextLayout(java.lang.String, java.awt.Font, java.awt.font.FontRenderContext)">TextLayout</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;string,
           <A HREF="../../../java/awt/Font.html" title="java.awt 中的类">Font</A>&nbsp;font,
           <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 中的类">FontRenderContext</A>&nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <code>String</code> 和 <A HREF="../../../java/awt/Font.html" title="java.awt 中的类"><CODE>Font</CODE></A> 构造一个 <code>TextLayout</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#TextLayout(java.lang.String, java.util.Map, java.awt.font.FontRenderContext)">TextLayout</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;string,
           <A HREF="../../../java/util/Map.html" title="java.util 中的接口">Map</A>&lt;? extends <A HREF="../../../java/text/AttributedCharacterIterator.Attribute.html" title="java.text 中的类">AttributedCharacterIterator.Attribute</A>,?&gt;&nbsp;attributes,
           <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 中的类">FontRenderContext</A>&nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <code>String</code> 和属性集构造一个 <code>TextLayout</code>。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#clone()">clone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建此 <code>TextLayout</code> 的副本。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#draw(java.awt.Graphics2D, float, float)">draw</A></B>(<A HREF="../../../java/awt/Graphics2D.html" title="java.awt 中的类">Graphics2D</A>&nbsp;g2,
     float&nbsp;x,
     float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在指定的 <A HREF="../../../java/awt/Graphics2D.html" title="java.awt 中的类"><CODE>Graphics2D</CODE></A> 上下文中的指定位置上呈现此 <code>TextLayout</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#equals(java.lang.Object)">equals</A></B>(<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果指定 <code>Object</code> 是一个 <code>TextLayout</code> 对象，且指定的 <code>Object</code> 等于此 <code>TextLayout</code>，则返回 <code>true</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#equals(java.awt.font.TextLayout)">equals</A></B>(<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 中的类">TextLayout</A>&nbsp;rhs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个布局相等，则返回 <code>true</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getAdvance()">getAdvance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此 <code>TextLayout</code> 的 advance。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getAscent()">getAscent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此 <code>TextLayout</code> 的 ascent。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBaseline()">getBaseline</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此 <code>TextLayout</code> 的基线。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBaselineOffsets()">getBaselineOffsets</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回用于此 <code>TextLayout</code> 的基线偏移量数组。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBlackBoxBounds(int, int)">getBlackBoxBounds</A></B>(int&nbsp;firstEndpoint,
                  int&nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回指定范围中字符的黑框边界。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBounds()">getBounds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此 <code>TextLayout</code> 的边界。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretInfo(java.awt.font.TextHitInfo)">getCaretInfo</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回与对应于 <code>hit</code> 的插入符有关的信息。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretInfo(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)">getCaretInfo</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit,
             <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回与对应于 <code>hit</code> 的插入符有关的信息。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShape(java.awt.font.TextHitInfo)">getCaretShape</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示此 <code>TextLayout</code> 的自然边界中指定目标字符处插入符的 <code>Shape</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShape(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)">getCaretShape</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit,
              <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示指定边界内指定目标字符处插入符的 <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口"><CODE>Shape</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int)">getCaretShapes</A></B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回对应于强插入符和弱插入符的两条路径。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int, java.awt.geom.Rectangle2D)">getCaretShapes</A></B>(int&nbsp;offset,
               <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回对应于强插入符和弱插入符的两条路径。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int, java.awt.geom.Rectangle2D, java.awt.font.TextLayout.CaretPolicy)">getCaretShapes</A></B>(int&nbsp;offset,
               <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds,
               <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类">TextLayout.CaretPolicy</A>&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回对应于强插入符和弱插入符的两条路径。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCharacterCount()">getCharacterCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回由此 <code>TextLayout</code> 表示的字符数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCharacterLevel(int)">getCharacterLevel</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 <code>index</code> 处字符的级别。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getDescent()">getDescent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此 <code>TextLayout</code> 的 descent。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 中的类">TextLayout</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getJustifiedLayout(float)">getJustifiedLayout</A></B>(float&nbsp;justificationWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建调整到指定宽度的此 <code>TextLayout</code> 的一个副本。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/LayoutPath.html" title="java.awt.font 中的类">LayoutPath</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLayoutPath()">getLayoutPath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 LayoutPath，如果布局路径是默认路径（x 映射到 advance，y 映射到 offset），则返回 null。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLeading()">getLeading</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回 <code>TextLayout</code> 的行距。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLogicalHighlightShape(int, int)">getLogicalHighlightShape</A></B>(int&nbsp;firstEndpoint,
                         int&nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回封装指定范围中逻辑选择范围的 <code>Shape</code>，它扩展到此 <code>TextLayout</code> 的自然边界。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLogicalHighlightShape(int, int, java.awt.geom.Rectangle2D)">getLogicalHighlightShape</A></B>(int&nbsp;firstEndpoint,
                         int&nbsp;secondEndpoint,
                         <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回封闭指定范围中扩展到指定 <code>bounds</code> 的逻辑选择范围的 <code>Shape</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLogicalRangesForVisualSelection(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)">getLogicalRangesForVisualSelection</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;firstEndpoint,
                                   <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回对应于可视选择范围的逻辑文本范围。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextLeftHit(int)">getNextLeftHit</A></B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回下一个插入符左侧（顶部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextLeftHit(int, java.awt.font.TextLayout.CaretPolicy)">getNextLeftHit</A></B>(int&nbsp;offset,
               <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类">TextLayout.CaretPolicy</A>&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回下一个插入符左侧（顶部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextLeftHit(java.awt.font.TextHitInfo)">getNextLeftHit</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回下一个插入符左侧（顶部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextRightHit(int)">getNextRightHit</A></B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回下一个插入符右侧（底部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextRightHit(int, java.awt.font.TextLayout.CaretPolicy)">getNextRightHit</A></B>(int&nbsp;offset,
                <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类">TextLayout.CaretPolicy</A>&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回下一个插入符右侧（底部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextRightHit(java.awt.font.TextHitInfo)">getNextRightHit</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回下一个插入符右侧（底部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getOutline(java.awt.geom.AffineTransform)">getOutline</A></B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 中的类">AffineTransform</A>&nbsp;tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回表示此 <code>TextLayout</code> 的轮廓的 <code>Shape</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Rectangle.html" title="java.awt 中的类">Rectangle</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getPixelBounds(java.awt.font.FontRenderContext, float, float)">getPixelBounds</A></B>(<A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 中的类">FontRenderContext</A>&nbsp;frc,
               float&nbsp;x,
               float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回在图形中使用给定 <code>FontRenderContext</code> 在给定位置处呈现 <code>TextLayout</code> 时的像素边界。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisibleAdvance()">getVisibleAdvance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此 <code>TextLayout</code> 的 advance，减去结尾空格。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)">getVisualHighlightShape</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;firstEndpoint,
                        <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回封闭指定范围中扩展到指定边界的可视选择范围的 <code>Shape</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)">getVisualHighlightShape</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;firstEndpoint,
                        <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;secondEndpoint,
                        <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回封闭指定范围中扩展到 <code>bounds</code> 的可视选择范围的路径。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisualOtherHit(java.awt.font.TextHitInfo)">getVisualOtherHit</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回位于指定目标字符插入符另一侧的目标字符。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#handleJustify(float)">handleJustify</A></B>(float&nbsp;justificationWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调整此布局。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此 <code>TextLayout</code> 的哈希码。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hitTestChar(float, float)">hitTestChar</A></B>(float&nbsp;x,
            float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回对应于指定点的 <code>TextHitInfo</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hitTestChar(float, float, java.awt.geom.Rectangle2D)">hitTestChar</A></B>(float&nbsp;x,
            float&nbsp;y,
            <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回对应于指定点的 <code>TextHitInfo</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hitToPoint(java.awt.font.TextHitInfo, java.awt.geom.Point2D)">hitToPoint</A></B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit,
           <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 中的类">Point2D</A>&nbsp;point)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个命中点转换为标准坐标中的一个点。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#isLeftToRight()">isLeftToRight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此 <code>TextLayout</code> 的基本方向是从左到右，则返回 <code>true</code>；如果基本方向是从右到左，则返回 <code>false</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#isVertical()">isVertical</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此 <code>TextLayout</code> 是垂直的，则返回 <code>true</code>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此 <code>TextLayout</code> 的调试信息。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>字段详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DEFAULT_CARET_POLICY"><!-- --></A><H3>
DEFAULT_CARET_POLICY</H3>
<PRE>
public static final <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类">TextLayout.CaretPolicy</A> <B>DEFAULT_CARET_POLICY</B></PRE>
<DL>
<DD>客户端未指定策略时使用此 <code>CaretPolicy</code>。使用此策略，方向与行方向相同的字符的命中要强于对反方向字符的命中。如果字符的方向相同，则对字符开始边的命中要强于对字符结尾边的命中。
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="TextLayout(java.lang.String, java.awt.Font, java.awt.font.FontRenderContext)"><!-- --></A><H3>
TextLayout</H3>
<PRE>
public <B>TextLayout</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;string,
                  <A HREF="../../../java/awt/Font.html" title="java.awt 中的类">Font</A>&nbsp;font,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 中的类">FontRenderContext</A>&nbsp;frc)</PRE>
<DL>
<DD>根据 <code>String</code> 和 <A HREF="../../../java/awt/Font.html" title="java.awt 中的类"><CODE>Font</CODE></A> 构造一个 <code>TextLayout</code>。使用指定的 <code>Font</code> 样式化所有文本。
 <p>
<code>String</code> 必须指定单个文本段，因为双向算法需要整个段落。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>string</CODE> - 要显示的文本<DD><CODE>font</CODE> - 用于样式化文本的 <code>Font</code><DD><CODE>frc</CODE> - 包含关于正确测量文本所需图形设备的信息。根据设备分辨率和属性（如抗锯齿）的不同，文本测量可能稍有变化。此参数未指定 <code>TextLayout</code> 和用户空间之间的转换。</DL>
</DL>
<HR>

<A NAME="TextLayout(java.lang.String, java.util.Map, java.awt.font.FontRenderContext)"><!-- --></A><H3>
TextLayout</H3>
<PRE>
public <B>TextLayout</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;string,
                  <A HREF="../../../java/util/Map.html" title="java.util 中的接口">Map</A>&lt;? extends <A HREF="../../../java/text/AttributedCharacterIterator.Attribute.html" title="java.text 中的类">AttributedCharacterIterator.Attribute</A>,?&gt;&nbsp;attributes,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 中的类">FontRenderContext</A>&nbsp;frc)</PRE>
<DL>
<DD>根据 <code>String</code> 和属性集构造一个 <code>TextLayout</code>。
 <p>
使用提供的属性样式化所有文本。
 <p>
<code>String</code> 必须指定单个文本段，因为双向算法需要整个段落。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>string</CODE> - 要显示的文本<DD><CODE>attributes</CODE> - 用于样式化文本的属性<DD><CODE>frc</CODE> - 包含关于正确测量文本所需图形设备的信息。根据设备分辨率和属性（如抗锯齿）的不同，文本测量可能稍有变化。此参数未指定 <code>TextLayout</code> 和用户空间之间的转换。</DL>
</DL>
<HR>

<A NAME="TextLayout(java.text.AttributedCharacterIterator, java.awt.font.FontRenderContext)"><!-- --></A><H3>
TextLayout</H3>
<PRE>
public <B>TextLayout</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 中的接口">AttributedCharacterIterator</A>&nbsp;text,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 中的类">FontRenderContext</A>&nbsp;frc)</PRE>
<DL>
<DD>根据样式文本上的迭代器构造一个 <code>TextLayout</code>。
 <p>
该迭代器必须指定单个文本段，因为双向算法需要整个段落。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>text</CODE> - 要显示的样式文本<DD><CODE>frc</CODE> - 包含关于正确测量文本所需图形设备的信息。根据设备分辨率和属性（如抗锯齿）的不同，文本测量可能稍有变化。此参数未指定 <code>TextLayout</code> 和用户空间之间的转换。</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="clone()"><!-- --></A><H3>
clone</H3>
<PRE>
protected <A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>clone</B>()</PRE>
<DL>
<DD>创建此 <code>TextLayout</code> 的副本。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此实例的一个副本。<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/Cloneable.html" title="java.lang 中的接口"><CODE>Cloneable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getJustifiedLayout(float)"><!-- --></A><H3>
getJustifiedLayout</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 中的类">TextLayout</A> <B>getJustifiedLayout</B>(float&nbsp;justificationWidth)</PRE>
<DL>
<DD>创建调整到指定宽度的此 <code>TextLayout</code> 的一个副本。
 <p>
如果已调整了此 <code>TextLayout</code>，则抛出异常。如果此 <code>TextLayout</code> 对象的调整率为零，将返回与此 <code>TextLayout</code> 相同的 <code>TextLayout</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>justificationWidth</CODE> - 调整行时使用的宽度。要获得最佳结果，该宽度与行的当前 advance 不应有太大差别。
<DT><B>返回：</B><DD>调整到指定宽度的 <code>TextLayout</code>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/Error.html" title="java.lang 中的类">Error</A></CODE> - 如果已调整了此布局，则抛出 Error。</DL>
</DD>
</DL>
<HR>

<A NAME="handleJustify(float)"><!-- --></A><H3>
handleJustify</H3>
<PRE>
protected void <B>handleJustify</B>(float&nbsp;justificationWidth)</PRE>
<DL>
<DD>调整此布局。子类重写该方法来控制调整（如果存在子类，即……）。

只在段落属性（来自源文本，可以是布局属性的默认值）指示一个非零调整率时才调整布局。将文本调整到指示的宽度。当前实现还调整标点和尾部空白，使其接近于调整宽度。调整布局之后将不会对其进行再调整。
 <p>
某些代码依赖于布局的不可变性。因此子类不应直接调用该方法，而应调用 getJustifiedLayout，getJustifiedLayout 将在此布局的副本上调用此方法，并保留原始布局。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>justificationWidth</CODE> - 调整行时使用的宽度。要获得最佳结果，该宽度与行的当前 advance 不应有太大差别。<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getJustifiedLayout(float)"><CODE>getJustifiedLayout(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBaseline()"><!-- --></A><H3>
getBaseline</H3>
<PRE>
public byte <B>getBaseline</B>()</PRE>
<DL>
<DD>返回此 <code>TextLayout</code> 的基线。基线是 <code>Font</code> 中定义的一个值，它可以是 roman、centered 或 hanging。Ascent 和 descent 相对于此基线。<code>baselineOffsets</code> 也相对于此基线。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <code>TextLayout</code> 的基线。<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getBaselineOffsets()"><CODE>getBaselineOffsets()</CODE></A>, 
<A HREF="../../../java/awt/Font.html" title="java.awt 中的类"><CODE>Font</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBaselineOffsets()"><!-- --></A><H3>
getBaselineOffsets</H3>
<PRE>
public float[] <B>getBaselineOffsets</B>()</PRE>
<DL>
<DD>返回用于此 <code>TextLayout</code> 的基线偏移量数组。
 <p>
该数组用 <code>Font</code> 中定义的 roman、centered 或 hanging 值之一进行索引。这些值相对于此 <code>TextLayout</code> 对象的基线，从而 <code>getBaselineOffsets[getBaseline()] == 0</code>。将偏移量添加到 <code>TextLayout</code> 对象基线所在的位置，以获取新基线的位置。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>包含用于此 <code>TextLayout</code> 基线的偏移量数组。<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getBaseline()"><CODE>getBaseline()</CODE></A>, 
<A HREF="../../../java/awt/Font.html" title="java.awt 中的类"><CODE>Font</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAdvance()"><!-- --></A><H3>
getAdvance</H3>
<PRE>
public float <B>getAdvance</B>()</PRE>
<DL>
<DD>返回此 <code>TextLayout</code> 的 advance。该 advance 是从原点到最右边（最底部）字符的 advance 的距离。返回值位于相对于基线的坐标中。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <code>TextLayout</code> 的 advance。</DL>
</DD>
</DL>
<HR>

<A NAME="getVisibleAdvance()"><!-- --></A><H3>
getVisibleAdvance</H3>
<PRE>
public float <B>getVisibleAdvance</B>()</PRE>
<DL>
<DD>返回此 <code>TextLayout</code> 的 advance，减去结尾空格。返回值位于相对于基线的坐标中。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <code>TextLayout</code> 的 advance，不包括结尾的空格。<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getAdvance()"><CODE>getAdvance()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAscent()"><!-- --></A><H3>
getAscent</H3>
<PRE>
public float <B>getAscent</B>()</PRE>
<DL>
<DD>返回此 <code>TextLayout</code> 的 ascent。ascent 是从 <code>TextLayout</code> 的顶端（右端）到基线的距离。它始终为正数或零。ascent 足以容纳上标文本，它是每个字形的 ascent、偏移量和基线总和的最大值。该 ascent 是 TextLayout 中所有文本基线的最大 ascent。返回值位于相对于基线的坐标中。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <code>TextLayout</code> 的 ascent。</DL>
</DD>
</DL>
<HR>

<A NAME="getDescent()"><!-- --></A><H3>
getDescent</H3>
<PRE>
public float <B>getDescent</B>()</PRE>
<DL>
<DD>返回此 <code>TextLayout</code> 的 descent。descent 是从基线到 <code>TextLayout</code> 底部（左端）的距离。它始终为正数或零。descent 足以容纳下标文本，它是每个字形的 descent、偏移量和基线总和的最大值。该 ascent 是 TextLayout 中所有文本基线的最大 descent。返回值位于相对于基线的坐标中。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <code>TextLayout</code> 的 descent。</DL>
</DD>
</DL>
<HR>

<A NAME="getLeading()"><!-- --></A><H3>
getLeading</H3>
<PRE>
public float <B>getLeading</B>()</PRE>
<DL>
<DD>返回 <code>TextLayout</code> 的行距。行距是此 <code>TextLayout</code> 的建议行间距。返回值位于相对于基线的坐标中。
 <p>
行距通过 <code>TextLayout</code> 中所有字形向量的行距、descent 和基线计算。算法大致如下：
 <blockquote><pre>
 maxD = 0;
 maxDL = 0;
 for (GlyphVector g in all glyphvectors) {
    maxD = max(maxD, g.getDescent() + offsets[g.getBaseline()]);
    maxDL = max(maxDL, g.getDescent() + g.getLeading() +
                       offsets[g.getBaseline()]);
 }
 return maxDL - maxD;
 </pre></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <code>TextLayout</code> 的行距。</DL>
</DD>
</DL>
<HR>

<A NAME="getBounds()"><!-- --></A><H3>
getBounds</H3>
<PRE>
public <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A> <B>getBounds</B>()</PRE>
<DL>
<DD>返回此 <code>TextLayout</code> 的边界。这些边界位于标准坐标中。因为光栅化效果，这些边界可能没有封装 TextLayout 呈现的所有像素。它可能与 <code>TextLayout</code> 的 ascent、descent、origin 或 advance 并不完全一致。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>作为此 <code>TextLayout</code> 边界的 <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类"><CODE>Rectangle2D</CODE></A>。</DL>
</DD>
</DL>
<HR>

<A NAME="getPixelBounds(java.awt.font.FontRenderContext, float, float)"><!-- --></A><H3>
getPixelBounds</H3>
<PRE>
public <A HREF="../../../java/awt/Rectangle.html" title="java.awt 中的类">Rectangle</A> <B>getPixelBounds</B>(<A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 中的类">FontRenderContext</A>&nbsp;frc,
                                float&nbsp;x,
                                float&nbsp;y)</PRE>
<DL>
<DD>返回在图形中使用给定 <code>FontRenderContext</code> 在给定位置处呈现 <code>TextLayout</code> 时的像素边界。图形呈现上下文不必与用来创建此 <code>TextLayout</code> 的 <code>FontRenderContext</code> 相同，并且可以为 null。如果为 null，则使用此 <code>TextLayout</code> 的 <code>FontRenderContext</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>frc</CODE> - <code>Graphics</code> 的 <code>FontRenderContext</code>。<DD><CODE>x</CODE> - 呈现此 <code>TextLayout</code> 处的 x 坐标。<DD><CODE>y</CODE> - 呈现此 <code>TextLayout</code> 处的 y 坐标。
<DT><B>返回：</B><DD>封装受影响像素的 <code>Rectangle</code>。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/GlyphVector.html#getPixelBounds(java.awt.font.FontRenderContext, float, float)"><CODE>GlyphVector.getPixelBounds(java.awt.font.FontRenderContext, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isLeftToRight()"><!-- --></A><H3>
isLeftToRight</H3>
<PRE>
public boolean <B>isLeftToRight</B>()</PRE>
<DL>
<DD>如果此 <code>TextLayout</code> 的基本方向是从左到右，则返回 <code>true</code>；如果基本方向是从右到左，则返回 <code>false</code>。<code>TextLayout</code>  的基本方向是从左到右 (LTR) 或从右到左 (RTL)。基本方向与行中文本的实际方向无关，实际方向可以是 LTR、RTL 或混向。默认情况下，从左到右布局按左对齐来定位。如果布局在制表行上进行，那么制表符将从左到右，从而逻辑连续布局的定位将从左到右。对于 RTL 布局则相反。默认情况下，它们是按左对齐来定位的，制表符将从右到左。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果此 <code>TextLayout</code> 的基本方向是从左到右，则返回 <code>true</code>；否则返回 <code>false</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="isVertical()"><!-- --></A><H3>
isVertical</H3>
<PRE>
public boolean <B>isVertical</B>()</PRE>
<DL>
<DD>如果此 <code>TextLayout</code> 是垂直的，则返回 <code>true</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果此 <code>TextLayout</code> 是垂直的，则返回 <code>true</code>；否则返回 <code>false</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="getCharacterCount()"><!-- --></A><H3>
getCharacterCount</H3>
<PRE>
public int <B>getCharacterCount</B>()</PRE>
<DL>
<DD>返回由此 <code>TextLayout</code> 表示的字符数。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <code>TextLayout</code> 中的字符数。</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretInfo(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><!-- --></A><H3>
getCaretInfo</H3>
<PRE>
public float[] <B>getCaretInfo</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit,
                            <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</PRE>
<DL>
<DD>返回与对应于 <code>hit</code> 的插入符有关的信息。数组的第一个元素是插入符与基线的交集，它是沿基线的一段距离。数组的第二个元素是插入符的反斜面（排列/上升），它是根据位于该点的基线进行测量的。
 <p>
此方法仅用于获取信息。要显示插入符，最好使用 <code>getCaretShapes</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>hit</CODE> - 此 <code>TextLayout</code> 中的目标字符<DD><CODE>bounds</CODE> - 构造插入符位置的边界。这些边界位于相对于基线的坐标中。
<DT><B>返回：</B><DD>包含插入符位置和斜面的两元素数组。返回的插入符信息位于相对于基线的坐标中。<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int, java.awt.geom.Rectangle2D, java.awt.font.TextLayout.CaretPolicy)"><CODE>getCaretShapes(int, Rectangle2D, TextLayout.CaretPolicy)</CODE></A>, 
<A HREF="../../../java/awt/Font.html#getItalicAngle()"><CODE>Font.getItalicAngle()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCaretInfo(java.awt.font.TextHitInfo)"><!-- --></A><H3>
getCaretInfo</H3>
<PRE>
public float[] <B>getCaretInfo</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit)</PRE>
<DL>
<DD>返回与对应于 <code>hit</code> 的插入符有关的信息。此方法是 <code>getCaretInfo</code> 的便捷用法，它使用了此 <code>TextLayout</code> 的自然边界。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>hit</CODE> - 此 <code>TextLayout</code> 中的目标字符
<DT><B>返回：</B><DD>有关对应于目标字符的插入符的信息。返回的插入符信息位于相对于基线的坐标中。</DL>
</DD>
</DL>
<HR>

<A NAME="getNextRightHit(java.awt.font.TextHitInfo)"><!-- --></A><H3>
getNextRightHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A> <B>getNextRightHit</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit)</PRE>
<DL>
<DD>返回下一个插入符右侧（底部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。如果目标字符索引超出范围，则抛出 <A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类"><CODE>IllegalArgumentException</CODE></A>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>hit</CODE> - 此布局中的目标字符
<DT><B>返回：</B><DD>插入符显示在所提供目标字符的插入符右侧（底部）下一个位置的目标字符，或者返回 <code>null</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="getNextRightHit(int, java.awt.font.TextLayout.CaretPolicy)"><!-- --></A><H3>
getNextRightHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A> <B>getNextRightHit</B>(int&nbsp;offset,
                                   <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类">TextLayout.CaretPolicy</A>&nbsp;policy)</PRE>
<DL>
<DD>返回下一个插入符右侧（底部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。目标字符位于指定偏移量处根据指定策略确定的强插入符右侧。返回的目标字符是根据指定策略确定的两个可能目标字符中较强的一个。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>offset</CODE> - 此 <code>TextLayout</code> 中的插入偏移量。不能小于 0 或大于此 <code>TextLayout</code> 对象的字符计数。<DD><CODE>policy</CODE> - 用来选择强插入符的策略
<DT><B>返回：</B><DD>插入符显示在所提供目标字符的插入符右侧（底部）下一个位置的目标字符，或者返回 <code>null</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="getNextRightHit(int)"><!-- --></A><H3>
getNextRightHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A> <B>getNextRightHit</B>(int&nbsp;offset)</PRE>
<DL>
<DD>返回下一个插入符右侧（底部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。目标字符位于指定偏移量处根据默认策略确定的强插入符右侧。返回的目标字符是根据默认策略确定的两个可能目标字符中较强的一个。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>offset</CODE> - 此 <code>TextLayout</code> 中的插入偏移量。不能小于 0 或大于该 <code>TextLayout</code> 对象的字符计数。
<DT><B>返回：</B><DD>插入符显示在所提供目标字符的插入符右侧（底部）下一个位置的目标字符，或者返回 <code>null</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="getNextLeftHit(java.awt.font.TextHitInfo)"><!-- --></A><H3>
getNextLeftHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A> <B>getNextLeftHit</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit)</PRE>
<DL>
<DD>返回下一个插入符左侧（顶部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。如果目标字符索引超出范围，则抛出 <code>IllegalArgumentException</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>hit</CODE> - 此 <code>TextLayout</code> 中的目标字符。
<DT><B>返回：</B><DD>插入符显示在所提供目标字符的插入符左侧（顶部）下一个位置的目标字符，或者返回 <code>null</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="getNextLeftHit(int, java.awt.font.TextLayout.CaretPolicy)"><!-- --></A><H3>
getNextLeftHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A> <B>getNextLeftHit</B>(int&nbsp;offset,
                                  <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类">TextLayout.CaretPolicy</A>&nbsp;policy)</PRE>
<DL>
<DD>返回下一个插入符左侧（顶部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。目标字符位于指定偏移量处根据指定策略确定的强插入符左侧。返回的目标字符是根据指定策略确定的两个可能目标字符中较强的一个。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>offset</CODE> - 此 <code>TextLayout</code> 中的插入偏移量。不能小于 0 或大于此 <code>TextLayout</code> 对象的字符计数。<DD><CODE>policy</CODE> - 用来选择强插入符的策略
<DT><B>返回：</B><DD>插入符显示在所提供目标字符的插入符左侧（顶部）下一个位置的目标字符，或者返回 <code>null</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="getNextLeftHit(int)"><!-- --></A><H3>
getNextLeftHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A> <B>getNextLeftHit</B>(int&nbsp;offset)</PRE>
<DL>
<DD>返回下一个插入符左侧（顶部）的目标字符；如果没有这样的字符，则返回 <code>null</code>。目标字符位于指定偏移量处根据默认策略确定的强插入符左侧。返回的目标字符是根据默认策略确定的两个可能目标字符中较强的一个。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>offset</CODE> - 此 <code>TextLayout</code> 中的插入偏移量。不能小于 0 或大于此 <code>TextLayout</code> 对象的字符计数。
<DT><B>返回：</B><DD>插入符显示在所提供目标字符的插入符左侧（顶部）下一个位置的目标字符，或者返回 <code>null</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="getVisualOtherHit(java.awt.font.TextHitInfo)"><!-- --></A><H3>
getVisualOtherHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A> <B>getVisualOtherHit</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit)</PRE>
<DL>
<DD>返回位于指定目标字符插入符另一侧的目标字符。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>hit</CODE> - 指定的目标字符
<DT><B>返回：</B><DD>位于指定字符插入符另一侧的目标字符。</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShape(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><!-- --></A><H3>
getCaretShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A> <B>getCaretShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit,
                           <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</PRE>
<DL>
<DD>返回表示指定边界内指定目标字符处插入符的 <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口"><CODE>Shape</CODE></A>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>hit</CODE> - 生成插入符处的目标字符<DD><CODE>bounds</CODE> - 用于生成插入符的 <code>TextLayout</code> 的边界。这些边界位于相对于基线的坐标中。
<DT><B>返回：</B><DD>表示插入符的 <code>Shape</code>。返回的形状位于标准坐标中。</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShape(java.awt.font.TextHitInfo)"><!-- --></A><H3>
getCaretShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A> <B>getCaretShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit)</PRE>
<DL>
<DD>返回表示此 <code>TextLayout</code> 的自然边界中指定目标字符处插入符的 <code>Shape</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>hit</CODE> - 生成插入符处的目标字符
<DT><B>返回：</B><DD>表示插入符的 <code>Shape</code>。返回的形状位于标准坐标中。</DL>
</DD>
</DL>
<HR>

<A NAME="getCharacterLevel(int)"><!-- --></A><H3>
getCharacterLevel</H3>
<PRE>
public byte <B>getCharacterLevel</B>(int&nbsp;index)</PRE>
<DL>
<DD>返回 <code>index</code> 处字符的级别。索引 -1 和 <code>characterCount</code> 被分配为此 <code>TextLayout</code> 的基本级别。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>index</CODE> - 可获取级别的字符索引
<DT><B>返回：</B><DD>指定 index 处字符的级别。</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShapes(int, java.awt.geom.Rectangle2D, java.awt.font.TextLayout.CaretPolicy)"><!-- --></A><H3>
getCaretShapes</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A>[] <B>getCaretShapes</B>(int&nbsp;offset,
                              <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds,
                              <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类">TextLayout.CaretPolicy</A>&nbsp;policy)</PRE>
<DL>
<DD>返回对应于强插入符和弱插入符的两条路径。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>offset</CODE> - 此 <code>TextLayout</code> 中的偏移量<DD><CODE>bounds</CODE> - 插入符扩展到的边界。这些边界位于相对于基线的坐标中。<DD><CODE>policy</CODE> - 指定的 <code>CaretPolicy</code>
<DT><B>返回：</B><DD>包含两条路径的数组。元素零是强插入符。如果有两个插入符，则元素 1 为弱插入符，否则为 <code>null</code>。返回的形状位于标准坐标中。</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShapes(int, java.awt.geom.Rectangle2D)"><!-- --></A><H3>
getCaretShapes</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A>[] <B>getCaretShapes</B>(int&nbsp;offset,
                              <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</PRE>
<DL>
<DD>返回对应于强插入符和弱插入符的两条路径。此方法是使用默认插入符策略的 <code>getCaretShapes</code> 的便捷用法。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>offset</CODE> - 此 <code>TextLayout</code> 中的偏移量<DD><CODE>bounds</CODE> - 插入符扩展到的边界。此边界位于相对于基线的坐标中。
<DT><B>返回：</B><DD>对应于 <code>DEFAULT_CARET_POLICY</code> 定义的强插入符和弱插入符的两条路径。这些路径位于标准坐标中。</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShapes(int)"><!-- --></A><H3>
getCaretShapes</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A>[] <B>getCaretShapes</B>(int&nbsp;offset)</PRE>
<DL>
<DD>返回对应于强插入符和弱插入符的两条路径。此方法是 <code>getCaretShapes</code> 的便捷用法，后者使用默认插入符策略和此 <code>TextLayout</code> 对象的自然边界。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>offset</CODE> - 此 <code>TextLayout</code> 中的偏移量
<DT><B>返回：</B><DD>对应于 <code>DEFAULT_CARET_POLICY</code> 定义的强插入符和弱插入符的两条路径。这两条路径位于标准坐标中。</DL>
</DD>
</DL>
<HR>

<A NAME="getLogicalRangesForVisualSelection(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)"><!-- --></A><H3>
getLogicalRangesForVisualSelection</H3>
<PRE>
public int[] <B>getLogicalRangesForVisualSelection</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;firstEndpoint,
                                                <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;secondEndpoint)</PRE>
<DL>
<DD>返回对应于可视选择范围的逻辑文本范围。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>firstEndpoint</CODE> - 可视范围的端点<DD><CODE>secondEndpoint</CODE> - 可视范围的另一个端点。此端点可以小于 <code>firstEndpoint</code>。
<DT><B>返回：</B><DD>表示所选范围的开始/限制对的整数数组。<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><CODE>getVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><!-- --></A><H3>
getVisualHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A> <B>getVisualHighlightShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;firstEndpoint,
                                     <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;secondEndpoint,
                                     <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</PRE>
<DL>
<DD>返回封闭指定范围中扩展到 <code>bounds</code> 的可视选择范围的路径。
 <p>
如果选择范围包括最左侧（最顶部）的位置，那么它将扩展到 <code>bounds</code> 的左侧（顶部）。如果选择范围包括最右侧（最底部）的位置，那么它将扩展到边界的右侧（底部）。选择范围的高度（垂直行上的宽度）始终扩展到 <code>bounds</code>。
 <p>
尽管选择范围始终是连续的，但逻辑选择文本在混向文本的行上可能是不连续的。所选文本的逻辑范围可以使用 <code>getLogicalRangesForVisualSelection</code> 检索。例如，假设文本 "ABCdef" 中的大写字母表示在从右到左的行上呈现的从右到左的文本，可视选择范围从 0L（"A" 的开始边）到 3T（"d" 的结尾边）。文本显示如下，粗体下划线区域表示选择范围：<br><pre>
    d<u><b>efCBA  </b></u>
 </pre>
因为视觉上连续的文本在逻辑上是不连续的，所以逻辑选择范围为 0-3、4-6 (ABC, ef)。还请注意的是，由于选择了布局上最右侧的位置（"A" 的右边），因此选择范围将扩展到边界的右侧。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>firstEndpoint</CODE> - 可视选择范围的端点<DD><CODE>secondEndpoint</CODE> - 可视选择范围的另一个端点<DD><CODE>bounds</CODE> - 选择范围扩展到的边界矩形。此矩形位于相对于基线的坐标中。
<DT><B>返回：</B><DD>封闭选择范围的 <code>Shape</code>。此形状位于标准坐标中。<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getLogicalRangesForVisualSelection(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)"><CODE>getLogicalRangesForVisualSelection(TextHitInfo, TextHitInfo)</CODE></A>, 
<A HREF="../../../java/awt/font/TextLayout.html#getLogicalHighlightShape(int, int, java.awt.geom.Rectangle2D)"><CODE>getLogicalHighlightShape(int, int, Rectangle2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)"><!-- --></A><H3>
getVisualHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A> <B>getVisualHighlightShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;firstEndpoint,
                                     <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;secondEndpoint)</PRE>
<DL>
<DD>返回封闭指定范围中扩展到指定边界的可视选择范围的 <code>Shape</code>。此方法是 <code>getVisualHighlightShape</code> 的便捷用法，后者使用了此 <code>TextLayout</code> 的自然边界。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>firstEndpoint</CODE> - 可视选择范围的端点<DD><CODE>secondEndpoint</CODE> - 可视选择范围的另一个端点
<DT><B>返回：</B><DD>封闭选择范围的 <code>Shape</code>。此形状位于标准坐标中。</DL>
</DD>
</DL>
<HR>

<A NAME="getLogicalHighlightShape(int, int, java.awt.geom.Rectangle2D)"><!-- --></A><H3>
getLogicalHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A> <B>getLogicalHighlightShape</B>(int&nbsp;firstEndpoint,
                                      int&nbsp;secondEndpoint,
                                      <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</PRE>
<DL>
<DD>返回封闭指定范围中扩展到指定 <code>bounds</code> 的逻辑选择范围的 <code>Shape</code>。
 <p>
如果选择范围包括第一个逻辑字符，那么它将扩展到此 <code>TextLayout</code> 的起点之前的 <code>bounds</code> 部分。如果该范围包括最后的逻辑字符，那么它将扩展到此 <code>TextLayout</code> 的结束点之后的 <code>bounds</code> 部分。选择范围的高度（垂直行上的宽度）始终扩展到 <code>bounds</code>。
 <p>
选择范围在混向文本的行上可能是不连续的。只有逻辑范围中开始和限制之间的那些字符才显示为被选中。例如，假定文本 "ABCdef" 的大写字母表示在从右到左的行上呈现从右到左的文本，逻辑选择范围是从 0 到 4 ('ABCd')。文本显示如下，粗体表示选择范围，下划线表示扩展：<br><pre>
    <u><b>d</b></u>ef<u><b>CBA  </b></u>
 </pre>
因为选择的字符在视觉上是不连续的，该选择范围是不连续的。还请注意的是，由于该范围包括第一个逻辑字符 (A)，所以该选择范围将扩展到布局开始之前的 <code>bounds</code> 部分，在本例中（从右到左的行）是 <code>bounds</code> 的右半部。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>firstEndpoint</CODE> - 选择的字符范围的端点<DD><CODE>secondEndpoint</CODE> - 选择的字符范围的另一个端点。可以小于 <code>firstEndpoint</code>。此范围包括 min(firstEndpoint, secondEndpoint) 处的字符，但不包括 max(firstEndpoint, secondEndpoint) 处的字符。<DD><CODE>bounds</CODE> - 选择范围扩展到的边界矩形。此矩形位于相对于基线的坐标中。
<DT><B>返回：</B><DD>封装该选择范围的区域。此区域位于标准坐标中。<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><CODE>getVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLogicalHighlightShape(int, int)"><!-- --></A><H3>
getLogicalHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A> <B>getLogicalHighlightShape</B>(int&nbsp;firstEndpoint,
                                      int&nbsp;secondEndpoint)</PRE>
<DL>
<DD>返回封装指定范围中逻辑选择范围的 <code>Shape</code>，它扩展到此 <code>TextLayout</code> 的自然边界。此方法是 <code>getLogicalHighlightShape</code> 的便捷用法，后者使用了此 <code>TextLayout</code> 的自然边界。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>firstEndpoint</CODE> - 选择的字符范围的端点<DD><CODE>secondEndpoint</CODE> - 选择的字符范围的另一个端点。可以小于 <code>firstEndpoint</code>。此范围包括 min(firstEndpoint, secondEndpoint) 处的字符，但不包括 max(firstEndpoint, secondEndpoint) 处的字符。
<DT><B>返回：</B><DD>封装选择范围的 <code>Shape</code>。 此形状位于标准坐标中。</DL>
</DD>
</DL>
<HR>

<A NAME="getBlackBoxBounds(int, int)"><!-- --></A><H3>
getBlackBoxBounds</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A> <B>getBlackBoxBounds</B>(int&nbsp;firstEndpoint,
                               int&nbsp;secondEndpoint)</PRE>
<DL>
<DD>返回指定范围中字符的黑框边界。黑框边界是所有对应于开始和限制之间字符字形的边界框并集。此区域可以不相交。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>firstEndpoint</CODE> - 字符范围的端点<DD><CODE>secondEndpoint</CODE> - 字符范围的另一个端点。可以小于 <code>firstEndpoint</code>。
<DT><B>返回：</B><DD>封装黑框边界的 <code>Shape</code>。此形状位于标准坐标中。</DL>
</DD>
</DL>
<HR>

<A NAME="hitTestChar(float, float, java.awt.geom.Rectangle2D)"><!-- --></A><H3>
hitTestChar</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A> <B>hitTestChar</B>(float&nbsp;x,
                               float&nbsp;y,
                               <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 中的类">Rectangle2D</A>&nbsp;bounds)</PRE>
<DL>
<DD>返回对应于指定点的 <code>TextHitInfo</code>。将 <code>TextLayout</code> 边界之外的坐标映射到第一个逻辑字符开始边上的点，或映射到最后一个逻辑字符结束边上的点（如果合适），而不考虑该字符在行中的位置。该方法只使用基线方向。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>x</CODE> - 距离此 <code>TextLayout</code> 原点的 x 偏移量。此偏移量位于标准坐标中。<DD><CODE>y</CODE> - 距离此 <code>TextLayout</code> 原点的 y 偏移量。此偏移量位于标准坐标中。<DD><CODE>bounds</CODE> - <code>TextLayout</code> 的边界。此边界位于相对于基线的坐标中。
<DT><B>返回：</B><DD>描述指定点处字符和边缘（开始边或结尾边）的 TextHitInfo。</DL>
</DD>
</DL>
<HR>

<A NAME="hitTestChar(float, float)"><!-- --></A><H3>
hitTestChar</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A> <B>hitTestChar</B>(float&nbsp;x,
                               float&nbsp;y)</PRE>
<DL>
<DD>返回对应于指定点的 <code>TextHitInfo</code>。此方法是 <code>hitTestChar</code> 的便捷用法，后者使用了此 <code>TextLayout</code> 的自然边界。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>x</CODE> - 距离此 <code>TextLayout</code> 原点的 x 偏移量。此偏移量位于标准坐标中。<DD><CODE>y</CODE> - 距离此 <code>TextLayout</code> 原点的 y 偏移量。此偏移量位于标准坐标中。
<DT><B>返回：</B><DD>描述指定点下字符和边缘（开始边或结尾边）的 TextHitInfo。</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>返回此 <code>TextLayout</code> 的哈希码。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <code>TextLayout</code> 的哈希码。<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A>, 
<A HREF="../../../java/util/Hashtable.html" title="java.util 中的类"><CODE>Hashtable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A>&nbsp;obj)</PRE>
<DL>
<DD>如果指定 <code>Object</code> 是一个 <code>TextLayout</code> 对象，且指定的 <code>Object</code> 等于此 <code>TextLayout</code>，则返回 <code>true</code>。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>obj</CODE> - 用于测试相等性的 <code>Object</code>
<DT><B>返回：</B><DD>如果指定的 <code>Object</code> 等于此 <code>TextLayout</code>，则返回 <code>true</code>；否则返回 <code>false</code>。<DT><B>另请参见：</B><DD><A HREF="../../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A>, 
<A HREF="../../../java/util/Hashtable.html" title="java.util 中的类"><CODE>Hashtable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.awt.font.TextLayout)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 中的类">TextLayout</A>&nbsp;rhs)</PRE>
<DL>
<DD>如果两个布局相等，则返回 <code>true</code>。如果两个布局包含具有相同顺序的相等字形向量，则这两个布局相等。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>rhs</CODE> - 要与此 <code>TextLayout</code> 进行比较的 <code>TextLayout</code>
<DT><B>返回：</B><DD>如果指定的 <code>TextLayout</code> 等于此 <code>TextLayout</code>，则返回 <code>true</code>。</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>()</PRE>
<DL>
<DD>返回此 <code>TextLayout</code> 的调试信息。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../../java/lang/Object.html#toString()">toString</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此 <code>TextLayout</code> 的 <code>String</code> 形式的 <code>textLine</code></DL>
</DD>
</DL>
<HR>

<A NAME="draw(java.awt.Graphics2D, float, float)"><!-- --></A><H3>
draw</H3>
<PRE>
public void <B>draw</B>(<A HREF="../../../java/awt/Graphics2D.html" title="java.awt 中的类">Graphics2D</A>&nbsp;g2,
                 float&nbsp;x,
                 float&nbsp;y)</PRE>
<DL>
<DD>在指定的 <A HREF="../../../java/awt/Graphics2D.html" title="java.awt 中的类"><CODE>Graphics2D</CODE></A> 上下文中的指定位置上呈现此 <code>TextLayout</code>。布局的原点置于 x,&nbsp;y。呈现可能涉及此位置的 <code>getBounds()</code> 中的任何点。此方法不改变 <code>g2</code>。文本是沿着基线路径呈现的。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>g2</CODE> - 呈现布局的 <code>Graphics2D</code> 上下文<DD><CODE>x</CODE> - 此 <code>TextLayout</code> 的 X 坐标<DD><CODE>y</CODE> - 此 <code>TextLayout</code> 的 Y 坐标<DT><B>另请参见：</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getBounds()"><CODE>getBounds()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getOutline(java.awt.geom.AffineTransform)"><!-- --></A><H3>
getOutline</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 中的接口">Shape</A> <B>getOutline</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 中的类">AffineTransform</A>&nbsp;tx)</PRE>
<DL>
<DD>返回表示此 <code>TextLayout</code> 的轮廓的 <code>Shape</code>。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>tx</CODE> - 应用于此 <code>TextLayout</code> 轮廓的可选 <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 中的类"><CODE>AffineTransform</CODE></A>。
<DT><B>返回：</B><DD>此 <code>TextLayout</code> 的轮廓的 <code>Shape</code>。此形状位于标准坐标中。</DL>
</DD>
</DL>
<HR>

<A NAME="getLayoutPath()"><!-- --></A><H3>
getLayoutPath</H3>
<PRE>
public <A HREF="../../../java/awt/font/LayoutPath.html" title="java.awt.font 中的类">LayoutPath</A> <B>getLayoutPath</B>()</PRE>
<DL>
<DD>返回 LayoutPath，如果布局路径是默认路径（x 映射到 advance，y 映射到 offset），则返回 null。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>布局路径<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hitToPoint(java.awt.font.TextHitInfo, java.awt.geom.Point2D)"><!-- --></A><H3>
hitToPoint</H3>
<PRE>
public void <B>hitToPoint</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类">TextHitInfo</A>&nbsp;hit,
                       <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 中的类">Point2D</A>&nbsp;point)</PRE>
<DL>
<DD>将一个命中点转换为标准坐标中的一个点。该点在字符的基线上，在适当的情况下，它可以位于字符的开始边或结尾边上。如果路径在通过命中表示的字符边上断开，那么该点将与此字符相邻。
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>hit</CODE> - 命中检查。此参数必须是 TextLayout 上的一次有效命中。<DD><CODE>point</CODE> - 返回的点。此点位于标准坐标中。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 hit 对于 TextLayout 无效。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 hit 或 point 为 null。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/TextLayout.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 中的类"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/awt/font/TextLayout.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="TextLayout.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
