<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 13:51:00 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
java.util.concurrent (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="java.util.concurrent (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>软件包</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">类</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/package-summary.html"><B>上一个软件包</B></A>&nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/atomic/package-summary.html"><B>下一个软件包</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/package-summary.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
软件包 java.util.concurrent
</H2>
 在并发编程中很常用的实用工具类。
<P>
<B>请参见：</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>描述</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>接口摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/BlockingDeque.html" title="java.util.concurrent 中的接口">BlockingDeque&lt;E&gt;</A></B></TD>
<TD>支持两个附加操作的 <A HREF="../../../java/util/Queue.html" title="java.util 中的接口"><CODE>Queue</CODE></A>，这两个操作是：获取元素时等待双端队列变为非空；存储元素时等待双端队列中的空间变得可用。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue&lt;E&gt;</A></B></TD>
<TD>支持两个附加操作的 <A HREF="../../../java/util/Queue.html" title="java.util 中的接口"><CODE>Queue</CODE></A>，这两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 中的接口">Callable&lt;V&gt;</A></B></TD>
<TD>返回结果并且可能抛出异常的任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CompletionService.html" title="java.util.concurrent 中的接口">CompletionService&lt;V&gt;</A></B></TD>
<TD>将生产新的异步任务与使用已完成任务的结果分离开来的服务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentMap.html" title="java.util.concurrent 中的接口">ConcurrentMap&lt;K,V&gt;</A></B></TD>
<TD>提供其他原子 <tt>putIfAbsent</tt>、<tt>remove</tt>、<tt>replace</tt> 方法的 <A HREF="../../../java/util/Map.html" title="java.util 中的接口"><CODE>Map</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentNavigableMap.html" title="java.util.concurrent 中的接口">ConcurrentNavigableMap&lt;K,V&gt;</A></B></TD>
<TD>支持 <A HREF="../../../java/util/NavigableMap.html" title="java.util 中的接口"><CODE>NavigableMap</CODE></A> 操作，且以递归方式支持其可导航子映射的 <A HREF="../../../java/util/concurrent/ConcurrentMap.html" title="java.util.concurrent 中的接口"><CODE>ConcurrentMap</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Delayed.html" title="java.util.concurrent 中的接口">Delayed</A></B></TD>
<TD>一种混合风格的接口，用来标记那些应该在给定延迟时间之后执行的对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口">Executor</A></B></TD>
<TD>执行已提交的 <A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口"><CODE>Runnable</CODE></A> 任务的对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口">ExecutorService</A></B></TD>
<TD><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口"><CODE>Executor</CODE></A> 提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 中的接口"><CODE>Future</CODE></A> 的方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 中的接口">Future&lt;V&gt;</A></B></TD>
<TD><tt>Future</tt> 表示异步计算的结果。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口">RejectedExecutionHandler</A></B></TD>
<TD>无法由 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 中的类"><CODE>ThreadPoolExecutor</CODE></A> 执行的任务的处理程序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RunnableFuture.html" title="java.util.concurrent 中的接口">RunnableFuture&lt;V&gt;</A></B></TD>
<TD>作为 <A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口"><CODE>Runnable</CODE></A> 的 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 中的接口"><CODE>Future</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RunnableScheduledFuture.html" title="java.util.concurrent 中的接口">RunnableScheduledFuture&lt;V&gt;</A></B></TD>
<TD>作为 <A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口"><CODE>Runnable</CODE></A> 的 <A HREF="../../../java/util/concurrent/ScheduledFuture.html" title="java.util.concurrent 中的接口"><CODE>ScheduledFuture</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 中的接口">ScheduledExecutorService</A></B></TD>
<TD>一个 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A>，可安排在给定的延迟后运行或定期执行的命令。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledFuture.html" title="java.util.concurrent 中的接口">ScheduledFuture&lt;V&gt;</A></B></TD>
<TD>一个延迟的、结果可接受的操作，可将其取消。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口">ThreadFactory</A></B></TD>
<TD>根据需要创建新线程的对象。</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>类摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 中的类">AbstractExecutorService</A></B></TD>
<TD>提供 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A> 执行方法的默认实现。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 中的类">ArrayBlockingQueue&lt;E&gt;</A></B></TD>
<TD>一个由数组支持的有界<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">阻塞队列</A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 中的类">ConcurrentHashMap&lt;K,V&gt;</A></B></TD>
<TD>支持获取的完全并发和更新的所期望可调整并发的哈希表。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentLinkedQueue.html" title="java.util.concurrent 中的类">ConcurrentLinkedQueue&lt;E&gt;</A></B></TD>
<TD>一个基于链接节点的无界线程安全<A HREF="../../../java/util/Queue.html" title="java.util 中的接口">队列</A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentSkipListMap.html" title="java.util.concurrent 中的类">ConcurrentSkipListMap&lt;K,V&gt;</A></B></TD>
<TD>可缩放的并发 <A HREF="../../../java/util/concurrent/ConcurrentNavigableMap.html" title="java.util.concurrent 中的接口"><CODE>ConcurrentNavigableMap</CODE></A> 实现。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentSkipListSet.html" title="java.util.concurrent 中的类">ConcurrentSkipListSet&lt;E&gt;</A></B></TD>
<TD>一个基于 <A HREF="../../../java/util/concurrent/ConcurrentSkipListMap.html" title="java.util.concurrent 中的类"><CODE>ConcurrentSkipListMap</CODE></A> 的可缩放并发 <A HREF="../../../java/util/NavigableSet.html" title="java.util 中的接口"><CODE>NavigableSet</CODE></A> 实现。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 中的类">CopyOnWriteArrayList&lt;E&gt;</A></B></TD>
<TD><A HREF="../../../java/util/ArrayList.html" title="java.util 中的类"><CODE>ArrayList</CODE></A> 的一个线程安全的变体，其中所有可变操作（<tt>add</tt>、<tt>set</tt> 等等）都是通过对底层数组进行一次新的复制来实现的。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CopyOnWriteArraySet.html" title="java.util.concurrent 中的类">CopyOnWriteArraySet&lt;E&gt;</A></B></TD>
<TD>对其所有操作使用内部 <A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 中的类"><CODE>CopyOnWriteArrayList</CODE></A> 的 <A HREF="../../../java/util/Set.html" title="java.util 中的接口"><CODE>Set</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 中的类">CountDownLatch</A></B></TD>
<TD>一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CyclicBarrier.html" title="java.util.concurrent 中的类">CyclicBarrier</A></B></TD>
<TD>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/DelayQueue.html" title="java.util.concurrent 中的类">DelayQueue&lt;E extends Delayed&gt;</A></B></TD>
<TD><tt>Delayed</tt> 元素的一个无界<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">阻塞队列</A>，只有在延迟期满时才能从中提取元素。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Exchanger.html" title="java.util.concurrent 中的类">Exchanger&lt;V&gt;</A></B></TD>
<TD>可以在对中对元素进行配对和交换的线程的同步点。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutorCompletionService.html" title="java.util.concurrent 中的类">ExecutorCompletionService&lt;V&gt;</A></B></TD>
<TD>使用提供的 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口"><CODE>Executor</CODE></A> 来执行任务的 <A HREF="../../../java/util/concurrent/CompletionService.html" title="java.util.concurrent 中的接口"><CODE>CompletionService</CODE></A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 中的类">Executors</A></B></TD>
<TD>此包中所定义的 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口"><CODE>Executor</CODE></A>、<A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A>、<A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ScheduledExecutorService</CODE></A>、<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口"><CODE>ThreadFactory</CODE></A> 和 <A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 中的接口"><CODE>Callable</CODE></A> 类的工厂和实用方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 中的类">FutureTask&lt;V&gt;</A></B></TD>
<TD>可取消的异步计算。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/LinkedBlockingDeque.html" title="java.util.concurrent 中的类">LinkedBlockingDeque&lt;E&gt;</A></B></TD>
<TD>一个基于已链接节点的、任选范围的<A HREF="../../../java/util/concurrent/BlockingDeque.html" title="java.util.concurrent 中的接口">阻塞双端队列</A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 中的类">LinkedBlockingQueue&lt;E&gt;</A></B></TD>
<TD>一个基于已链接节点的、范围任意的 <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">blocking queue</A>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/PriorityBlockingQueue.html" title="java.util.concurrent 中的类">PriorityBlockingQueue&lt;E&gt;</A></B></TD>
<TD>一个无界<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">阻塞队列</A>，它使用与类 <A HREF="../../../java/util/PriorityQueue.html" title="java.util 中的类"><CODE>PriorityQueue</CODE></A> 相同的顺序规则，并且提供了阻塞获取操作。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 中的类">ScheduledThreadPoolExecutor</A></B></TD>
<TD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 中的类"><CODE>ThreadPoolExecutor</CODE></A>，它可另行安排在给定的延迟后运行命令，或者定期执行命令。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent 中的类">Semaphore</A></B></TD>
<TD>一个计数信号量。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 中的类">SynchronousQueue&lt;E&gt;</A></B></TD>
<TD>一种<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">阻塞队列</A>，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 中的类">ThreadPoolExecutor</A></B></TD>
<TD>一个 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A>，它使用可能的几个池线程之一执行每个提交的任务，通常使用 <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 中的类"><CODE>Executors</CODE></A> 工厂方法配置。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.AbortPolicy</A></B></TD>
<TD>用于被拒绝任务的处理程序，它将抛出 <tt>RejectedExecutionException</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.CallerRunsPolicy</A></B></TD>
<TD>用于被拒绝任务的处理程序，它直接在 <tt>execute</tt> 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.DiscardOldestPolicy</A></B></TD>
<TD>用于被拒绝任务的处理程序，它放弃最旧的未处理请求，然后重试 <tt>execute</tt>；如果执行程序已关闭，则会丢弃该任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.DiscardPolicy</A></B></TD>
<TD>用于被拒绝任务的处理程序，默认情况下它将丢弃被拒绝的任务。</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>枚举摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A></B></TD>
<TD><tt>TimeUnit</tt> 表示给定单元粒度的时间段，它提供在这些单元中进行跨单元转换和执行计时及延迟操作的实用工具方法。</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>异常摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/BrokenBarrierException.html" title="java.util.concurrent 中的类">BrokenBarrierException</A></B></TD>
<TD>当某个线程试图等待处于断开状态的 barrier 时，或者 barrier 进入断开状态而线程处于等待状态时，抛出该异常。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CancellationException.html" title="java.util.concurrent 中的类">CancellationException</A></B></TD>
<TD>如果某项值生成任务（如 <A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 中的类"><CODE>FutureTask</CODE></A>）的结果因为任务被取消而无法获取到，则抛出该异常。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutionException.html" title="java.util.concurrent 中的类">ExecutionException</A></B></TD>
<TD>当试图获取已通过抛出异常而中止的任务的结果时，抛出此异常。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent 中的类">RejectedExecutionException</A></B></TD>
<TD>当无法执行某个任务时,由 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口"><CODE>Executor</CODE></A> 抛出的异常。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/TimeoutException.html" title="java.util.concurrent 中的类">TimeoutException</A></B></TD>
<TD>阻塞操作超时时，抛出该异常。</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
软件包 java.util.concurrent 的描述
</H2>

<P>
<p> 在并发编程中很常用的实用工具类。此包包括了几个小的、已标准化的可扩展框架，以及一些提供有用功能的类，没有这些类，这些功能会很难实现或实现起来冗长乏味。下面简要描述主要的组件。另请参阅 <tt>locks</tt> 和 <tt>atomic</tt> 包。

<h2>执行程序</h2>

<b>接口。</b><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口"><CODE>Executor</CODE></A> 是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。根据所使用的具体 Executor 类的不同，可能在新创建的线程中，现有的任务执行线程中，或者调用 <tt>execute()</tt> 的线程中执行任务，并且可能顺序或并发执行。<A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A> 提供了多个完整的异步任务执行框架。ExecutorService 管理任务的排队和安排，并允许受控制的关闭。<A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ScheduledExecutorService</CODE></A> 子接口及相关的接口添加了对延迟的和定期任务执行的支持。ExecutorService 提供了安排异步执行的方法，可执行由 <A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 中的接口"><CODE>Callable</CODE></A> 表示的任何函数，结果类似于 <A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口"><CODE>Runnable</CODE></A>。<A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 中的接口"><CODE>Future</CODE></A> 返回函数的结果，允许确定执行是否完成，并提供取消执行的方法。<A HREF="../../../java/util/concurrent/RunnableFuture.html" title="java.util.concurrent 中的接口"><CODE>RunnableFuture</CODE></A> 是拥有 <tt>run</tt> 方法的 Future，<tt>run</tt> 方法执行时将设置其结果。 

<p>

<b>实现。</b>类 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 中的类"><CODE>ThreadPoolExecutor</CODE></A> 和 <A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 中的类"><CODE>ScheduledThreadPoolExecutor</CODE></A> 提供可调的、灵活的线程池。<A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 中的类"><CODE>Executors</CODE></A> 类提供大多数 Executor 的常见类型和配置的工厂方法，以及使用它们的几种实用工具方法。其他基于 Executor 的实用工具包括具体类 <A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 中的类"><CODE>FutureTask</CODE></A>，它提供 Future 的常见可扩展实现，以及 <A HREF="../../../java/util/concurrent/ExecutorCompletionService.html" title="java.util.concurrent 中的类"><CODE>ExecutorCompletionService</CODE></A>，它有助于协调对异步任务组的处理。

<h2>队列</h2>

java.util.concurrent <A HREF="../../../java/util/concurrent/ConcurrentLinkedQueue.html" title="java.util.concurrent 中的类"><CODE>ConcurrentLinkedQueue</CODE></A> 类提供了高效的、可伸缩的、线程安全的非阻塞 FIFO 队列。java.util.concurrent 中的五个实现都支持扩展的 <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口"><CODE>BlockingQueue</CODE></A> 接口，该接口定义了 put 和 take 的阻塞版本：<A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 中的类"><CODE>LinkedBlockingQueue</CODE></A>、<A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 中的类"><CODE>ArrayBlockingQueue</CODE></A>、<A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 中的类"><CODE>SynchronousQueue</CODE></A>、<A HREF="../../../java/util/concurrent/PriorityBlockingQueue.html" title="java.util.concurrent 中的类"><CODE>PriorityBlockingQueue</CODE></A> 和 <A HREF="../../../java/util/concurrent/DelayQueue.html" title="java.util.concurrent 中的类"><CODE>DelayQueue</CODE></A>。这些不同的类覆盖了生产者-使用者、消息传递、并行任务执行和相关并发设计的大多数常见使用的上下文。<A HREF="../../../java/util/concurrent/BlockingDeque.html" title="java.util.concurrent 中的接口"><CODE>BlockingDeque</CODE></A> 接口扩展 <tt>BlockingQueue</tt>，以支持 FIFO 和 LIFO（基于堆栈）操作。<A HREF="../../../java/util/concurrent/LinkedBlockingDeque.html" title="java.util.concurrent 中的类"><CODE>LinkedBlockingDeque</CODE></A> 类提供一个实现。


<h2>计时</h2>

<A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举"><CODE>TimeUnit</CODE></A> 类为指定和控制基于超时的操作提供了多重粒度（包括纳秒级）。该包中的大多数类除了包含不确定的等待之外，还包含基于超时的操作。在使用超时的所有情况中，超时指定了在表明已超时前该方法应该等待的最少时间。在超时发生后，实现会&ldquo;尽力&rdquo;检测超时。但是，在检测超时与超时之后再次实际执行线程之间可能要经过不确定的时间。接受超时期参数的所有方法将小于等于 0 的值视为根本不会等待。要“永远”等待，可以使用 <tt>Long.MAX_VALUE</tt> 值。

<h2>同步器</h2>

四个类可协助实现常见的专用同步语句。<A HREF="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent 中的类"><CODE>Semaphore</CODE></A> 是一个经典的并发工具。<A HREF="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 中的类"><CODE>CountDownLatch</CODE></A> 是一个极其简单但又极其常用的实用工具，用于在保持给定数目的信号、事件或条件前阻塞执行。<A HREF="../../../java/util/concurrent/CyclicBarrier.html" title="java.util.concurrent 中的类"><CODE>CyclicBarrier</CODE></A> 是一个可重置的多路同步点，在某些并行编程风格中很有用。<A HREF="../../../java/util/concurrent/Exchanger.html" title="java.util.concurrent 中的类"><CODE>Exchanger</CODE></A> 允许两个线程在 collection 点交换对象，它在多流水线设计中是有用的。

<h2>并发 Collection</h2>

除队列外，此包还提供了设计用于多线程上下文中的 Collection 实现：<A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 中的类"><CODE>ConcurrentHashMap</CODE></A>、<A HREF="../../../java/util/concurrent/ConcurrentSkipListMap.html" title="java.util.concurrent 中的类"><CODE>ConcurrentSkipListMap</CODE></A>、<A HREF="../../../java/util/concurrent/ConcurrentSkipListSet.html" title="java.util.concurrent 中的类"><CODE>ConcurrentSkipListSet</CODE></A>、<A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 中的类"><CODE>CopyOnWriteArrayList</CODE></A> 和
<A HREF="../../../java/util/concurrent/CopyOnWriteArraySet.html" title="java.util.concurrent 中的类"><CODE>CopyOnWriteArraySet</CODE></A>。当期望许多线程访问一个给定 collection 时，<tt>ConcurrentHashMap</tt> 通常优于同步的 <tt>HashMap</tt>，<tt>ConcurrentSkipListMap</tt> 通常优于同步的 <tt>TreeMap</tt>。当期望的读数和遍历远远大于列表的更新数时，<tt>CopyOnWriteArrayList</tt> 优于同步的 <tt>ArrayList</tt>。

<p>此包中与某些类一起使用的&ldquo;Concurrent&rdquo前缀;是一种简写，表明与类似的&ldquo;同步&rdquo;类有所不同。例如，<tt>java.util.Hashtable</tt> 和 <tt>Collections.synchronizedMap(new HashMap())</tt> 是同步的，但 <A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 中的类"><CODE>ConcurrentHashMap</CODE></A> 则是&ldquo;并发的&rdquo;。并发 collection 是线程安全的，但是不受单个排他锁的管理。在 ConcurrentHashMap 这一特定情况下，它可以安全地允许进行任意数目的并发读取，以及数目可调的并发写入。需要通过单个锁不允许对 collection 的所有访问时，&ldquo;同步&rdquo;类是很有用的，其代价是较差的可伸缩性。在期望多个线程访问公共 collection 的其他情况中，通常&ldquo;并发&rdquo;版本要更好一些。当 collection 是未共享的，或者仅保持其他锁时 collection 是可访问的情况下，非同步 collection 则要更好一些。

<p> 大多数并发 Collection 实现（包括大多数 Queue）与常规的 java.util 约定也不同，因为它们的迭代器提供了<em>弱一致的</em>，而不是快速失败的遍历。弱一致的迭代器是线程安全的，但是在迭代时没有必要冻结 collection，所以它不一定反映自迭代器创建以来的所有更新。

<a name="MemoryVisibility">
<h2>内存一致性属性</h2>

<a href="http://java.sun.com/docs/books/jls/third_edition/html/memory.html">
Java Language Specification 第 17 章</a>定义了内存操作（如共享变量的读写）的 <i>happen-before</i> 关系。只有写入操作 <i>happen-before</i> 读取操作时，才保证一个线程写入的结果对另一个线程的读取是可视的。<code>synchronized</code> 和 <code>volatile</code> 构造 <i>happen-before</i> 关系，<code>Thread.start()</code> 和 <code>Thread.join()</code> 方法形成 <i>happen-before</i> 关系。尤其是：

<ul>
  <li>线程中的每个操作 <i>happen-before</i> 稍后按程序顺序传入的该线程中的每个操作。 

  <li>一个解除锁监视器的（<code>synchronized</code> 阻塞或方法退出）<i>happen-before</i> 相同监视器的每个后续锁（<code>synchronized</code> 阻塞或方法进入）。并且因为 <i>happen-before</i> 关系是可传递的，所以解除锁定之前的线程的所有操作 <i>happen-before</i> 锁定该监视器的任何线程后续的所有操作。

  <li>写入 <code>volatile</code> 字段 <i>happen-before</i> 每个后续读取相同字段。<code>volatile</code> 字段的读取和写入与进入和退出监视器具有相似的内存一致性效果，但<em>不</em> 需要互斥锁。

  <li>在线程上调用 <code>start</code> <i>happen-before</i> 已启动的线程中的任何线程。

  <li>线程中的所有操作 <i>happen-before</i> 从该线程上的 <code>join</code> 成功返回的任何其他线程。

</ul>


<code>java.util.concurrent</code> 中所有类的方法及其子包扩展了这些对更高级别同步的保证。尤其是：

<ul>

  <li>线程中将一个对象放入任何并发 collection 之前的操作 <i>happen-before</i> 从另一线程中的 collection 访问或移除该元素的后续操作。

  <li>线程中向 <code>Executor</code> 提交 <code>Runnable</code> 之前的操作 <i>happen-before</i> 其执行开始。同样适用于向 <code>ExecutorService</code> 提交 <code>Callables</code>。

  <li>异步计算（由 <code>Future</code> 表示）所采取的操作 <i>happen-before</i> 通过另一线程中 <code>Future.get()</code> 获取结果后续的操作。

  <li>“释放”同步储存方法（如 <code>Lock.unlock</code>、<code>Semaphore.release</code> 和 <code>CountDownLatch.countDown</code>）之前的操作 <i>happen-before</i> 另一线程中相同同步储存对象成功“获取”方法（如 <code>Lock.lock</code>、<code>Semaphore.acquire</code>、<code>Condition.await</code> 和 <code>CountDownLatch.await</code>）的后续操作。

  <li>对于通过 <code>Exchanger</code> 成功交换对象的每个线程对，每个线程中 <code>exchange()</code> 之前的操作 <i>happen-before</i> 另一线程中对应 <code>exchange()</code> 后续的操作。

  <li>调用 <code>CyclicBarrier.await</code> 之前的操作 <i>happen-before</i> 屏障操作所执行的操作，屏障操作所执行的操作 <i>happen-before</i> 从另一线程中对应 <code>await</code> 成功返回的后续操作。

</ul>
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>软件包</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">类</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/package-summary.html"><B>上一个软件包</B></A>&nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/atomic/package-summary.html"><B>下一个软件包</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/package-summary.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
