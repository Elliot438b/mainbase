<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 12:53:13 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
ThreadPoolExecutor (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ThreadPoolExecutor (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ThreadPoolExecutor.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/ThreadPoolExecutor.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="ThreadPoolExecutor.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent</FONT>
<BR>
类 ThreadPoolExecutor</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="继承者 "><A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 中的类">java.util.concurrent.AbstractExecutorService</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="继承者 "><B>java.util.concurrent.ThreadPoolExecutor</B>
</PRE>
<DL>
<DT><B>所有已实现的接口：</B> <DD><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 中的接口">Executor</A>, <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口">ExecutorService</A></DD>
</DL>
<DL>
<DT><B>直接已知子类：</B> <DD><A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 中的类">ScheduledThreadPoolExecutor</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ThreadPoolExecutor</B><DT>extends <A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 中的类">AbstractExecutorService</A></DL>
</PRE>

<P>
一个 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 中的接口"><CODE>ExecutorService</CODE></A>，它使用可能的几个池线程之一执行每个提交的任务，通常使用 <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 中的类"><CODE>Executors</CODE></A> 工厂方法配置。

<p>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 <tt>ThreadPoolExecutor</tt> 还维护着一些基本的统计数据，如完成的任务数。

<p>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 中的类"><CODE>Executors</CODE></A> 工厂方法 <A HREF="../../../java/util/concurrent/Executors.html#newCachedThreadPool()"><CODE>Executors.newCachedThreadPool()</CODE></A>（无界线程池，可以进行自动线程回收）、<A HREF="../../../java/util/concurrent/Executors.html#newFixedThreadPool(int)"><CODE>Executors.newFixedThreadPool(int)</CODE></A>（固定大小线程池）和 <A HREF="../../../java/util/concurrent/Executors.html#newSingleThreadExecutor()"><CODE>Executors.newSingleThreadExecutor()</CODE></A>（单个后台线程），它们均为大多数使用场景预定义了设置。否则，在手动配置和调整此类时，使用以下指导：

<dl>

<dt>核心和最大池大小</dt>

<dd><tt>ThreadPoolExecutor</tt> 将根据 corePoolSize（参见 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()"><CODE>getCorePoolSize()</CODE></A>）和 maximumPoolSize（参见 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()"><CODE>getMaximumPoolSize()</CODE></A>）设置的边界自动调整池大小。当新任务在方法 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)"><CODE>execute(java.lang.Runnable)</CODE></A> 中提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的。如果运行的线程多于 corePoolSize 而少于 maximumPoolSize，则仅当队列满时才创建新线程。如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池。如果将 maximumPoolSize 设置为基本的无界值（如 <tt>Integer.MAX_VALUE</tt>），则允许池适应任意数量的并发任务。在大多数情况下，核心和最大池大小仅基于构造来设置，不过也可以使用 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)"><CODE>setCorePoolSize(int)</CODE></A> 和 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)"><CODE>setMaximumPoolSize(int)</CODE></A> 进行动态更改。 </dd>

<dt> 按需构造</dt>

<dd> 默认情况下，即使核心线程最初只是在新任务到达时才创建和启动的，也可以使用方法 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread()"><CODE>prestartCoreThread()</CODE></A> 或 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads()"><CODE>prestartAllCoreThreads()</CODE></A> 对其进行动态重写。如果构造带有非空队列的池，则可能希望预先启动线程。 </dd>

<dt>创建新线程</dt>

<dd>使用 <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口"><CODE>ThreadFactory</CODE></A> 创建新线程。如果没有另外说明，则在同一个 <A HREF="../../../java/lang/ThreadGroup.html" title="java.lang 中的类"><CODE>ThreadGroup</CODE></A> 中一律使用 <A HREF="../../../java/util/concurrent/Executors.html#defaultThreadFactory()"><CODE>Executors.defaultThreadFactory()</CODE></A> 创建线程，并且这些线程具有相同的 <tt>NORM_PRIORITY</tt> 优先级和非守护进程状态。通过提供不同的 ThreadFactory，可以改变线程的名称、线程组、优先级、守护进程状态，等等。如果从 <tt>newThread</tt> 返回 null 时 <tt>ThreadFactory</tt> 未能创建线程，则执行程序将继续运行，但不能执行任何任务。 </dd>

<dt>保持活动时间</dt>

<dd>如果池中当前有多于 corePoolSize 的线程，则这些多出的线程在空闲时间超过 keepAliveTime 时将会终止（参见 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)"><CODE>getKeepAliveTime(java.util.concurrent.TimeUnit)</CODE></A>）。这提供了当池处于非活动状态时减少资源消耗的方法。如果池后来变得更为活动，则可以创建新的线程。也可以使用方法 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><CODE>setKeepAliveTime(long, java.util.concurrent.TimeUnit)</CODE></A> 动态地更改此参数。使用 <tt>Long.MAX_VALUE</tt> <A HREF="../../../java/util/concurrent/TimeUnit.html#NANOSECONDS"><CODE>TimeUnit.NANOSECONDS</CODE></A> 的值在关闭前有效地从以前的终止状态禁用空闲线程。默认情况下，保持活动策略只在有多于 corePoolSizeThreads 的线程时应用。但是只要 keepAliveTime 值非 0，<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut(boolean)"><CODE>allowCoreThreadTimeOut(boolean)</CODE></A> 方法也可将此超时策略应用于核心线程。 </dd>

<dt>排队</dt>

<dd>所有 <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口"><CODE>BlockingQueue</CODE></A> 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互：

 <ul>

<li> 如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。</li>

<li> 如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。</li>
 
<li> 如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。</li>

 </ul>

排队有三种通用策略：
 <ol>

<li> <em> 直接提交。</em>工作队列的默认选项是 <A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 中的类"><CODE>SynchronousQueue</CODE></A>，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>

<li><em> 无界队列。</em>使用无界队列（例如，不具有预定义容量的 <A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 中的类"><CODE>LinkedBlockingQueue</CODE></A>）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>

<li><em>有界队列。</em>当使用有限的 maximumPoolSizes 时，有界队列（如 <A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 中的类"><CODE>ArrayBlockingQueue</CODE></A>）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</li>

 </ol>

 </dd>

<dt>被拒绝的任务</dt>

<dd> 当 Executor 已经关闭，并且 Executor 将有限边界用于最大线程和工作队列容量，且已经饱和时，在方法 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)"><CODE>execute(java.lang.Runnable)</CODE></A> 中提交的新任务将被<em>拒绝</em>。在以上两种情况下，<tt>execute</tt> 方法都将调用其 <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口"><CODE>RejectedExecutionHandler</CODE></A> 的 <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html#rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)"><CODE>RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)</CODE></A> 方法。下面提供了四种预定义的处理程序策略：

 <ol>

<li> 在默认的 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 中的类"><CODE>ThreadPoolExecutor.AbortPolicy</CODE></A> 中，处理程序遭到拒绝将抛出运行时 <A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent 中的类"><CODE>RejectedExecutionException</CODE></A>。</li>
 
<li> 在 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent 中的类"><CODE>ThreadPoolExecutor.CallerRunsPolicy</CODE></A> 中，线程调用运行该任务的 <tt>execute</tt> 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</li>

<li> 在 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent 中的类"><CODE>ThreadPoolExecutor.DiscardPolicy</CODE></A> 中，不能执行的任务将被删除。</li>

<li>在 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent 中的类"><CODE>ThreadPoolExecutor.DiscardOldestPolicy</CODE></A> 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。</li>

 </ol>

定义和使用其他种类的 <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口"><CODE>RejectedExecutionHandler</CODE></A> 类也是可能的，但这样做需要非常小心，尤其是当策略仅用于特定容量或排队策略时。</dd>

<dt>钩子 (hook) 方法</dt>

<dd>此类提供 <tt>protected</tt> 可重写的 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute(java.lang.Thread, java.lang.Runnable)"><CODE>beforeExecute(java.lang.Thread, java.lang.Runnable)</CODE></A> 和 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable, java.lang.Throwable)"><CODE>afterExecute(java.lang.Runnable, java.lang.Throwable)</CODE></A> 方法，这两种方法分别在执行每个任务之前和之后调用。它们可用于操纵执行环境；例如，重新初始化 ThreadLocal、搜集统计信息或添加日志条目。此外，还可以重写方法 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#terminated()"><CODE>terminated()</CODE></A> 来执行 Executor 完全终止后需要完成的所有特殊处理。 

<p>如果钩子 (hook) 或回调方法抛出异常，则内部辅助线程将依次失败并突然终止。</dd> 

<dt>队列维护</dt>

<dd> 方法 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getQueue()"><CODE>getQueue()</CODE></A> 允许出于监控和调试目的而访问工作队列。强烈反对出于其他任何目的而使用此方法。<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#remove(java.lang.Runnable)"><CODE>remove(java.lang.Runnable)</CODE></A> 和 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()"><CODE>purge()</CODE></A> 这两种方法可用于在取消大量已排队任务时帮助进行存储回收。</dd> 

 <dt>终止</dt>

<dd> 程序 <em>AND</em> 不再引用的池没有剩余线程会自动 <tt>shutdown</tt>。如果希望确保回收取消引用的池（即使用户忘记调用 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown()"><CODE>shutdown()</CODE></A>），则必须安排未使用的线程最终终止：设置适当保持活动时间，使用 0 核心线程的下边界和/或设置 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut(boolean)"><CODE>allowCoreThreadTimeOut(boolean)</CODE></A>。</dd> </dl>

<p> <b>扩展示例</b>。此类的大多数扩展可以重写一个或多个受保护的钩子 (hook) 方法。例如，下面是一个添加了简单的暂停/恢复功能的子类：

 <pre>
 class PausableThreadPoolExecutor extends ThreadPoolExecutor {
   private boolean isPaused;
   private ReentrantLock pauseLock = new ReentrantLock();
   private Condition unpaused = pauseLock.newCondition();

   public PausableThreadPoolExecutor(...) { super(...); }
 
   protected void beforeExecute(Thread t, Runnable r) {
     super.beforeExecute(t, r);
     pauseLock.lock();
     try {
       while (isPaused) unpaused.await();
     } catch(InterruptedException ie) {
       t.interrupt();
     } finally {
       pauseLock.unlock();
     }
   }
 
   public void pause() {
     pauseLock.lock();
     try {
       isPaused = true;
     } finally {
       pauseLock.unlock();
     }
   }
 
   public void resume() {
     pauseLock.lock();
     try {
       isPaused = false;
       unpaused.signalAll();
     } finally {
       pauseLock.unlock();
     }
   }
 }
 </pre>
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.5</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>嵌套类摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.AbortPolicy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于被拒绝任务的处理程序，它将抛出 <tt>RejectedExecutionException</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.CallerRunsPolicy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于被拒绝任务的处理程序，它直接在 <tt>execute</tt> 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.DiscardOldestPolicy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于被拒绝任务的处理程序，它放弃最旧的未处理请求，然后重试 <tt>execute</tt>；如果执行程序已关闭，则会丢弃该任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent 中的类">ThreadPoolExecutor.DiscardPolicy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于被拒绝任务的处理程序，默认情况下它将丢弃被拒绝的任务。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue)">ThreadPoolExecutor</A></B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt;&nbsp;workQueue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用给定的初始参数和默认的线程工厂及被拒绝的执行处理程序创建新的 <tt>ThreadPoolExecutor</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler)">ThreadPoolExecutor</A></B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口">RejectedExecutionHandler</A>&nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用给定的初始参数和默认的线程工厂创建新的 <tt>ThreadPoolExecutor</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory)">ThreadPoolExecutor</A></B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口">ThreadFactory</A>&nbsp;threadFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用给定的初始参数和默认被拒绝的执行处理程序创建新的 <tt>ThreadPoolExecutor</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)">ThreadPoolExecutor</A></B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口">ThreadFactory</A>&nbsp;threadFactory,
                   <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口">RejectedExecutionHandler</A>&nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用给定的初始参数创建新的 <tt>ThreadPoolExecutor</tt>。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable, java.lang.Throwable)">afterExecute</A></B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;r,
             <A HREF="../../../java/lang/Throwable.html" title="java.lang 中的类">Throwable</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于完成执行给定 Runnable 所调用的方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut(boolean)">allowCoreThreadTimeOut</A></B>(boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在保持活动时间内没有任务到达，新任务到达时正在替换（如果需要），则设置控制核心线程是超时还是终止的策略。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#allowsCoreThreadTimeOut()">allowsCoreThreadTimeOut</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此池允许核心线程超时和终止，如果在 keepAlive 时间内没有任务到达，新任务到达时正在替换（如果需要），则返回 true。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#awaitTermination(long, java.util.concurrent.TimeUnit)">awaitTermination</A></B>(long&nbsp;timeout,
                 <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute(java.lang.Thread, java.lang.Runnable)">beforeExecute</A></B>(<A HREF="../../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>&nbsp;t,
              <A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在执行给定线程中的给定 Runnable 之前调用的方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)">execute</A></B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;command)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在将来某个时间执行给定任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#finalize()">finalize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当不再引用此执行程序时，调用 <tt>shutdown</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getActiveCount()">getActiveCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回主动执行任务的近似线程数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCompletedTaskCount()">getCompletedTaskCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回已完成执行的近似任务总数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()">getCorePoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回核心线程数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)">getKeepAliveTime</A></B>(<A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回线程保持活动的时间，该时间就是超过核心池大小的线程可以在终止前保持空闲的时间值。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getLargestPoolSize()">getLargestPoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回曾经同时位于池中的最大线程数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()">getMaximumPoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回允许的最大线程数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getPoolSize()">getPoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回池中的当前线程数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getQueue()">getQueue</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此执行程序使用的任务队列。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口">RejectedExecutionHandler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler()">getRejectedExecutionHandler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回用于未执行任务的当前处理程序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getTaskCount()">getTaskCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回曾计划执行的近似任务总数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口">ThreadFactory</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory()">getThreadFactory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回用于创建新线程的线程工厂。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isShutdown()">isShutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此执行程序已关闭，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isTerminated()">isTerminated</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果关闭后所有任务都已完成，则返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isTerminating()">isTerminating</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果此执行程序处于在 <tt>shutdown</tt> 或 <tt>shutdownNow</tt> 之后正在终止但尚未完全终止的过程中，则返回 true。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads()">prestartAllCoreThreads</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动所有核心线程，使其处于等待工作的空闲状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread()">prestartCoreThread</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动核心线程，使其处于等待工作的空闲状态。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()">purge</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尝试从工作队列移除所有已取消的 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 中的接口"><CODE>Future</CODE></A> 任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#remove(java.lang.Runnable)">remove</A></B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;task)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)">setCorePoolSize</A></B>(int&nbsp;corePoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置核心线程数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)">setKeepAliveTime</A></B>(long&nbsp;time,
                 <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置线程在终止前可以保持空闲的时间限制。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)">setMaximumPoolSize</A></B>(int&nbsp;maximumPoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置允许的最大线程数。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)">setRejectedExecutionHandler</A></B>(<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口">RejectedExecutionHandler</A>&nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置用于未执行任务的新处理程序。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory(java.util.concurrent.ThreadFactory)">setThreadFactory</A></B>(<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口">ThreadFactory</A>&nbsp;threadFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置用于创建新线程的线程工厂。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown()">shutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/List.html" title="java.util 中的接口">List</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdownNow()">shutdownNow</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#terminated()">terminated</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 Executor 已经终止时调用的方法。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.concurrent.AbstractExecutorService"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.util.concurrent.<A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 中的类">AbstractExecutorService</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll(java.util.Collection)">invokeAll</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll(java.util.Collection, long, java.util.concurrent.TimeUnit)">invokeAll</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny(java.util.Collection)">invokeAny</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny(java.util.Collection, long, java.util.concurrent.TimeUnit)">invokeAny</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#newTaskFor(java.util.concurrent.Callable)">newTaskFor</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#newTaskFor(java.lang.Runnable, T)">newTaskFor</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.util.concurrent.Callable)">submit</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.lang.Runnable)">submit</A>, <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.lang.Runnable, T)">submit</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue)"><!-- --></A><H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt;&nbsp;workQueue)</PRE>
<DL>
<DD>用给定的初始参数和默认的线程工厂及被拒绝的执行处理程序创建新的 <tt>ThreadPoolExecutor</tt>。使用 <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 中的类"><CODE>Executors</CODE></A> 工厂方法之一比使用此通用构造方法方便得多。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>corePoolSize</CODE> - 池中所保存的线程数，包括空闲线程。<DD><CODE>maximumPoolSize</CODE> - 池中允许的最大线程数。<DD><CODE>keepAliveTime</CODE> - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。<DD><CODE>unit</CODE> - keepAliveTime 参数的时间单位。<DD><CODE>workQueue</CODE> - 执行前用于保持任务的队列。此队列仅保持由 <tt>execute</tt> 方法提交的 <tt>Runnable</tt> 任务。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 corePoolSize 或 keepAliveTime 小于 0，或者 maximumPoolSize 小于等于 0，或者 corePoolSize 大于 maximumPoolSize。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>workQueue</tt> 为 null</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory)"><!-- --></A><H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口">ThreadFactory</A>&nbsp;threadFactory)</PRE>
<DL>
<DD>用给定的初始参数和默认被拒绝的执行处理程序创建新的 <tt>ThreadPoolExecutor</tt>。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>corePoolSize</CODE> - 池中所保存的线程数，包括空闲线程。<DD><CODE>maximumPoolSize</CODE> - 池中允许的最大线程数。<DD><CODE>keepAliveTime</CODE> - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。<DD><CODE>unit</CODE> - keepAliveTime 参数的时间单位。<DD><CODE>workQueue</CODE> - 执行前用于保持任务的队列。此队列仅保持由 <tt>execute</tt> 方法提交的 <tt>Runnable</tt> 任务。<DD><CODE>threadFactory</CODE> - 执行程序创建新线程时使用的工厂。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 corePoolSize 或 keepAliveTime 小于 0，或者 maximumPoolSize 小于等于 0，或者 corePoolSize 大于 maximumPoolSize。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>workQueue</tt> 或 <tt>threadFactory</tt> 为 null。</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler)"><!-- --></A><H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口">RejectedExecutionHandler</A>&nbsp;handler)</PRE>
<DL>
<DD>用给定的初始参数和默认的线程工厂创建新的 <tt>ThreadPoolExecutor</tt>。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>corePoolSize</CODE> - 池中所保存的线程数，包括空闲线程。<DD><CODE>maximumPoolSize</CODE> - 池中允许的最大线程数。<DD><CODE>keepAliveTime</CODE> - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。<DD><CODE>unit</CODE> - keepAliveTime 参数的时间单位。<DD><CODE>workQueue</CODE> - 执行前用于保持任务的队列。此队列仅由保持 <tt>execute</tt> 方法提交的 <tt>Runnable</tt> 任务。<DD><CODE>handler</CODE> - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 corePoolSize 或 keepAliveTime 小于 0，或者 maximumPoolSize 小于等于 0，或者 corePoolSize 大于 maximumPoolSize。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>workQueue</tt> 或 <tt>handler</tt> 为 null。</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)"><!-- --></A><H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口">ThreadFactory</A>&nbsp;threadFactory,
                          <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口">RejectedExecutionHandler</A>&nbsp;handler)</PRE>
<DL>
<DD>用给定的初始参数创建新的 <tt>ThreadPoolExecutor</tt>。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>corePoolSize</CODE> - 池中所保存的线程数，包括空闲线程。<DD><CODE>maximumPoolSize</CODE> - 池中允许的最大线程数。<DD><CODE>keepAliveTime</CODE> - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。<DD><CODE>unit</CODE> - keepAliveTime 参数的时间单位。<DD><CODE>workQueue</CODE> - 执行前用于保持任务的队列。此队列仅保持由 <tt>execute</tt> 方法提交的 <tt>Runnable</tt> 任务。<DD><CODE>threadFactory</CODE> - 执行程序创建新线程时使用的工厂。<DD><CODE>handler</CODE> - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 corePoolSize 或 keepAliveTime 小于 0，或者 maximumPoolSize 小于等于 0，或者 corePoolSize 大于 maximumPoolSize。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>workQueue</tt>、<tt>threadFactory</tt> 或 <tt>handler</tt> 为 null。</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="execute(java.lang.Runnable)"><!-- --></A><H3>
execute</H3>
<PRE>
public void <B>execute</B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;command)</PRE>
<DL>
<DD>在将来某个时间执行给定任务。可以在新线程中或者在现有池线程中执行该任务。

如果无法将任务提交执行，或者因为此执行程序已关闭，或者因为已达到其容量，则该任务由当前 <tt>RejectedExecutionHandler</tt> 处理。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>command</CODE> - 要执行的任务。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent 中的类">RejectedExecutionException</A></CODE> - 如果无法接收要执行的任务，则由 <tt>RejectedExecutionHandler</tt> 决定是否抛出 RejectedExecutionException
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果命令为 null</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown()"><!-- --></A><H3>
shutdown</H3>
<PRE>
public void <B>shutdown</B>()</PRE>
<DL>
<DD>按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。如果已经关闭，则调用没有其他作用。
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在并且关闭此 ExecutorService 可能操作某些不允许调用者修改的线程（因为它没有 <A HREF="../../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A><tt>(&quot;modifyThread&quot;)</tt>），或者安全管理器的 <tt>checkAccess</tt> 方法拒绝访问。</DL>
</DD>
</DL>
<HR>

<A NAME="shutdownNow()"><!-- --></A><H3>
shutdownNow</H3>
<PRE>
public <A HREF="../../../java/util/List.html" title="java.util 中的接口">List</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt; <B>shutdownNow</B>()</PRE>
<DL>
<DD>尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表。在从此方法返回的任务队列中排空（移除）这些任务。
  
<p>并不保证能够停止正在处理的活动执行任务，但是会尽力尝试。 此实现通过 <A HREF="../../../java/lang/Thread.html#interrupt()"><CODE>Thread.interrupt()</CODE></A> 取消任务，所以无法响应中断的任何任务可能永远无法终止。
<P>
<DD><DL>

<DT><B>返回：</B><DD>从未开始执行的任务的列表。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 中的类">SecurityException</A></CODE> - 如果安全管理器存在并且关闭此 ExecutorService 可能操作某些不允许调用者修改的线程（因为它没有 <A HREF="../../../java/lang/RuntimePermission.html" title="java.lang 中的类"><CODE>RuntimePermission</CODE></A><tt>(&quot;modifyThread&quot;)</tt>），或者安全管理器的 <tt>checkAccess</tt> 方法拒绝访问。</DL>
</DD>
</DL>
<HR>

<A NAME="isShutdown()"><!-- --></A><H3>
isShutdown</H3>
<PRE>
public boolean <B>isShutdown</B>()</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#isShutdown()">ExecutorService</A></CODE> 复制的描述</B></DD>
<DD>如果此执行程序已关闭，则返回 <tt>true</tt>。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果此执行程序已关闭，则返回 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="isTerminating()"><!-- --></A><H3>
isTerminating</H3>
<PRE>
public boolean <B>isTerminating</B>()</PRE>
<DL>
<DD>如果此执行程序处于在 <tt>shutdown</tt> 或 <tt>shutdownNow</tt> 之后正在终止但尚未完全终止的过程中，则返回 true。此方法可能对调试很有用。关闭之后很长一段时间才报告返回的 <tt>true</tt>，这可能表示提交的任务已经被忽略或取消中断，导致此执行程序无法正确终止。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果正在终止但尚未完成，则返回 true</DL>
</DD>
</DL>
<HR>

<A NAME="isTerminated()"><!-- --></A><H3>
isTerminated</H3>
<PRE>
public boolean <B>isTerminated</B>()</PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#isTerminated()">ExecutorService</A></CODE> 复制的描述</B></DD>
<DD>如果关闭后所有任务都已完成，则返回 <tt>true</tt>。注意，除非首先调用 <tt>shutdown</tt> 或 <tt>shutdownNow</tt>，否则 <tt>isTerminated</tt> 永不为 <tt>true</tt>。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果关闭后所有任务都已完成，则返回 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="awaitTermination(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
awaitTermination</H3>
<PRE>
public boolean <B>awaitTermination</B>(long&nbsp;timeout,
                                <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit)
                         throws <A HREF="../../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></PRE>
<DL>
<DD><B>从接口 <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#awaitTermination(long, java.util.concurrent.TimeUnit)">ExecutorService</A></CODE> 复制的描述</B></DD>
<DD>请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>timeout</CODE> - 最长等待时间<DD><CODE>unit</CODE> - timeout 参数的时间单位
<DT><B>返回：</B><DD>如果此执行程序终止，则返回 <tt>true</tt>；如果终止前超时期满，则返回 <tt>false</tt>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/InterruptedException.html" title="java.lang 中的类">InterruptedException</A></CODE> - 如果等待时发生中断</DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A><H3>
finalize</H3>
<PRE>
protected void <B>finalize</B>()</PRE>
<DL>
<DD>当不再引用此执行程序时，调用 <tt>shutdown</tt>。
<P>
<DD><DL>
<DT><B>覆盖：</B><DD>类 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE> 中的 <CODE><A HREF="../../../java/lang/Object.html#finalize()">finalize</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setThreadFactory(java.util.concurrent.ThreadFactory)"><!-- --></A><H3>
setThreadFactory</H3>
<PRE>
public void <B>setThreadFactory</B>(<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口">ThreadFactory</A>&nbsp;threadFactory)</PRE>
<DL>
<DD>设置用于创建新线程的线程工厂。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>threadFactory</CODE> - 新线程工厂
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 threadFactory 为 null<DT><B>另请参见：</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory()"><CODE>getThreadFactory()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getThreadFactory()"><!-- --></A><H3>
getThreadFactory</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口">ThreadFactory</A> <B>getThreadFactory</B>()</PRE>
<DL>
<DD>返回用于创建新线程的线程工厂。
<P>
<DD><DL>

<DT><B>返回：</B><DD>当前线程工厂<DT><B>另请参见：</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory(java.util.concurrent.ThreadFactory)"><CODE>setThreadFactory(java.util.concurrent.ThreadFactory)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"><!-- --></A><H3>
setRejectedExecutionHandler</H3>
<PRE>
public void <B>setRejectedExecutionHandler</B>(<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口">RejectedExecutionHandler</A>&nbsp;handler)</PRE>
<DL>
<DD>设置用于未执行任务的新处理程序。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>handler</CODE> - 新处理程序
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果处理程序为 null<DT><B>另请参见：</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler()"><CODE>getRejectedExecutionHandler()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRejectedExecutionHandler()"><!-- --></A><H3>
getRejectedExecutionHandler</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 中的接口">RejectedExecutionHandler</A> <B>getRejectedExecutionHandler</B>()</PRE>
<DL>
<DD>返回用于未执行任务的当前处理程序。
<P>
<DD><DL>

<DT><B>返回：</B><DD>当前处理程序<DT><B>另请参见：</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"><CODE>setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCorePoolSize(int)"><!-- --></A><H3>
setCorePoolSize</H3>
<PRE>
public void <B>setCorePoolSize</B>(int&nbsp;corePoolSize)</PRE>
<DL>
<DD>设置核心线程数。此操作将重写构造方法中设置的任何值。如果新值小于当前值，则多余的现有线程将在下一次空闲时终止。如果较大，则在需要时启动新线程来执行这些排队的任务。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>corePoolSize</CODE> - 新核心大小
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>corePoolSize</tt> 小于 0<DT><B>另请参见：</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()"><CODE>getCorePoolSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCorePoolSize()"><!-- --></A><H3>
getCorePoolSize</H3>
<PRE>
public int <B>getCorePoolSize</B>()</PRE>
<DL>
<DD>返回核心线程数。
<P>
<DD><DL>

<DT><B>返回：</B><DD>核心线程数<DT><B>另请参见：</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)"><CODE>setCorePoolSize(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="prestartCoreThread()"><!-- --></A><H3>
prestartCoreThread</H3>
<PRE>
public boolean <B>prestartCoreThread</B>()</PRE>
<DL>
<DD>启动核心线程，使其处于等待工作的空闲状态。仅当执行新任务时，此操作才重写默认的启动核心线程策略。如果已启动所有核心线程，此方法将返回 <tt>false</tt>。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果启动了线程，则返回 true</DL>
</DD>
</DL>
<HR>

<A NAME="prestartAllCoreThreads()"><!-- --></A><H3>
prestartAllCoreThreads</H3>
<PRE>
public int <B>prestartAllCoreThreads</B>()</PRE>
<DL>
<DD>启动所有核心线程，使其处于等待工作的空闲状态。仅当执行新任务时，此操作才重写默认的启动核心线程策略。
<P>
<DD><DL>

<DT><B>返回：</B><DD>已启动的线程数</DL>
</DD>
</DL>
<HR>

<A NAME="allowsCoreThreadTimeOut()"><!-- --></A><H3>
allowsCoreThreadTimeOut</H3>
<PRE>
public boolean <B>allowsCoreThreadTimeOut</B>()</PRE>
<DL>
<DD>如果此池允许核心线程超时和终止，如果在 keepAlive 时间内没有任务到达，新任务到达时正在替换（如果需要），则返回 true。当返回 true 时，适用于非核心线程的相同的保持活动策略也同样适用于核心线程。当返回 false（默认值）时，由于没有传入任务，核心线程不会终止。
<P>
<DD><DL>

<DT><B>返回：</B><DD>如果允许核心线程超时，则返回 <tt>true</tt>；否则返回 <tt>false</tt><DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="allowCoreThreadTimeOut(boolean)"><!-- --></A><H3>
allowCoreThreadTimeOut</H3>
<PRE>
public void <B>allowCoreThreadTimeOut</B>(boolean&nbsp;value)</PRE>
<DL>
<DD>如果在保持活动时间内没有任务到达，新任务到达时正在替换（如果需要），则设置控制核心线程是超时还是终止的策略。当为 false（默认值）时，由于没有传入任务，核心线程将永远不会中止。当为 true 时，适用于非核心线程的相同的保持活动策略也同样适用于核心线程。为了避免连续线程替换，保持活动时间在设置为 <tt>true</tt> 时必须大于 0。通常应该在主动使用该池前调用此方法。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>value</CODE> - 如果应该超时，则为 <tt>true</tt>；否则为 <tt>false</tt>
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 value 为 <tt>true</tt> 并且当前保持活动时间不大于 0。<DT><B>从以下版本开始：</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMaximumPoolSize(int)"><!-- --></A><H3>
setMaximumPoolSize</H3>
<PRE>
public void <B>setMaximumPoolSize</B>(int&nbsp;maximumPoolSize)</PRE>
<DL>
<DD>设置允许的最大线程数。此操作将重写构造方法中设置的任何值。如果新值小于当前值，则多余的现有线程将在下一次空闲时终止。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>maximumPoolSize</CODE> - 新的最大值
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果新的最大值小于等于 0，或者小于<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()">核心池大小</A><DT><B>另请参见：</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()"><CODE>getMaximumPoolSize()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumPoolSize()"><!-- --></A><H3>
getMaximumPoolSize</H3>
<PRE>
public int <B>getMaximumPoolSize</B>()</PRE>
<DL>
<DD>返回允许的最大线程数。
<P>
<DD><DL>

<DT><B>返回：</B><DD>允许的最大线程数<DT><B>另请参见：</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)"><CODE>setMaximumPoolSize(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
setKeepAliveTime</H3>
<PRE>
public void <B>setKeepAliveTime</B>(long&nbsp;time,
                             <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit)</PRE>
<DL>
<DD>设置线程在终止前可以保持空闲的时间限制。如果池中的当前线程数多于核心线程数，在不处理任务的情况下等待这一时间段之后，多余的线程将被终止。此操作将重写构造方法中设置的任何值。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>time</CODE> - 等待的时间。时间值 0 将导致执行任务后多余的线程立即终止。<DD><CODE>unit</CODE> - 时间参数的时间单位
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果时间小于 0，或者时间为 0 和 allowsCoreThreadTimeOut<DT><B>另请参见：</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)"><CODE>getKeepAliveTime(java.util.concurrent.TimeUnit)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getKeepAliveTime(java.util.concurrent.TimeUnit)"><!-- --></A><H3>
getKeepAliveTime</H3>
<PRE>
public long <B>getKeepAliveTime</B>(<A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 中的枚举">TimeUnit</A>&nbsp;unit)</PRE>
<DL>
<DD>返回线程保持活动的时间，该时间就是超过核心池大小的线程可以在终止前保持空闲的时间值。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>unit</CODE> - 所需的结果时间单位
<DT><B>返回：</B><DD>时间限制<DT><B>另请参见：</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><CODE>setKeepAliveTime(long, java.util.concurrent.TimeUnit)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getQueue()"><!-- --></A><H3>
getQueue</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 中的接口">BlockingQueue</A>&lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&gt; <B>getQueue</B>()</PRE>
<DL>
<DD>返回此执行程序使用的任务队列。对任务队列的访问主要用于调试和监控。此队列可能正处于活动使用状态中。获取任务队列不妨碍已加入队列的任务的执行。
<P>
<DD><DL>

<DT><B>返回：</B><DD>任务队列</DL>
</DD>
</DL>
<HR>

<A NAME="remove(java.lang.Runnable)"><!-- --></A><H3>
remove</H3>
<PRE>
public boolean <B>remove</B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;task)</PRE>
<DL>
<DD>从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。

<p> 此方法可用作取消方案的一部分。它可能无法移除在放置到内部队列之前已经转换为其他形式的任务。例如，使用 <tt>submit</tt> 输入的任务可能被转换为维护 <tt>Future</tt> 状态的形式。但是，在此情况下，<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()"><CODE>purge()</CODE></A> 方法可用于移除那些已被取消的 Future。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>task</CODE> - 要移除的任务
<DT><B>返回：</B><DD>如果已经移除任务，则返回 true</DL>
</DD>
</DL>
<HR>

<A NAME="purge()"><!-- --></A><H3>
purge</H3>
<PRE>
public void <B>purge</B>()</PRE>
<DL>
<DD>尝试从工作队列移除所有已取消的 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 中的接口"><CODE>Future</CODE></A> 任务。此方法可用作存储回收操作，它对功能没有任何影响。取消的任务不会再次执行，但是它们可能在工作队列中累积，直到 worker 线程主动将其移除。调用此方法将试图立即移除它们。但是，如果出现其他线程的干预，那么此方法移除任务将失败。
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPoolSize()"><!-- --></A><H3>
getPoolSize</H3>
<PRE>
public int <B>getPoolSize</B>()</PRE>
<DL>
<DD>返回池中的当前线程数。
<P>
<DD><DL>

<DT><B>返回：</B><DD>线程数。</DL>
</DD>
</DL>
<HR>

<A NAME="getActiveCount()"><!-- --></A><H3>
getActiveCount</H3>
<PRE>
public int <B>getActiveCount</B>()</PRE>
<DL>
<DD>返回主动执行任务的近似线程数。
<P>
<DD><DL>

<DT><B>返回：</B><DD>线程数。</DL>
</DD>
</DL>
<HR>

<A NAME="getLargestPoolSize()"><!-- --></A><H3>
getLargestPoolSize</H3>
<PRE>
public int <B>getLargestPoolSize</B>()</PRE>
<DL>
<DD>返回曾经同时位于池中的最大线程数。
<P>
<DD><DL>

<DT><B>返回：</B><DD>线程数。</DL>
</DD>
</DL>
<HR>

<A NAME="getTaskCount()"><!-- --></A><H3>
getTaskCount</H3>
<PRE>
public long <B>getTaskCount</B>()</PRE>
<DL>
<DD>返回曾计划执行的近似任务总数。因为在计算期间任务和线程的状态可能动态改变，所以返回值只是一个近似值。
<P>
<DD><DL>

<DT><B>返回：</B><DD>任务数</DL>
</DD>
</DL>
<HR>

<A NAME="getCompletedTaskCount()"><!-- --></A><H3>
getCompletedTaskCount</H3>
<PRE>
public long <B>getCompletedTaskCount</B>()</PRE>
<DL>
<DD>返回已完成执行的近似任务总数。因为在计算期间任务和线程的状态可能动态改变，所以返回值只是一个近似值，但是该值在整个连续调用过程中不会减少。
<P>
<DD><DL>

<DT><B>返回：</B><DD>任务数。</DL>
</DD>
</DL>
<HR>

<A NAME="beforeExecute(java.lang.Thread, java.lang.Runnable)"><!-- --></A><H3>
beforeExecute</H3>
<PRE>
protected void <B>beforeExecute</B>(<A HREF="../../../java/lang/Thread.html" title="java.lang 中的类">Thread</A>&nbsp;t,
                             <A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;r)</PRE>
<DL>
<DD>在执行给定线程中的给定 Runnable 之前调用的方法。此方法由将执行任务 <tt>r</tt> 的线程 <tt>t</tt> 调用，并且可用于重新初始化 ThreadLocals 或者执行日志记录。

<p>此实现不执行任何操作，但可在子类中定制。注：为了正确嵌套多个重写操作，此方法结束时，子类通常应该调用 <tt>super.beforeExecute</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>t</CODE> - 将运行任务 r 的线程。<DD><CODE>r</CODE> - 将执行的任务。</DL>
</DD>
</DL>
<HR>

<A NAME="afterExecute(java.lang.Runnable, java.lang.Throwable)"><!-- --></A><H3>
afterExecute</H3>
<PRE>
protected void <B>afterExecute</B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 中的接口">Runnable</A>&nbsp;r,
                            <A HREF="../../../java/lang/Throwable.html" title="java.lang 中的类">Throwable</A>&nbsp;t)</PRE>
<DL>
<DD>基于完成执行给定 Runnable 所调用的方法。此方法由执行任务的线程调用。如果非 null，则 Throwable 是导致执行突然终止的未捕获 <tt>RuntimeException</tt> 或 <tt>Error</tt>。

<p><b>注：</b>当操作显示地或者通过 <tt>submit</tt> 之类的方法包含在任务内时（如 <A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 中的类"><CODE>FutureTask</CODE></A>），这些任务对象捕获和维护计算异常，因此它们不会导致突然终止，内部异常<em>不会</em> 传递给此方法。 

<p>此实现不执行任何操作，但可在子类中定制。注：为了正确嵌套多个重写操作，此方法开始时，子类通常应该调用 <tt>super.afterExecute</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>r</CODE> - 已经完成的 runnable 线程。<DD><CODE>t</CODE> - 导致终止的异常；如果执行正常结束，则为 null。</DL>
</DD>
</DL>
<HR>

<A NAME="terminated()"><!-- --></A><H3>
terminated</H3>
<PRE>
protected void <B>terminated</B>()</PRE>
<DL>
<DD>当 Executor 已经终止时调用的方法。默认实现不执行任何操作。注：为了正确嵌套多个重写操作，子类通常应该在此方法中调用 <tt>super.afterExecute</tt>。
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ThreadPoolExecutor.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 中的接口"><B>上一个类</B></A>&nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/ThreadPoolExecutor.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="ThreadPoolExecutor.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;<A HREF="#nested_class_summary">嵌套</A>&nbsp;|&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;字段&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
