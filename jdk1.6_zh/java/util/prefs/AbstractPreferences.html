<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-beta2) on Fri Mar 09 12:53:30 CST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=gb2312">
<TITLE>
AbstractPreferences (Java 2 Platform SE 6)
</TITLE>

<META NAME="keywords" CONTENT="概述, Java<sup><font size=-2>TM</font></sup> 2 Platform Standard Edition 6<br>API 开发人员文档">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AbstractPreferences (Java 2 Platform SE 6)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractPreferences.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;上一个类&nbsp;
&nbsp;<A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/prefs/AbstractPreferences.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="AbstractPreferences.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.prefs</FONT>
<BR>
类 AbstractPreferences</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="继承者 "><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">java.util.prefs.Preferences</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="继承者 "><B>java.util.prefs.AbstractPreferences</B>
</PRE>
<HR>
<DL>
<DT><PRE>public abstract class <B>AbstractPreferences</B><DT>extends <A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></DL>
</PRE>

<P>
此类提供了 <A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类"><CODE>Preferences</CODE></A> 类的骨干实现，从而大大简化了实现此类的任务。

<p><strong>此类仅供 <tt>Preferences</tt> 实现者使用。<tt>Preferences</tt> 设施的普通用户无需参考此文档。<A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类"><CODE>Preferences</CODE></A> 文档已经足够了。</strong>

<p>实现者必须重写九个抽象服务提供者接口 (SPI) 方法：<A HREF="../../../java/util/prefs/AbstractPreferences.html#getSpi(java.lang.String)"><CODE>getSpi(String)</CODE></A>、<A HREF="../../../java/util/prefs/AbstractPreferences.html#putSpi(java.lang.String, java.lang.String)"><CODE>putSpi(String,String)</CODE></A>、<A HREF="../../../java/util/prefs/AbstractPreferences.html#removeSpi(java.lang.String)"><CODE>removeSpi(String)</CODE></A>、<A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A>、<A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNodeSpi()"><CODE>removeNodeSpi()</CODE></A>、<A HREF="../../../java/util/prefs/AbstractPreferences.html#keysSpi()"><CODE>keysSpi()</CODE></A>、<A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNamesSpi()"><CODE>childrenNamesSpi()</CODE></A>、<A HREF="../../../java/util/prefs/AbstractPreferences.html#syncSpi()"><CODE>syncSpi()</CODE></A> 和 <A HREF="../../../java/util/prefs/AbstractPreferences.html#flushSpi()"><CODE>flushSpi()</CODE></A>。所有的具体方法都精确指定它们如何在这些 SPI 方法上实现。如果出于某种考虑（如性能）对默认实现不满意，则实现者可能决定重写一个或多个具体方法。

<p>SPI 方法按异常行为可分为三个组。<tt>getSpi</tt> 方法应该永远不抛出异常，但是对性能丝毫不会产生影响，因为 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE>get(String,String)</CODE></A> 会拦截此方法所抛出的任何异常，并对调用者返回指定的默认值。<tt>removeNodeSpi、keysSpi、childrenNamesSpi、syncSpi</tt> 和 <tt>flushSpi</tt> 方法被指定抛出 <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类"><CODE>BackingStoreException</CODE></A>；如果实现无法执行操作，则需要抛出此经过检查的异常。该异常向外传播，导致相应的 API 方法失败。

<p>其余的 SPI 方法 <A HREF="../../../java/util/prefs/AbstractPreferences.html#putSpi(java.lang.String, java.lang.String)"><CODE>putSpi(String,String)</CODE></A>、<A HREF="../../../java/util/prefs/AbstractPreferences.html#removeSpi(java.lang.String)"><CODE>removeSpi(String)</CODE></A> 和 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A> 具有更加复杂的异常行为。未指定它们抛出 <tt>BackingStoreException</tt>，因为即使内部存储不可用，它们通常也遵守其协定。之所以这样是因为它们不返回任何信息，并且在进行对 <A HREF="../../../java/util/prefs/Preferences.html#flush()"><CODE>Preferences.flush()</CODE></A> 或 <A HREF="../../../java/util/prefs/Preferences.html#sync()"><CODE>Preferences.sync()</CODE></A> 的后续调用之前，不要求其结果是持久的。一般而言，这些 SPI 方法不应抛出异常。在某些实现中，可能存在这些调用甚至无法对后续处理的请求操作进行排队的情形。即使在这些情形下，最好的做法也是忽略该调用并返回，而不是抛出异常。但是，在这些情形下，所有 <tt>flush()</tt> 和 <tt>sync</tt> 的后续调用应该返回 <tt>false</tt>，因为返回 <tt>true</tt> 意味着以前的所有操作都已成功地成为持久性操作。

<p>有一种情况下 <tt>putSpi、removeSpi 和 childSpi</tt> <i>应该</i> 抛出异常：如果调用者在底层操作系统上不具备执行请求操作的足够权限。例如，如果非特权用户尝试修改系统首选项，则在大多数系统上都会发生这种情况。（这要求特权随实现而变化。在有些实现中，需要修改文件系统中某些目录内容的特权；而在另外一些实现中，则需要修改注册表中某些键的内容。）在上述任何情形下，通常让程序继续执行并不合乎需要，就好像这些操作在以后会成为持久操作一样。虽然在这些情形下不要求实现抛出异常，但还是鼓励这样做。<A HREF="../../../java/lang/SecurityException.html" title="java.lang 中的类"><CODE>SecurityException</CODE></A> 就是合适的选择。

<p>大多数 SPI 方法都要求实现在首选项节点上读取或写入信息。实现者需要注意一种情况，即另一个 VM 当前可能已经从内部存储删除了此节点。如果该节点已经删除了，则实现有责任重新创建它。

<p>实现注意事项：在 Sun 的默认 <tt>Preferences</tt> 实现中，用户的身份是从底层操作系统继承的，在虚拟机的生命周期中不能更改。在服务器端的 <tt>Preferences</tt> 实现中，用户身份可以随请求而更改，并通过使用静态 <A HREF="../../../java/lang/ThreadLocal.html" title="java.lang 中的类"><CODE>ThreadLocal</CODE></A> 实例隐式传递给 <tt>Preferences</tt> 方法。<i>大力</i> 提倡这种实现的设计者在访问首选项时确定用户（例如，使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE>get(String,String)</CODE></A> 或 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String,String)</CODE></A> 方法），而不是将用户与每个 <tt>Preferences</tt> 实例永久关联。后一种行为与通常的 <tt>Preferences</tt> 用法有冲突，将带来很大的混乱。
<P>

<P>
<DL>
<DT><B>从以下版本开始：</B></DT>
  <DD>1.4</DD>
<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类"><CODE>Preferences</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>字段摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#lock">lock</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用其监视器锁定此节点的对象。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#newNode">newNode</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在创建此对象前内部存储中不存在此节点，则该字段为 <tt>true</tt>。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.util.prefs.Preferences"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.util.prefs.<A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A> 继承的字段</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/util/prefs/Preferences.html#MAX_KEY_LENGTH">MAX_KEY_LENGTH</A>, <A HREF="../../../java/util/prefs/Preferences.html#MAX_NAME_LENGTH">MAX_NAME_LENGTH</A>, <A HREF="../../../java/util/prefs/Preferences.html#MAX_VALUE_LENGTH">MAX_VALUE_LENGTH</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>构造方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#AbstractPreferences(java.util.prefs.AbstractPreferences, java.lang.String)">AbstractPreferences</A></B>(<A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 中的类">AbstractPreferences</A>&nbsp;parent,
                    <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用指定的父节点和与其父节点相关的指定名称创建首选项节点。</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>方法摘要</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#absolutePath()">absolutePath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#absolutePath()"><CODE>Preferences.absolutePath()</CODE></A> 中的规范实现 <tt>absolutePath</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#addNodeChangeListener(java.util.prefs.NodeChangeListener)">addNodeChangeListener</A></B>(<A HREF="../../../java/util/prefs/NodeChangeListener.html" title="java.util.prefs 中的接口">NodeChangeListener</A>&nbsp;ncl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册指定侦听器以接收此节点的<i>节点更改事件</i>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">addPreferenceChangeListener</A></B>(<A HREF="../../../java/util/prefs/PreferenceChangeListener.html" title="java.util.prefs 中的接口">PreferenceChangeListener</A>&nbsp;pcl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册指定侦听器以接收此首选项节点的<i>首选项更改事件</i>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 中的类">AbstractPreferences</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#cachedChildren()">cachedChildren</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此节点的所有已知未移除子节点。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNames()">childrenNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#childrenNames()"><CODE>Preferences.childrenNames()</CODE></A> 中的规范实现 <tt>children</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNamesSpi()">childrenNamesSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此首选项节点的子节点名称。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 中的类">AbstractPreferences</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)">childSpi</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此首选项节点的指定子节点；如果该子节点尚未存在，则创建它。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#clear()"><CODE>Preferences.clear()</CODE></A> 中的规范实现 <tt>clear</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#exportNode(java.io.OutputStream)">exportNode</A></B>(<A HREF="../../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A>&nbsp;os)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#exportNode(java.io.OutputStream)"><CODE>Preferences.exportNode(OutputStream)</CODE></A> 中的规范实现 <tt>exportNode</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#exportSubtree(java.io.OutputStream)">exportSubtree</A></B>(<A HREF="../../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A>&nbsp;os)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#exportSubtree(java.io.OutputStream)"><CODE>Preferences.exportSubtree(OutputStream)</CODE></A> 中的规范实现 <tt>exportSubtree</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#flush()">flush</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#flush()"><CODE>Preferences.flush()</CODE></A> 中的规范实现 <tt>flush</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#flushSpi()">flushSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方法是在此节点被锁定的情况下调用的。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)">get</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
    <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String,String)</CODE></A> 中的规范实现 <tt>get</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getBoolean(java.lang.String, boolean)">getBoolean</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
           boolean&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#getBoolean(java.lang.String, boolean)"><CODE>Preferences.getBoolean(String,boolean)</CODE></A> 中的规范实现 <tt>getBoolean</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getByteArray(java.lang.String, byte[])">getByteArray</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
             byte[]&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#getByteArray(java.lang.String, byte[])"><CODE>Preferences.getByteArray(String,byte[])</CODE></A> 中的规范实现 <tt>getByteArray</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 中的类">AbstractPreferences</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getChild(java.lang.String)">getChild</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;nodeName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果指定的子节点存在，则返回该子节点；如果它不存在，则返回 <tt>null</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getDouble(java.lang.String, double)">getDouble</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
          double&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#getDouble(java.lang.String, double)"><CODE>Preferences.getDouble(String,double)</CODE></A> 中的规范实现 <tt>getDouble</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getFloat(java.lang.String, float)">getFloat</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
         float&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#getFloat(java.lang.String, float)"><CODE>Preferences.getFloat(String,float)</CODE></A> 中的规范实现 <tt>getFloat</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getInt(java.lang.String, int)">getInt</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
       int&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#getInt(java.lang.String, int)"><CODE>Preferences.getInt(String,int)</CODE></A> 中的规范实现 <tt>getInt</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getLong(java.lang.String, long)">getLong</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
        long&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#getLong(java.lang.String, long)"><CODE>Preferences.getLong(String,long)</CODE></A> 中的规范实现 <tt>getLong</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getSpi(java.lang.String)">getSpi</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回与此首选项节点上的指定键相关联的值；如果不存在此键的关联值或此时无法确定该关联值，则返回 <tt>null</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#isRemoved()">isRemoved</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除此节点（或其祖先）时才返回 <tt>true</tt>。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#isUserNode()">isUserNode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#isUserNode()"><CODE>Preferences.isUserNode()</CODE></A> 中的规范实现 <tt>isUserNode</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#keys()">keys</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#keys()"><CODE>Preferences.keys()</CODE></A> 中的规范实现 <tt>keys</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#keysSpi()">keysSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回在此首选项节点中具有关联值的所有键。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#name()">name</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#name()"><CODE>Preferences.name()</CODE></A> 中的规范实现 <tt>name</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#node(java.lang.String)">node</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#node(java.lang.String)"><CODE>Preferences.node(String)</CODE></A> 中的规范实现 <tt>node</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#nodeExists(java.lang.String)">nodeExists</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#nodeExists(java.lang.String)"><CODE>Preferences.nodeExists(String)</CODE></A> 中的规范实现 <tt>nodeExists</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#parent()">parent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#parent()"><CODE>Preferences.parent()</CODE></A> 中的规范实现 <tt>parent</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)">put</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
    <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#put(java.lang.String, java.lang.String)"><CODE>Preferences.put(String,String)</CODE></A> 中的规范实现 <tt>put</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putBoolean(java.lang.String, boolean)">putBoolean</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
           boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#putBoolean(java.lang.String, boolean)"><CODE>Preferences.putBoolean(String,boolean)</CODE></A> 中的规范实现 <tt>putBoolean</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putByteArray(java.lang.String, byte[])">putByteArray</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
             byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#putByteArray(java.lang.String, byte[])"><CODE>Preferences.putByteArray(String,byte[])</CODE></A> 中的规范实现 <tt>putByteArray</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putDouble(java.lang.String, double)">putDouble</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
          double&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#putDouble(java.lang.String, double)"><CODE>Preferences.putDouble(String,double)</CODE></A> 中的规范实现 <tt>putDouble</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putFloat(java.lang.String, float)">putFloat</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
         float&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#putFloat(java.lang.String, float)"><CODE>Preferences.putFloat(String,float)</CODE></A> 中的规范实现 <tt>putFloat</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putInt(java.lang.String, int)">putInt</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
       int&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#putInt(java.lang.String, int)"><CODE>Preferences.putInt(String,int)</CODE></A> 中的规范实现 <tt>putInt</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putLong(java.lang.String, long)">putLong</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
        long&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#putLong(java.lang.String, long)"><CODE>Preferences.putLong(String,long)</CODE></A> 中的规范实现 <tt>putLong</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putSpi(java.lang.String, java.lang.String)">putSpi</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
       <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将给定的键-值关联置于此首选项节点中。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#remove(java.lang.String)">remove</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#remove(java.lang.String)"><CODE>Preferences.remove(String)</CODE></A> 中的规范实现 <tt>remove(String)</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()">removeNode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A> 中的规范实现 <tt>removeNode()</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNodeChangeListener(java.util.prefs.NodeChangeListener)">removeNodeChangeListener</A></B>(<A HREF="../../../java/util/prefs/NodeChangeListener.html" title="java.util.prefs 中的接口">NodeChangeListener</A>&nbsp;ncl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移除指定 <tt>NodeChangeListener</tt>，使其不再接收更改事件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNodeSpi()">removeNodeSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移除此首选项节点，该首选项节点及其所包含的所有首选项都将失效。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">removePreferenceChangeListener</A></B>(<A HREF="../../../java/util/prefs/PreferenceChangeListener.html" title="java.util.prefs 中的接口">PreferenceChangeListener</A>&nbsp;pcl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移除指定首选项更改侦听器，使其不再接收首选项更改事件。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#removeSpi(java.lang.String)">removeSpi</A></B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移除此首选项节点上指定键的关联值（如果有）。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#sync()">sync</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 <A HREF="../../../java/util/prefs/Preferences.html#sync()"><CODE>Preferences.sync()</CODE></A> 中的规范实现 <tt>sync</tt> 方法。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#syncSpi()">syncSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方法是在此节点被锁定的情况下调用的。</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回此首选项节点的绝对路径名称。</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.prefs.Preferences"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.util.prefs.<A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/util/prefs/Preferences.html#importPreferences(java.io.InputStream)">importPreferences</A>, <A HREF="../../../java/util/prefs/Preferences.html#systemNodeForPackage(java.lang.Class)">systemNodeForPackage</A>, <A HREF="../../../java/util/prefs/Preferences.html#systemRoot()">systemRoot</A>, <A HREF="../../../java/util/prefs/Preferences.html#userNodeForPackage(java.lang.Class)">userNodeForPackage</A>, <A HREF="../../../java/util/prefs/Preferences.html#userRoot()">userRoot</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>从类 java.lang.<A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A> 继承的方法</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>, <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../java/lang/Object.html#finalize()">finalize</A>, <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>字段详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="newNode"><!-- --></A><H3>
newNode</H3>
<PRE>
protected boolean <B>newNode</B></PRE>
<DL>
<DD>如果在创建此对象前内部存储中不存在此节点，则该字段为 <tt>true</tt>。该字段被初始化为 false，但是子类构造方法可以将其设置为 true（并且以后不应再修改）。此字段指示创建完成时是否激活节点更改事件。
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="lock"><!-- --></A><H3>
lock</H3>
<PRE>
protected final <A HREF="../../../java/lang/Object.html" title="java.lang 中的类">Object</A> <B>lock</B></PRE>
<DL>
<DD>使用其监视器锁定此节点的对象。使用此对象（优先于节点本身）来减少由于锁定节点而有意或无意拒绝服务的可能性。为了避免死锁，<i>永远</i> 不要让保持该节点后代上的锁定的线程锁定节点。
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>构造方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AbstractPreferences(java.util.prefs.AbstractPreferences, java.lang.String)"><!-- --></A><H3>
AbstractPreferences</H3>
<PRE>
protected <B>AbstractPreferences</B>(<A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 中的类">AbstractPreferences</A>&nbsp;parent,
                              <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>用指定的父节点和与其父节点相关的指定名称创建首选项节点。
<P>
<DL>
<DT><B>参数：</B><DD><CODE>parent</CODE> - 此首选项节点的父节点；如果此首选项是根，则为 null。<DD><CODE>name</CODE> - 此首选项节点相对于其父节点的名称，如果此首选项是根，则为 <tt>""</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>name</tt> 包含一个斜杠 (<tt>'/'</tt>) 或者 <tt>parent</tt> 为 <tt>null</tt> 且名称不是 <tt>""</tt>。</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>方法详细信息</B></FONT></TH>
</TR>
</TABLE>

<A NAME="put(java.lang.String, java.lang.String)"><!-- --></A><H3>
put</H3>
<PRE>
public void <B>put</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;value)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#put(java.lang.String, java.lang.String)"><CODE>Preferences.put(String,String)</CODE></A> 中的规范实现 <tt>put</tt> 方法。

<p>此实现检查键和值是否合法，获取此首选项节点的锁定，检查该节点是否未被移除，调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#putSpi(java.lang.String, java.lang.String)"><CODE>putSpi(String,String)</CODE></A>，并且如果存在首选项更改侦听器，则将由事件指派线程所处理的通知事件加入队列。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#put(java.lang.String, java.lang.String)">put</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 指定的 value 将要关联的键。<DD><CODE>value</CODE> - 指定的 key 将要关联的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 key 或 value 为 <tt>null</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>key.length()</tt> 超过 <tt>MAX_KEY_LENGTH</tt>，或者 <tt>value.length</tt> 超过 <tt>MAX_VALUE_LENGTH</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。</DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.String, java.lang.String)"><!-- --></A><H3>
get</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A> <B>get</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                  <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;def)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String,String)</CODE></A> 中的规范实现 <tt>get</tt> 方法。

<p>此实现首先检查 <tt>key</tt> 是否为 <tt>null</tt>；如果是，则抛出 <tt>NullPointerException</tt>。然后，它获取此首选项节点的锁，检查该节点是否未被移除，调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#getSpi(java.lang.String)"><CODE>getSpi(String)</CODE></A> 并返回结果，除非 <tt>getSpi</tt> 调用返回 <tt>null</tt> 或抛出异常，在这种情况下此调用返回 <tt>def</tt>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)">get</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要返回其关联值的键。<DD><CODE>def</CODE> - 此首选项节点不具有与 <tt>key</tt> 相关联的值时所要返回的值。
<DT><B>返回：</B><DD>与 <tt>key</tt> 相关联的值；如果没有与 <tt>key</tt> 相关联的值，则返回 <tt>def</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 key 为 <tt>null</tt>。（默认值 <tt>null</tt> <i>是</i> 允许的。）</DL>
</DD>
</DL>
<HR>

<A NAME="remove(java.lang.String)"><!-- --></A><H3>
remove</H3>
<PRE>
public void <B>remove</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#remove(java.lang.String)"><CODE>Preferences.remove(String)</CODE></A> 中的规范实现 <tt>remove(String)</tt> 方法。

<p>此实现获取首选项节点的锁，检查该节点是否未被移除，调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeSpi(java.lang.String)"><CODE>removeSpi(String)</CODE></A>，并且如果存在首选项更改侦听器，则将由事件指派线程所处理的通知事件加入队列。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#remove(java.lang.String)">remove</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 从首选项节点中移除其映射关系的键。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。</DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>()
           throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#clear()"><CODE>Preferences.clear()</CODE></A> 中的规范实现 <tt>clear</tt> 方法。

<p>此实现获取首选项节点的锁，调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#keys()"><CODE>keys()</CODE></A> 以获取键的数组，并且对每个键调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#remove(java.lang.String)"><CODE>remove(String)</CODE></A>，从而在数组上进行迭代。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#clear()">clear</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="putInt(java.lang.String, int)"><!-- --></A><H3>
putInt</H3>
<PRE>
public void <B>putInt</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                   int&nbsp;value)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#putInt(java.lang.String, int)"><CODE>Preferences.putInt(String,int)</CODE></A> 中的规范实现 <tt>putInt</tt> 方法。

<p>此实现使用 <A HREF="../../../java/lang/Integer.html#toString(int)"><CODE>Integer.toString(int)</CODE></A> 将 <tt>value</tt> 转换为一个字符串，并在结果上调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String,String)</CODE></A>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putInt(java.lang.String, int)">putInt</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要与字符串形式的 value 相关联的键。<DD><CODE>value</CODE> - 要与 key 相关联的字符串形式的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 key 为 <tt>null</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>key.length()</tt> 超过 <tt>MAX_KEY_LENGTH</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getInt(java.lang.String, int)"><CODE>Preferences.getInt(String,int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getInt(java.lang.String, int)"><!-- --></A><H3>
getInt</H3>
<PRE>
public int <B>getInt</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                  int&nbsp;def)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#getInt(java.lang.String, int)"><CODE>Preferences.getInt(String,int)</CODE></A> 中的规范实现 <tt>getInt</tt> 方法。

<p>此实现调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>。如果返回值为非 null，则实现尝试使用 <A HREF="../../../java/lang/Integer.html#parseInt(java.lang.String)"><CODE>Integer.parseInt(String)</CODE></A> 将其转换为 <tt>int</tt>。如果尝试成功，则此方法返回得到的值。否则返回 <tt>def</tt>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getInt(java.lang.String, int)">getInt</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要作为 int 返回其关联值的键。<DD><CODE>def</CODE> - 此首选项节点不具有与 <tt>key</tt> 相关联的值或无法将该关联值解释为 int 时要返回的值。
<DT><B>返回：</B><DD>与此首选项节点的 <tt>key</tt> 相关联的字符串所表示的 int 值；如果该关联值不存在或无法被解释为 int，则返回 <tt>def</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>key</tt> 为 <tt>null</tt>。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#putInt(java.lang.String, int)"><CODE>Preferences.putInt(String,int)</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String,String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="putLong(java.lang.String, long)"><!-- --></A><H3>
putLong</H3>
<PRE>
public void <B>putLong</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                    long&nbsp;value)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#putLong(java.lang.String, long)"><CODE>Preferences.putLong(String,long)</CODE></A> 中的规范实现 <tt>putLong</tt> 方法。

<p>此实现使用 <A HREF="../../../java/lang/Long.html#toString(long)"><CODE>Long.toString(long)</CODE></A> 将 <tt>value</tt> 转换为字符串，并在结果上调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String,String)</CODE></A>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putLong(java.lang.String, long)">putLong</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要与字符串形式的 value 相关联的键。<DD><CODE>value</CODE> - 要与 key 相关联的字符串形式的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 key 为 <tt>null</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>key.length()</tt> 超过 <tt>MAX_KEY_LENGTH</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getLong(java.lang.String, long)"><CODE>Preferences.getLong(String,long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLong(java.lang.String, long)"><!-- --></A><H3>
getLong</H3>
<PRE>
public long <B>getLong</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                    long&nbsp;def)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#getLong(java.lang.String, long)"><CODE>Preferences.getLong(String,long)</CODE></A> 中的规范实现 <tt>getLong</tt> 方法。

<p>此实现调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>。如果返回值为非 null，则实现尝试尝试使用 <A HREF="../../../java/lang/Long.html#parseLong(java.lang.String)"><CODE>Long.parseLong(String)</CODE></A> 将其转换为 <tt>long</tt>。如果尝试成功，则此方法返回得到的值。否则返回 <tt>def</tt>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getLong(java.lang.String, long)">getLong</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要作为 long 返回其关联值的键。<DD><CODE>def</CODE> - 此首选项节点不具有与 <tt>key</tt> 相关联的值或者无法将该关联值解释为 long 时要返回的值。
<DT><B>返回：</B><DD>由与此首选项节点的 <tt>key</tt> 相关联的字符串所表示的 long 值；如果该关联值不存在或无法被解释为 long，则返回 <tt>def</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除此节点（或其祖先）。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>key</tt> 为 <tt>null</tt>。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#putLong(java.lang.String, long)"><CODE>Preferences.putLong(String,long)</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String,String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="putBoolean(java.lang.String, boolean)"><!-- --></A><H3>
putBoolean</H3>
<PRE>
public void <B>putBoolean</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                       boolean&nbsp;value)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#putBoolean(java.lang.String, boolean)"><CODE>Preferences.putBoolean(String,boolean)</CODE></A> 中的规范实现 <tt>putBoolean</tt> 方法。

<p>此实现使用 <A HREF="../../../java/lang/String.html#valueOf(boolean)"><CODE>String.valueOf(boolean)</CODE></A> 将 <tt>value</tt> 转换为字符串，并在结果上调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String,String)</CODE></A>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putBoolean(java.lang.String, boolean)">putBoolean</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要与字符串形式的 value 相关联的键。<DD><CODE>value</CODE> - 要与 key 相关联的字符串形式的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 key 为 <tt>null</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>key.length()</tt> 超过 <tt>MAX_KEY_LENGTH</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getBoolean(java.lang.String, boolean)"><CODE>Preferences.getBoolean(String,boolean)</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String,String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBoolean(java.lang.String, boolean)"><!-- --></A><H3>
getBoolean</H3>
<PRE>
public boolean <B>getBoolean</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                          boolean&nbsp;def)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#getBoolean(java.lang.String, boolean)"><CODE>Preferences.getBoolean(String,boolean)</CODE></A> 中的规范实现 <tt>getBoolean</tt> 方法。

<p>此实现调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>。如果返回值为非 null，则使用 <A HREF="../../../java/lang/String.html#equalsIgnoreCase(java.lang.String)"><CODE>String.equalsIgnoreCase(String)</CODE></A> 将其与 <tt>"true"</tt> 相比较。如果比较返回 <tt>true</tt>，则此调用返回 <tt>true</tt>。否则，再次使用 <A HREF="../../../java/lang/String.html#equalsIgnoreCase(java.lang.String)"><CODE>String.equalsIgnoreCase(String)</CODE></A> 将初始值与 <tt>"false"</tt> 相比较。如果比较返回 <tt>true</tt>，则此调用返回 <tt>false</tt>。否则此调用返回 <tt>def</tt>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getBoolean(java.lang.String, boolean)">getBoolean</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要作为 boolean 返回其关联值的键。<DD><CODE>def</CODE> - 此首选项节点不具有与 <tt>key</tt> 相关联的值或无法将该关联值解释为 boolean 时要返回的值。
<DT><B>返回：</B><DD>与此首选项节点的 <tt>key</tt> 相关联的字符串所表示的 boolean 值；如果该关联值不存在或无法被解释为 boolean，则返回 <tt>def</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>key</tt> 为 <tt>null</tt>。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String,String)</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#putBoolean(java.lang.String, boolean)"><CODE>Preferences.putBoolean(String,boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="putFloat(java.lang.String, float)"><!-- --></A><H3>
putFloat</H3>
<PRE>
public void <B>putFloat</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                     float&nbsp;value)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#putFloat(java.lang.String, float)"><CODE>Preferences.putFloat(String,float)</CODE></A> 中的规范实现 <tt>putFloat</tt> 方法。

<p>此实现使用 <A HREF="../../../java/lang/Float.html#toString(float)"><CODE>Float.toString(float)</CODE></A> 将 <tt>value</tt> 转换为字符串，并在结果上调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String,String)</CODE></A>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putFloat(java.lang.String, float)">putFloat</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要与字符串形式的 value 相关联的键。<DD><CODE>value</CODE> - 要与 key 相关联的字符串形式的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 key 为 <tt>null</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>key.length()</tt> 超过 <tt>MAX_KEY_LENGTH</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getFloat(java.lang.String, float)"><CODE>Preferences.getFloat(String,float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFloat(java.lang.String, float)"><!-- --></A><H3>
getFloat</H3>
<PRE>
public float <B>getFloat</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                      float&nbsp;def)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#getFloat(java.lang.String, float)"><CODE>Preferences.getFloat(String,float)</CODE></A> 中的规范实现 <tt>getFloat</tt> 方法。

<p>此实现调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>。如果返回值为非 null，则实现尝试使用 <A HREF="../../../java/lang/Float.html#parseFloat(java.lang.String)"><CODE>Float.parseFloat(String)</CODE></A> 将其转换为 <tt>float</tt>。如果尝试成功，则此方法返回得到的值。否则返回 <tt>def</tt>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getFloat(java.lang.String, float)">getFloat</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要作为 float 返回其关联值的键。<DD><CODE>def</CODE> - 此首选项节点不具有与 <tt>key</tt> 相关联的值或无法将该关联值解释为 float 时要返回的值。
<DT><B>返回：</B><DD>与此首选项节点的 <tt>key</tt> 相关联的字符串所表示的 float 值；如果该关联值不存在或无法被解释为 float，则返回 <tt>def</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>key</tt> 为 <tt>null</tt>。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#putFloat(java.lang.String, float)"><CODE>Preferences.putFloat(String,float)</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String,String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="putDouble(java.lang.String, double)"><!-- --></A><H3>
putDouble</H3>
<PRE>
public void <B>putDouble</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                      double&nbsp;value)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#putDouble(java.lang.String, double)"><CODE>Preferences.putDouble(String,double)</CODE></A> 中的规范实现 <tt>putDouble</tt> 方法。

<p>此实现使用 <A HREF="../../../java/lang/Double.html#toString(double)"><CODE>Double.toString(double)</CODE></A> 将 <tt>value</tt> 转换为字符串，并在结果上调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String,String)</CODE></A>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putDouble(java.lang.String, double)">putDouble</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要与字符串形式的 value 相关联的键。<DD><CODE>value</CODE> - 要与 key 相关联的字符串形式的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 key 为 <tt>null</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 <tt>key.length()</tt> 超过 <tt>MAX_KEY_LENGTH</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getDouble(java.lang.String, double)"><CODE>Preferences.getDouble(String,double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDouble(java.lang.String, double)"><!-- --></A><H3>
getDouble</H3>
<PRE>
public double <B>getDouble</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                        double&nbsp;def)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#getDouble(java.lang.String, double)"><CODE>Preferences.getDouble(String,double)</CODE></A> 中的规范实现 <tt>getDouble</tt> 方法。

<p>此实现调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>。如果返回值为非 null，则实现尝试使用 <A HREF="../../../java/lang/Double.html#parseDouble(java.lang.String)"><CODE>Double.parseDouble(String)</CODE></A> 将其转换为 <tt>double</tt>。如果尝试成功，则此方法返回得到的值。否则返回 <tt>def</tt>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getDouble(java.lang.String, double)">getDouble</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要作为 double 返回其关联值的键。<DD><CODE>def</CODE> - 此首选项节点不具有与 <tt>key</tt> 相关联的值或无法将该关联值解释为 double 时要返回的值。
<DT><B>返回：</B><DD>与此首选项节点的 <tt>key</tt> 相关联的字符串所表示的 double 值；如果该关联值不存在或无法被解释为 double，则返回 <tt>def</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>key</tt> 为 <tt>null</tt>。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#putDouble(java.lang.String, double)"><CODE>Preferences.putDouble(String,double)</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String,String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="putByteArray(java.lang.String, byte[])"><!-- --></A><H3>
putByteArray</H3>
<PRE>
public void <B>putByteArray</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                         byte[]&nbsp;value)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#putByteArray(java.lang.String, byte[])"><CODE>Preferences.putByteArray(String,byte[])</CODE></A> 中的规范实现 <tt>putByteArray</tt> 方法。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putByteArray(java.lang.String, byte[])">putByteArray</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要与字符串形式的 value 相关联的键。。<DD><CODE>value</CODE> - 要与 key 相关联的字符串形式的值。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 key 或 value 为 <tt>null</tt>。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果 key.length() 超过 MAX_KEY_LENGTH 或者 value.length 超过 MAX_VALUE_LENGTH*3/4。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getByteArray(java.lang.String, byte[])"><CODE>Preferences.getByteArray(String,byte[])</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String,String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getByteArray(java.lang.String, byte[])"><!-- --></A><H3>
getByteArray</H3>
<PRE>
public byte[] <B>getByteArray</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                           byte[]&nbsp;def)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#getByteArray(java.lang.String, byte[])"><CODE>Preferences.getByteArray(String,byte[])</CODE></A> 中的规范实现 <tt>getByteArray</tt> 方法。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getByteArray(java.lang.String, byte[])">getByteArray</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>key</CODE> - 要作为字节数组返回其关联值的键。<DD><CODE>def</CODE> - 此首选项节点不具有与 <tt>key</tt> 相关联的值或无法将该关联值解释为字节数组时要返回的值。
<DT><B>返回：</B><DD>与此首选项节点的 <tt>key</tt> 相关联的字符串所表示的字节数组值；如果该关联值不存在或无法被解释为字节数组，则返回 <tt>def</tt>。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 中的类">NullPointerException</A></CODE> - 如果 <tt>key</tt> 为 <tt>null</tt>。（值 <tt>null</tt> 用于 <tt>def</tt> <i>是</i> 允许的。）<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String,String)</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#putByteArray(java.lang.String, byte[])"><CODE>Preferences.putByteArray(String,byte[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="keys()"><!-- --></A><H3>
keys</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>[] <B>keys</B>()
              throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#keys()"><CODE>Preferences.keys()</CODE></A> 中的规范实现 <tt>keys</tt> 方法。

<p>此实现获取首选项节点的锁，检查该节点是否未被移除并调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#keysSpi()"><CODE>keysSpi()</CODE></A>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#keys()">keys</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>在此首选项节点中具有关联值的键数组。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。</DL>
</DD>
</DL>
<HR>

<A NAME="childrenNames()"><!-- --></A><H3>
childrenNames</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>[] <B>childrenNames</B>()
                       throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#childrenNames()"><CODE>Preferences.childrenNames()</CODE></A> 中的规范实现 <tt>children</tt> 方法。

<p>此实现获取首选项节点的锁，检查该节点是否未被移除，构造已初始化为已缓存的子节点名称（此节点“子缓存”中的子节点）的 <tt>TreeSet</tt>，调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNamesSpi()"><CODE>childrenNamesSpi()</CODE></A> 并将所有返回的子名称添加到该 set 中。使用 <tt>toArray</tt> 方法将树 set 的元素转储到 <tt>String</tt> 数组中，并返回此数组。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#childrenNames()">childrenNames</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此首选项节点的子节点名称。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/AbstractPreferences.html#cachedChildren()"><CODE>cachedChildren()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cachedChildren()"><!-- --></A><H3>
cachedChildren</H3>
<PRE>
protected final <A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 中的类">AbstractPreferences</A>[] <B>cachedChildren</B>()</PRE>
<DL>
<DD>返回此节点的所有已知未移除子节点。
<P>
<DD><DL>

<DT><B>返回：</B><DD>此节点的所有已知未移除子节点。</DL>
</DD>
</DL>
<HR>

<A NAME="parent()"><!-- --></A><H3>
parent</H3>
<PRE>
public <A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A> <B>parent</B>()</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#parent()"><CODE>Preferences.parent()</CODE></A> 中的规范实现 <tt>parent</tt> 方法。

<p>此实现获取首选项节点的锁，检查该节点是否未被移除，并返回传递给此节点构造方法的父值。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#parent()">parent</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>首选项节点的父节点。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。</DL>
</DD>
</DL>
<HR>

<A NAME="node(java.lang.String)"><!-- --></A><H3>
node</H3>
<PRE>
public <A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A> <B>node</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;path)</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#node(java.lang.String)"><CODE>Preferences.node(String)</CODE></A> 中的规范实现 <tt>node</tt> 方法。

<p>此实现获取首选项节点的锁并检查该节点是否未被移除。如果 <tt>path</tt> 为 <tt>""</tt>，则返回此节点；如果 <tt>path</tt> 为 <tt>"/"</tt>，则返回此节点的根。如果 <tt>path</tt> 中的第一个字符不是 <tt>'/'</tt>，则此实现将 <tt>path</tt> 分解为标记，并从此节点到指定节点递归式遍历此路径，在遍历的每一个步骤都要“使用”<tt>path</tt> 中的名称和斜杠。在每一个步骤，都要锁定当前节点并为指定节点检查该节点的子缓存。如果未找到，则该名称已经过检查，以确保其长度不超过 <tt>MAX_NAME_LENGTH</tt>。然后，调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A> 方法并将结果存储在此节点的子缓存中。如果新创建的 <tt>Preferences</tt> 对象的 <A HREF="../../../java/util/prefs/AbstractPreferences.html#newNode"><CODE>newNode</CODE></A> 字段为 <tt>true</tt>，并且存在任一节点更改侦听器，则将由事件指派线程所处理的通知事件加入队列。 

<p>没有其他的标记时，此方法将返回在子缓存中找到的最后一个值或 <tt>childSpi</tt> 返回的值。如果在遍历过程中，连续出现两个 <tt>"/"</tt> 标记或者最后一个标记是 <tt>"/"</tt>（而不是名称），则抛出适当的 <tt>IllegalArgumentException</tt>。

<p> 如果 <tt>path</tt> 的第一个字符是 <tt>'/'</tt>（指示绝对路径名），则在将 <tt>path</tt> 分解为标记前，删除此首选项节点的锁，此方法从根（不是从此节点）开始递归式遍历此路径。该递归在其他方面与对相对路径名的描述相同。根据 <A HREF="../../../java/util/prefs/AbstractPreferences.html#lock"><CODE>locking invariant</CODE></A>，从根节点开始遍历前删除此节点上的锁，这对于避免可能发生的死锁是至关重要的。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#node(java.lang.String)">node</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>path</CODE> - 要返回的首选项节点的路径名。
<DT><B>返回：</B><DD>指定的首选项节点。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果路径名无效（即它包含多个连续的斜杠字符，或者以斜杠字符结束并且大于一个 long 字符）。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#flush()"><CODE>Preferences.flush()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="nodeExists(java.lang.String)"><!-- --></A><H3>
nodeExists</H3>
<PRE>
public boolean <B>nodeExists</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;path)
                   throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#nodeExists(java.lang.String)"><CODE>Preferences.nodeExists(String)</CODE></A> 中的规范实现 <tt>nodeExists</tt> 方法。

<p>此实现非常类似于 <A HREF="../../../java/util/prefs/AbstractPreferences.html#node(java.lang.String)"><CODE>node(String)</CODE></A>，不同之处是使用了 <A HREF="../../../java/util/prefs/AbstractPreferences.html#getChild(java.lang.String)"><CODE>getChild(String)</CODE></A> 而没有使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A>。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#nodeExists(java.lang.String)">nodeExists</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>path</CODE> - 要检查其是否存在的节点的路径名。
<DT><B>返回：</B><DD>如果指定的节点存在，则返回 true。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 中的类">IllegalArgumentException</A></CODE> - 如果路径名无效（即它包含多个连续的斜杠字符，或者以斜杠字符结束并且大于一个 long 字符）。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先），并且 <tt>pathname</tt> 不是空字符串 (<tt>""</tt>)。</DL>
</DD>
</DL>
<HR>

<A NAME="removeNode()"><!-- --></A><H3>
removeNode</H3>
<PRE>
public void <B>removeNode</B>()
                throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A> 中的规范实现 <tt>removeNode()</tt> 方法。

<p>此实现检查此节点是否为根；如果是，则抛出适当的异常。然后，它锁定此节点的父节点，并调用递归帮助器方法来遍历以此节点为根的子树。递归方法锁定其所调用的节点，检查它是否未被删除，然后确保已缓存其所有子节点：调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNamesSpi()"><CODE>childrenNamesSpi()</CODE></A> 方法并检查每个返回的子节点名称是否已包含在子缓存中。如果没有缓存子节点，则会调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A> 方法为其创建一个 <tt>Preferences</tt> 实例并将此实例置于子缓存中。然后，帮助器方法在其子缓存所包含的每个节点上递归式自我调用。下一步，它调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNodeSpi()"><CODE>removeNodeSpi()</CODE></A>，将其自身标记为已移除，并从其父节点的子缓存中自我移除。最后，如果存在任何节点更改侦听器，则其会将由事件指派线程所处理的通知事件加入队列。

<p>注意，始终使用所有祖先来调用帮助器方法，直到锁定“未被移除的最近祖先”为止。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#removeNode()">removeNode</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 中的类">UnsupportedOperationException</A></CODE> - 如果在根节点上调用此方法。
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#flush()"><CODE>Preferences.flush()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="name()"><!-- --></A><H3>
name</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A> <B>name</B>()</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#name()"><CODE>Preferences.name()</CODE></A> 中的规范实现 <tt>name</tt> 方法。

<p>此实现仅返回传递给此节点构造方法的名称。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#name()">name</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此首选项节点的名称（相对于其父节点）。</DL>
</DD>
</DL>
<HR>

<A NAME="absolutePath()"><!-- --></A><H3>
absolutePath</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A> <B>absolutePath</B>()</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#absolutePath()"><CODE>Preferences.absolutePath()</CODE></A> 中的规范实现 <tt>absolutePath</tt> 方法。

<p>此实现仅返回构造此节点时计算出的绝对路径名（基于传递给此节点构造方法的名称和传递给此节点祖先构造方法的名称）。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#absolutePath()">absolutePath</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>此首选项节点的绝对路径名。</DL>
</DD>
</DL>
<HR>

<A NAME="isUserNode()"><!-- --></A><H3>
isUserNode</H3>
<PRE>
public boolean <B>isUserNode</B>()</PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#isUserNode()"><CODE>Preferences.isUserNode()</CODE></A> 中的规范实现 <tt>isUserNode</tt> 方法。

<p>此实现将此节点的根节点（在 private 字段中存储）与 <A HREF="../../../java/util/prefs/Preferences.html#userRoot()"><CODE>Preferences.userRoot()</CODE></A> 返回的值相比较。如果两个对象引用相同，则此方法返回 true。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#isUserNode()">isUserNode</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>如果此首选项节点位于用户首选项树中，则返回 <tt>true</tt>；如果其位于系统首选项树中，则返回 <tt>false</tt>。</DL>
</DD>
</DL>
<HR>

<A NAME="addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)"><!-- --></A><H3>
addPreferenceChangeListener</H3>
<PRE>
public void <B>addPreferenceChangeListener</B>(<A HREF="../../../java/util/prefs/PreferenceChangeListener.html" title="java.util.prefs 中的接口">PreferenceChangeListener</A>&nbsp;pcl)</PRE>
<DL>
<DD><B>从类 <CODE><A HREF="../../../java/util/prefs/Preferences.html#addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">Preferences</A></CODE> 复制的描述</B></DD>
<DD>注册指定侦听器以接收此首选项节点的<i>首选项更改事件</i>。将首选项添加到此节点、从此节点移除首选项或者更改与首选项关联的值时都将生成首选项更改事件。（<A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A> 方法<i>不</i> 生成首选项更改事件，该方法只生成<i>节点更改事件</i>。首选项更改事件<i>是</i> 由 <tt>clear</tt> 方法生成的。）

<p>尽管有些实现可以为在 JVM 外进行的更改生成事件，但只有在已注册侦听器所在的 JVM 中所作的更改才能得到保证。事件可能是更改变得持久之前生成的。在此节点的子节点中修改首选项时不生成事件；需要此类事件的调用者必须在每个子节点中注册。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">addPreferenceChangeListener</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>pcl</CODE> - 要添加的首选项更改侦听器。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)"><CODE>Preferences.removePreferenceChangeListener(PreferenceChangeListener)</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#addNodeChangeListener(java.util.prefs.NodeChangeListener)"><CODE>Preferences.addNodeChangeListener(NodeChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)"><!-- --></A><H3>
removePreferenceChangeListener</H3>
<PRE>
public void <B>removePreferenceChangeListener</B>(<A HREF="../../../java/util/prefs/PreferenceChangeListener.html" title="java.util.prefs 中的接口">PreferenceChangeListener</A>&nbsp;pcl)</PRE>
<DL>
<DD><B>从类 <CODE><A HREF="../../../java/util/prefs/Preferences.html#removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">Preferences</A></CODE> 复制的描述</B></DD>
<DD>移除指定首选项更改侦听器，使其不再接收首选项更改事件。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">removePreferenceChangeListener</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>pcl</CODE> - 要移除的首选项更改侦听器。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)"><CODE>Preferences.addPreferenceChangeListener(PreferenceChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addNodeChangeListener(java.util.prefs.NodeChangeListener)"><!-- --></A><H3>
addNodeChangeListener</H3>
<PRE>
public void <B>addNodeChangeListener</B>(<A HREF="../../../java/util/prefs/NodeChangeListener.html" title="java.util.prefs 中的接口">NodeChangeListener</A>&nbsp;ncl)</PRE>
<DL>
<DD><B>从类 <CODE><A HREF="../../../java/util/prefs/Preferences.html#addNodeChangeListener(java.util.prefs.NodeChangeListener)">Preferences</A></CODE> 复制的描述</B></DD>
<DD>注册指定侦听器以接收此节点的<i>节点更改事件</i>。在此节点中添加或删除子节点时，将生成节点更改事件。（单个 <A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A> 调用即可产生多个<i>节点更改事件</i>，每个都对应于以已移除节点为根的子树中的一个节点。）

<p>尽管有些实现可以为在 JVM 外进行的更改生成事件，但只有在注册侦听器所在的 JVM 中所作的更改才能得到保证。事件可能是更改变得持久之前生成的。添加或移除此节点的间接子节点时不生成事件；需要此类事件的调用者必须在每个子节点中注册。

<p>节点的创建难以得到保证。因为节点是基于访问隐式创建的，实现无法确定访问前内部存储中是否存在子节点（例如，内部存储不可访问或已缓存信息过期）。在这些情形下，实现既不要求生成节点更改事件也不禁止这样做。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#addNodeChangeListener(java.util.prefs.NodeChangeListener)">addNodeChangeListener</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>ncl</CODE> - 要添加的 <tt>NodeChangeListener</tt>。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#removeNodeChangeListener(java.util.prefs.NodeChangeListener)"><CODE>Preferences.removeNodeChangeListener(NodeChangeListener)</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)"><CODE>Preferences.addPreferenceChangeListener(PreferenceChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeNodeChangeListener(java.util.prefs.NodeChangeListener)"><!-- --></A><H3>
removeNodeChangeListener</H3>
<PRE>
public void <B>removeNodeChangeListener</B>(<A HREF="../../../java/util/prefs/NodeChangeListener.html" title="java.util.prefs 中的接口">NodeChangeListener</A>&nbsp;ncl)</PRE>
<DL>
<DD><B>从类 <CODE><A HREF="../../../java/util/prefs/Preferences.html#removeNodeChangeListener(java.util.prefs.NodeChangeListener)">Preferences</A></CODE> 复制的描述</B></DD>
<DD>移除指定 <tt>NodeChangeListener</tt>，使其不再接收更改事件。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#removeNodeChangeListener(java.util.prefs.NodeChangeListener)">removeNodeChangeListener</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>ncl</CODE> - 要移除的 <tt>NodeChangeListener</tt>。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#addNodeChangeListener(java.util.prefs.NodeChangeListener)"><CODE>Preferences.addNodeChangeListener(NodeChangeListener)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="putSpi(java.lang.String, java.lang.String)"><!-- --></A><H3>
putSpi</H3>
<PRE>
protected abstract void <B>putSpi</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key,
                               <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;value)</PRE>
<DL>
<DD>将给定的键-值关联置于此首选项节点中。保证 <tt>key</tt> 和 <tt>value</tt> 均为非 null，并且具有合法的长度。此外，还要保证此节点未被移除。（实现者不必检查这些事情。）

<p>利用此节点上保持的锁定调用此方法。
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSpi(java.lang.String)"><!-- --></A><H3>
getSpi</H3>
<PRE>
protected abstract <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A> <B>getSpi</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key)</PRE>
<DL>
<DD>返回与此首选项节点上的指定键相关联的值；如果不存在此键的关联值或此时无法确定该关联值，则返回 <tt>null</tt>。保证 <tt>key</tt> 为非 null。此外，还要保证此节点未被移除。（实现者不必检查这两件事。） 

<p> 一般而言，此方法在任何情形下也不应抛出异常。但是，如果它确实抛出了异常，则该异常将被解释为 <tt>null</tt>，并按 <tt>null</tt> 返回值对待。

<p>利用此节点上保持的锁定调用此方法。
<P>
<DD><DL>

<DT><B>返回：</B><DD>与此首选项节点上的指定键相关联的值；如果不存在此键的关联值或此时无法确定该关联值，则返回 <tt>null</tt>。</DL>
</DD>
</DL>
<HR>

<A NAME="removeSpi(java.lang.String)"><!-- --></A><H3>
removeSpi</H3>
<PRE>
protected abstract void <B>removeSpi</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;key)</PRE>
<DL>
<DD>移除此首选项节点上指定键的关联值（如果有）。保证 <tt>key</tt> 为非 null。此外，还要保证此节点未被移除。（实现者不必检查这两件事。）

<p>利用此节点上保持的锁定调用此方法。
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeNodeSpi()"><!-- --></A><H3>
removeNodeSpi</H3>
<PRE>
protected abstract void <B>removeNodeSpi</B>()
                               throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>移除此首选项节点，该首选项节点及其所包含的所有首选项都将失效。进行此调用时，指定子节点不具有任何子节点（即 <A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A> 方法以自下向上的方式重复调用此方法，在移除节点本身之前首先移除该节点的所有子节点）。

<p>使用此节点及其父节点上保持的锁调用此方法（对 <A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A> 的一次调用即可移除所有祖先）。

<p>在此节点（或祖先）上调用 <tt>flush</tt> 方法之前对节点的移除不必是持久的。

<p>如果此节点抛出 <tt>BackingStoreException</tt>，则该异常将会传播到封闭的 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 调用之外。
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。</DL>
</DD>
</DL>
<HR>

<A NAME="keysSpi()"><!-- --></A><H3>
keysSpi</H3>
<PRE>
protected abstract <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>[] <B>keysSpi</B>()
                             throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>返回在此首选项节点中具有关联值的所有键。（如果此节点不具有任何首选项，则返回数组的大小将为 0。）保证此节点未被移除。

<p>利用此节点上保持的锁调用此方法。

<p>如果此节点抛出 <tt>BackingStoreException</tt>，则该异常将会传播到封闭的 <A HREF="../../../java/util/prefs/AbstractPreferences.html#keys()"><CODE>keys()</CODE></A> 调用之外。
<P>
<DD><DL>

<DT><B>返回：</B><DD>在此首选项节点中具有关联值的键数组。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。</DL>
</DD>
</DL>
<HR>

<A NAME="childrenNamesSpi()"><!-- --></A><H3>
childrenNamesSpi</H3>
<PRE>
protected abstract <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>[] <B>childrenNamesSpi</B>()
                                      throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>返回此首选项节点的子节点名称。（如果此节点不具有任何子节点，则返回数组的大小将为 0。）此方法不必返回任何已缓存节点的名称，但是这样做也没有什么坏处。

<p>利用此节点上保持的锁调用此方法。

<p>如果此节点抛出 <tt>BackingStoreException</tt>，则该异常将会传播到封闭的 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNames()"><CODE>childrenNames()</CODE></A> 调用之外。
<P>
<DD><DL>

<DT><B>返回：</B><DD>包含此首选项节点的子节点名称的数组。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。</DL>
</DD>
</DL>
<HR>

<A NAME="getChild(java.lang.String)"><!-- --></A><H3>
getChild</H3>
<PRE>
protected <A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 中的类">AbstractPreferences</A> <B>getChild</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;nodeName)
                                throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>如果指定的子节点存在，则返回该子节点；如果它不存在，则返回 <tt>null</tt>。保证 <tt>nodeName</tt> 为非 null、非空、不包含斜杠字符 ('/')，并且长度不超过 <A HREF="../../../java/util/prefs/Preferences.html#MAX_NAME_LENGTH"><CODE>Preferences.MAX_NAME_LENGTH</CODE></A> 个字符。此外，还要保证此节点未被移除。（如果选择重写此方法，则实现者不必检查这些事情。）

<p>最后，保证最后一次将指定节点移除后此方法的以前调用或 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(java.lang.String)</CODE></A> 未曾返回它。换句话说，缓存的值始终在首选项中使用，以调用此方法。（如果选择重写此方法，则实现者不必维护它自己以前返回的子节点缓存。）

<p>此实现获取首选项节点的锁，调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNames()"><CODE>childrenNames()</CODE></A> 以获取此节点的子节点的名称数组，并在该数组上迭代，将每个子节点的名称与指定节点名称进行比较。如果子节点名称正确，则调用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A> 方法并返回得到的节点。如果迭代完成时没有找到指定的名称，则返回 <tt>null</tt>。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>nodeName</CODE> - 要搜索的子节点的名称。
<DT><B>返回：</B><DD>如果指定的子节点存在，则返回该子节点；如果它不存在，则返回 null。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。</DL>
</DD>
</DL>
<HR>

<A NAME="childSpi(java.lang.String)"><!-- --></A><H3>
childSpi</H3>
<PRE>
protected abstract <A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 中的类">AbstractPreferences</A> <B>childSpi</B>(<A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A>&nbsp;name)</PRE>
<DL>
<DD>返回此首选项节点的指定子节点；如果该子节点尚未存在，则创建它。保证 <tt>name</tt> 为非 null、非空、不包含斜杠字符 ('/')，并且长度不超过 <A HREF="../../../java/util/prefs/Preferences.html#MAX_NAME_LENGTH"><CODE>Preferences.MAX_NAME_LENGTH</CODE></A> 个字符。此外，还要保证此节点未被移除。（实现者不必检查这些事情。）

<p>最后，保证最后一次将指定节点移除后此方法的以前调用或 <A HREF="../../../java/util/prefs/AbstractPreferences.html#getChild(java.lang.String)"><CODE>getChild(String)</CODE></A> 未曾返回它。换句话说，缓存的值始终在首选项中使用，以调用此方法。子类不必维护它们自己以前返回的子节点缓存。

<p>实现者必须确保返回的节点没有被移除。如果以前移除了此节点的名称相同的子节点，则实现者必须返回一个新构建的 <tt>AbstractPreferences</tt> 节点；一旦移除，<tt>AbstractPreferences</tt> 节点便无法“再生”。
 
<p>如果此方法导致创建了节点，则在此节点或其祖先之一（或子节点）上调用 <tt>flush</tt> 方法之前，不保证该节点是持久的。

<p>利用此节点上保持的锁调用此方法。
<P>
<DD><DL>
<DT><B>参数：</B><DD><CODE>name</CODE> - 要返回的子节点的名称（相对于此首选项节点）。
<DT><B>返回：</B><DD>指定的子节点。</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 中的类">String</A> <B>toString</B>()</PRE>
<DL>
<DD>返回此首选项节点的绝对路径名称。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#toString()">toString</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>返回：</B><DD>该对象的字符串表示形式。</DL>
</DD>
</DL>
<HR>

<A NAME="sync()"><!-- --></A><H3>
sync</H3>
<PRE>
public void <B>sync</B>()
          throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#sync()"><CODE>Preferences.sync()</CODE></A> 中的规范实现 <tt>sync</tt> 方法。

<p>此实现调用锁定此节点的递归帮助器方法，针对该方法调用 syncSpi() ，解除此节点的锁，并在每个“缓存子节点”上递归式调用这一方法。缓存子节点是此节点的子节点，已在此 VM 中创建并且后来没有被移除。实际上，此方法对以此节点为根的“缓存子树”进行深度优先遍历，针对该 subTree 中的每个节点调用 syncSpi()，这时只有该节点是锁定的。注意，是自上向下调用 syncSpi() 的。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#sync()">sync</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 中的类">IllegalStateException</A></CODE> - 如果已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/AbstractPreferences.html#flush()"><CODE>flush()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="syncSpi()"><!-- --></A><H3>
syncSpi</H3>
<PRE>
protected abstract void <B>syncSpi</B>()
                         throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>此方法是在此节点被锁定的情况下调用的。根据协定，此方法用于同步存储在此节点上的所有缓存首选项与存储在内部存储中的所有缓存首选项。（内部存储中不存在此节点是完全可能的，或者因为另一个 VM 删除了它或者因为还没有创建它。）注意，此方法<i>不</i> 应同步此节点的所有子节点中的首选项。如果内部存储自然地同步了整个子树，则鼓励实现者重写 sync()，而不是仅仅重写此方法。

<p>如果此节点抛出 <tt>BackingStoreException</tt>，则该异常将会传播到封闭的 <A HREF="../../../java/util/prefs/AbstractPreferences.html#sync()"><CODE>sync()</CODE></A> 调用之外。
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。</DL>
</DD>
</DL>
<HR>

<A NAME="flush()"><!-- --></A><H3>
flush</H3>
<PRE>
public void <B>flush</B>()
           throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#flush()"><CODE>Preferences.flush()</CODE></A> 中的规范实现 <tt>flush</tt> 方法。

<p>此实现调用锁定此节点的递归帮助器方法，针对该方法调用 flushSpi()，解除此节点的锁，并在每个“缓存子节点”上递归式调用这一方法。缓存子节点是此节点的子节点，已在此 VM 中创建并且后来没有被移除。实际上，此方法对以此节点为根的“缓存子树”进行深度优先遍历，针对该 subTree 中的每个节点调用 flushSpi()，这时只有该节点是锁定的。注意，是自上向下调用 flushSpi() 的。

<p> 如果在已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除的节点上调用此方法，则会在此节点（而非其他节点）上调用 flushSpi()。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#flush()">flush</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/AbstractPreferences.html#flush()"><CODE>flush()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="flushSpi()"><!-- --></A><H3>
flushSpi</H3>
<PRE>
protected abstract void <B>flushSpi</B>()
                          throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>此方法是在此节点被锁定的情况下调用的。根据协定，此方法用于强制执行从此首选项节点到内部存储内容的缓存更改，以保证其持久性。（内部存储中不存在此节点是完全可能的，或者因为另一个 VM 删除了它或者因为还没有创建它。）注意，此方法<i>不</i> 应刷新此节点的所有子节点中的首选项。如果内部存储自然地刷新了整个子树，则鼓励实现者重写 flush()，而不是仅仅重写此方法。

<p>如果此节点抛出 <tt>BackingStoreException</tt>，则该异常将会传播到封闭的 <A HREF="../../../java/util/prefs/AbstractPreferences.html#flush()"><CODE>flush()</CODE></A> 调用之外。
<P>
<DD><DL>

<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果由于内部存储的故障或未能通信而无法完成此操作。</DL>
</DD>
</DL>
<HR>

<A NAME="isRemoved()"><!-- --></A><H3>
isRemoved</H3>
<PRE>
protected boolean <B>isRemoved</B>()</PRE>
<DL>
<DD>当且仅当已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除此节点（或其祖先）时才返回 <tt>true</tt>。此方法在返回用于跟踪此状态的 private 字段内容前锁定此节点。
<P>
<DD><DL>

<DT><B>返回：</B><DD>当且仅当已经使用 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A> 方法移除了此节点（或其祖先）时才返回 <tt>true</tt>。</DL>
</DD>
</DL>
<HR>

<A NAME="exportNode(java.io.OutputStream)"><!-- --></A><H3>
exportNode</H3>
<PRE>
public void <B>exportNode</B>(<A HREF="../../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A>&nbsp;os)
                throws <A HREF="../../../java/io/IOException.html" title="java.io 中的类">IOException</A>,
                       <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#exportNode(java.io.OutputStream)"><CODE>Preferences.exportNode(OutputStream)</CODE></A> 中的规范实现 <tt>exportNode</tt> 方法。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#exportNode(java.io.OutputStream)">exportNode</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>os</CODE> - 根据其内容发出 XML 文档的输出流。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果写入指定的输出流导致一个 <tt>IOException</tt>。
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果无法从内部存储读取首选项数据。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#importPreferences(java.io.InputStream)"><CODE>Preferences.importPreferences(InputStream)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="exportSubtree(java.io.OutputStream)"><!-- --></A><H3>
exportSubtree</H3>
<PRE>
public void <B>exportSubtree</B>(<A HREF="../../../java/io/OutputStream.html" title="java.io 中的类">OutputStream</A>&nbsp;os)
                   throws <A HREF="../../../java/io/IOException.html" title="java.io 中的类">IOException</A>,
                          <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></PRE>
<DL>
<DD>根据 <A HREF="../../../java/util/prefs/Preferences.html#exportSubtree(java.io.OutputStream)"><CODE>Preferences.exportSubtree(OutputStream)</CODE></A> 中的规范实现 <tt>exportSubtree</tt> 方法。
<P>
<DD><DL>
<DT><B>指定者：</B><DD>类 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 中的类">Preferences</A></CODE> 中的 <CODE><A HREF="../../../java/util/prefs/Preferences.html#exportSubtree(java.io.OutputStream)">exportSubtree</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>参数：</B><DD><CODE>os</CODE> - 根据其内容发出 XML 文档的输出流。
<DT><B>抛出：</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 中的类">IOException</A></CODE> - 如果写入指定的输出流导致一个 <tt>IOException</tt>。
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类">BackingStoreException</A></CODE> - 如果无法从内部存储读取首选项数据。<DT><B>另请参见：</B><DD><A HREF="../../../java/util/prefs/Preferences.html#importPreferences(java.io.InputStream)"><CODE>Preferences.importPreferences(InputStream)</CODE></A>, 
<A HREF="../../../java/util/prefs/Preferences.html#exportNode(java.io.OutputStream)"><CODE>Preferences.exportNode(OutputStream)</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="跳过导航链接"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>概述</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>软件包</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>类</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractPreferences.html"><FONT CLASS="NavBarFont1"><B>使用</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>树</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>已过时</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>索引</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>帮助</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed. 6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;上一个类&nbsp;
&nbsp;<A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 中的类"><B>下一个类</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/prefs/AbstractPreferences.html" target="_top"><B>框架</B></A>  &nbsp;
&nbsp;<A HREF="AbstractPreferences.html" target="_top"><B>无框架</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>所有类</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  摘要：&nbsp;嵌套&nbsp;|&nbsp;<A HREF="#field_summary">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_summary">方法</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
详细信息：&nbsp;<A HREF="#field_detail">字段</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">构造方法</A>&nbsp;|&nbsp;<A HREF="#method_detail">方法</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://java.sun.com/cgi-bin/bugreport.cgi">提交错误或意见</a><p>版权所有 2008 Sun Microsystems, Inc. 保留所有权利。请遵守<a href="http://openjdk.java.net/legal/gplv2+ce.html">GNU General Public License, version 2 only</a>。</font>
</BODY>
</HTML>
